
FreeRTOS_VIA2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800200  00003572  00003606  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003572  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a77  00800244  00800244  0000364a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000364a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000367c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000480  00000000  00000000  000036bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003537  00000000  00000000  00003b3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b61  00000000  00000000  00007073  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003303  00000000  00000000  00007bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000010f4  00000000  00000000  0000aed8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000018a8  00000000  00000000  0000bfcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000023c9  00000000  00000000  0000d874  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000408  00000000  00000000  0000fc3d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8d c0       	rjmp	.+282    	; 0x11c <__ctors_end>
       2:	00 00       	nop
       4:	ac c0       	rjmp	.+344    	; 0x15e <__bad_interrupt>
       6:	00 00       	nop
       8:	aa c0       	rjmp	.+340    	; 0x15e <__bad_interrupt>
       a:	00 00       	nop
       c:	a8 c0       	rjmp	.+336    	; 0x15e <__bad_interrupt>
       e:	00 00       	nop
      10:	a6 c0       	rjmp	.+332    	; 0x15e <__bad_interrupt>
      12:	00 00       	nop
      14:	a4 c0       	rjmp	.+328    	; 0x15e <__bad_interrupt>
      16:	00 00       	nop
      18:	a2 c0       	rjmp	.+324    	; 0x15e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a0 c0       	rjmp	.+320    	; 0x15e <__bad_interrupt>
      1e:	00 00       	nop
      20:	9e c0       	rjmp	.+316    	; 0x15e <__bad_interrupt>
      22:	00 00       	nop
      24:	9c c0       	rjmp	.+312    	; 0x15e <__bad_interrupt>
      26:	00 00       	nop
      28:	9a c0       	rjmp	.+308    	; 0x15e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	98 c0       	rjmp	.+304    	; 0x15e <__bad_interrupt>
      2e:	00 00       	nop
      30:	96 c0       	rjmp	.+300    	; 0x15e <__bad_interrupt>
      32:	00 00       	nop
      34:	94 c0       	rjmp	.+296    	; 0x15e <__bad_interrupt>
      36:	00 00       	nop
      38:	92 c0       	rjmp	.+292    	; 0x15e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	90 c0       	rjmp	.+288    	; 0x15e <__bad_interrupt>
      3e:	00 00       	nop
      40:	8e c0       	rjmp	.+284    	; 0x15e <__bad_interrupt>
      42:	00 00       	nop
      44:	8c c0       	rjmp	.+280    	; 0x15e <__bad_interrupt>
      46:	00 00       	nop
      48:	8a c0       	rjmp	.+276    	; 0x15e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	88 c0       	rjmp	.+272    	; 0x15e <__bad_interrupt>
      4e:	00 00       	nop
      50:	86 c0       	rjmp	.+268    	; 0x15e <__bad_interrupt>
      52:	00 00       	nop
      54:	84 c0       	rjmp	.+264    	; 0x15e <__bad_interrupt>
      56:	00 00       	nop
      58:	82 c0       	rjmp	.+260    	; 0x15e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	80 c0       	rjmp	.+256    	; 0x15e <__bad_interrupt>
      5e:	00 00       	nop
      60:	7e c0       	rjmp	.+252    	; 0x15e <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__vector_25>
      68:	0c 94 2e 1a 	jmp	0x345c	; 0x345c <__vector_26>
      6c:	78 c0       	rjmp	.+240    	; 0x15e <__bad_interrupt>
      6e:	00 00       	nop
      70:	76 c0       	rjmp	.+236    	; 0x15e <__bad_interrupt>
      72:	00 00       	nop
      74:	74 c0       	rjmp	.+232    	; 0x15e <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c0       	rjmp	.+228    	; 0x15e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	70 c0       	rjmp	.+224    	; 0x15e <__bad_interrupt>
      7e:	00 00       	nop
      80:	c2 c6       	rjmp	.+3460   	; 0xe06 <__vector_32>
      82:	00 00       	nop
      84:	6c c0       	rjmp	.+216    	; 0x15e <__bad_interrupt>
      86:	00 00       	nop
      88:	6a c0       	rjmp	.+212    	; 0x15e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	68 c0       	rjmp	.+208    	; 0x15e <__bad_interrupt>
      8e:	00 00       	nop
      90:	66 c0       	rjmp	.+204    	; 0x15e <__bad_interrupt>
      92:	00 00       	nop
      94:	64 c0       	rjmp	.+200    	; 0x15e <__bad_interrupt>
      96:	00 00       	nop
      98:	62 c0       	rjmp	.+196    	; 0x15e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	60 c0       	rjmp	.+192    	; 0x15e <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5e c0       	rjmp	.+188    	; 0x15e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5c c0       	rjmp	.+184    	; 0x15e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	5a c0       	rjmp	.+180    	; 0x15e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	58 c0       	rjmp	.+176    	; 0x15e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	56 c0       	rjmp	.+172    	; 0x15e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	54 c0       	rjmp	.+168    	; 0x15e <__bad_interrupt>
      b6:	00 00       	nop
      b8:	52 c0       	rjmp	.+164    	; 0x15e <__bad_interrupt>
      ba:	00 00       	nop
      bc:	50 c0       	rjmp	.+160    	; 0x15e <__bad_interrupt>
      be:	00 00       	nop
      c0:	4e c0       	rjmp	.+156    	; 0x15e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4c c0       	rjmp	.+152    	; 0x15e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	4a c0       	rjmp	.+148    	; 0x15e <__bad_interrupt>
      ca:	00 00       	nop
      cc:	48 c0       	rjmp	.+144    	; 0x15e <__bad_interrupt>
      ce:	00 00       	nop
      d0:	46 c0       	rjmp	.+140    	; 0x15e <__bad_interrupt>
      d2:	00 00       	nop
      d4:	44 c0       	rjmp	.+136    	; 0x15e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	42 c0       	rjmp	.+132    	; 0x15e <__bad_interrupt>
      da:	00 00       	nop
      dc:	40 c0       	rjmp	.+128    	; 0x15e <__bad_interrupt>
      de:	00 00       	nop
      e0:	3e c0       	rjmp	.+124    	; 0x15e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	54 16       	cp	r5, r20
      e6:	54 16       	cp	r5, r20
      e8:	54 16       	cp	r5, r20
      ea:	af 16       	cp	r10, r31
      ec:	8e 16       	cp	r8, r30
      ee:	a9 16       	cp	r10, r25
      f0:	54 16       	cp	r5, r20
      f2:	54 16       	cp	r5, r20
      f4:	af 16       	cp	r10, r31
      f6:	8e 16       	cp	r8, r30

000000f8 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	1f 92       	push	r1
      fe:	1f 92       	push	r1
     100:	cd b7       	in	r28, 0x3d	; 61
     102:	de b7       	in	r29, 0x3e	; 62
     104:	9a 83       	std	Y+2, r25	; 0x02
     106:	89 83       	std	Y+1, r24	; 0x01
     108:	0e 94 7f 12 	call	0x24fe	; 0x24fe <prvCheckTasksWaitingTermination>
     10c:	80 91 3a 0c 	lds	r24, 0x0C3A
     110:	82 30       	cpi	r24, 0x02	; 2
     112:	08 f0       	brcs	.+2      	; 0x116 <prvIdleTask+0x1e>
     114:	03 d5       	rcall	.+2566   	; 0xb1c <vPortYield>
     116:	0e 94 92 19 	call	0x3324	; 0x3324 <vApplicationIdleHook>
     11a:	f6 cf       	rjmp	.-20     	; 0x108 <prvIdleTask+0x10>

0000011c <__ctors_end>:
     11c:	11 24       	eor	r1, r1
     11e:	1f be       	out	0x3f, r1	; 63
     120:	cf ef       	ldi	r28, 0xFF	; 255
     122:	d1 e2       	ldi	r29, 0x21	; 33
     124:	de bf       	out	0x3e, r29	; 62
     126:	cd bf       	out	0x3d, r28	; 61
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	0c bf       	out	0x3c, r16	; 60

0000012c <__do_copy_data>:
     12c:	12 e0       	ldi	r17, 0x02	; 2
     12e:	a0 e0       	ldi	r26, 0x00	; 0
     130:	b2 e0       	ldi	r27, 0x02	; 2
     132:	e2 e7       	ldi	r30, 0x72	; 114
     134:	f5 e3       	ldi	r31, 0x35	; 53
     136:	00 e0       	ldi	r16, 0x00	; 0
     138:	0b bf       	out	0x3b, r16	; 59
     13a:	02 c0       	rjmp	.+4      	; 0x140 <__do_copy_data+0x14>
     13c:	07 90       	elpm	r0, Z+
     13e:	0d 92       	st	X+, r0
     140:	a4 34       	cpi	r26, 0x44	; 68
     142:	b1 07       	cpc	r27, r17
     144:	d9 f7       	brne	.-10     	; 0x13c <__do_copy_data+0x10>

00000146 <__do_clear_bss>:
     146:	2c e0       	ldi	r18, 0x0C	; 12
     148:	a4 e4       	ldi	r26, 0x44	; 68
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	01 c0       	rjmp	.+2      	; 0x150 <.do_clear_bss_start>

0000014e <.do_clear_bss_loop>:
     14e:	1d 92       	st	X+, r1

00000150 <.do_clear_bss_start>:
     150:	ab 3b       	cpi	r26, 0xBB	; 187
     152:	b2 07       	cpc	r27, r18
     154:	e1 f7       	brne	.-8      	; 0x14e <.do_clear_bss_loop>
     156:	0e 94 e7 18 	call	0x31ce	; 0x31ce <main>
     15a:	0c 94 b7 1a 	jmp	0x356e	; 0x356e <_exit>

0000015e <__bad_interrupt>:
     15e:	0c 94 9b 19 	jmp	0x3336	; 0x3336 <__vector_default>

00000162 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
     166:	1f 92       	push	r1
     168:	1f 92       	push	r1
     16a:	cd b7       	in	r28, 0x3d	; 61
     16c:	de b7       	in	r29, 0x3e	; 62
     16e:	9a 83       	std	Y+2, r25	; 0x02
     170:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     172:	89 81       	ldd	r24, Y+1	; 0x01
     174:	9a 81       	ldd	r25, Y+2	; 0x02
     176:	9c 01       	movw	r18, r24
     178:	2d 5f       	subi	r18, 0xFD	; 253
     17a:	3f 4f       	sbci	r19, 0xFF	; 255
     17c:	89 81       	ldd	r24, Y+1	; 0x01
     17e:	9a 81       	ldd	r25, Y+2	; 0x02
     180:	fc 01       	movw	r30, r24
     182:	32 83       	std	Z+2, r19	; 0x02
     184:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     186:	89 81       	ldd	r24, Y+1	; 0x01
     188:	9a 81       	ldd	r25, Y+2	; 0x02
     18a:	2f ef       	ldi	r18, 0xFF	; 255
     18c:	3f ef       	ldi	r19, 0xFF	; 255
     18e:	fc 01       	movw	r30, r24
     190:	34 83       	std	Z+4, r19	; 0x04
     192:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     194:	89 81       	ldd	r24, Y+1	; 0x01
     196:	9a 81       	ldd	r25, Y+2	; 0x02
     198:	9c 01       	movw	r18, r24
     19a:	2d 5f       	subi	r18, 0xFD	; 253
     19c:	3f 4f       	sbci	r19, 0xFF	; 255
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	9a 81       	ldd	r25, Y+2	; 0x02
     1a2:	fc 01       	movw	r30, r24
     1a4:	36 83       	std	Z+6, r19	; 0x06
     1a6:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a8:	89 81       	ldd	r24, Y+1	; 0x01
     1aa:	9a 81       	ldd	r25, Y+2	; 0x02
     1ac:	9c 01       	movw	r18, r24
     1ae:	2d 5f       	subi	r18, 0xFD	; 253
     1b0:	3f 4f       	sbci	r19, 0xFF	; 255
     1b2:	89 81       	ldd	r24, Y+1	; 0x01
     1b4:	9a 81       	ldd	r25, Y+2	; 0x02
     1b6:	fc 01       	movw	r30, r24
     1b8:	30 87       	std	Z+8, r19	; 0x08
     1ba:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1bc:	89 81       	ldd	r24, Y+1	; 0x01
     1be:	9a 81       	ldd	r25, Y+2	; 0x02
     1c0:	fc 01       	movw	r30, r24
     1c2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     1c4:	0f 90       	pop	r0
     1c6:	0f 90       	pop	r0
     1c8:	df 91       	pop	r29
     1ca:	cf 91       	pop	r28
     1cc:	08 95       	ret

000001ce <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     1ce:	cf 93       	push	r28
     1d0:	df 93       	push	r29
     1d2:	1f 92       	push	r1
     1d4:	1f 92       	push	r1
     1d6:	cd b7       	in	r28, 0x3d	; 61
     1d8:	de b7       	in	r29, 0x3e	; 62
     1da:	9a 83       	std	Y+2, r25	; 0x02
     1dc:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	9a 81       	ldd	r25, Y+2	; 0x02
     1e2:	fc 01       	movw	r30, r24
     1e4:	11 86       	std	Z+9, r1	; 0x09
     1e6:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	df 91       	pop	r29
     1ee:	cf 91       	pop	r28
     1f0:	08 95       	ret

000001f2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1f2:	cf 93       	push	r28
     1f4:	df 93       	push	r29
     1f6:	00 d0       	rcall	.+0      	; 0x1f8 <vListInsertEnd+0x6>
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <vListInsertEnd+0x8>
     1fa:	cd b7       	in	r28, 0x3d	; 61
     1fc:	de b7       	in	r29, 0x3e	; 62
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03
     202:	7e 83       	std	Y+6, r23	; 0x06
     204:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     206:	8b 81       	ldd	r24, Y+3	; 0x03
     208:	9c 81       	ldd	r25, Y+4	; 0x04
     20a:	fc 01       	movw	r30, r24
     20c:	81 81       	ldd	r24, Z+1	; 0x01
     20e:	92 81       	ldd	r25, Z+2	; 0x02
     210:	9a 83       	std	Y+2, r25	; 0x02
     212:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     214:	8d 81       	ldd	r24, Y+5	; 0x05
     216:	9e 81       	ldd	r25, Y+6	; 0x06
     218:	29 81       	ldd	r18, Y+1	; 0x01
     21a:	3a 81       	ldd	r19, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	33 83       	std	Z+3, r19	; 0x03
     220:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     222:	89 81       	ldd	r24, Y+1	; 0x01
     224:	9a 81       	ldd	r25, Y+2	; 0x02
     226:	fc 01       	movw	r30, r24
     228:	24 81       	ldd	r18, Z+4	; 0x04
     22a:	35 81       	ldd	r19, Z+5	; 0x05
     22c:	8d 81       	ldd	r24, Y+5	; 0x05
     22e:	9e 81       	ldd	r25, Y+6	; 0x06
     230:	fc 01       	movw	r30, r24
     232:	35 83       	std	Z+5, r19	; 0x05
     234:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	9a 81       	ldd	r25, Y+2	; 0x02
     23a:	fc 01       	movw	r30, r24
     23c:	84 81       	ldd	r24, Z+4	; 0x04
     23e:	95 81       	ldd	r25, Z+5	; 0x05
     240:	2d 81       	ldd	r18, Y+5	; 0x05
     242:	3e 81       	ldd	r19, Y+6	; 0x06
     244:	fc 01       	movw	r30, r24
     246:	33 83       	std	Z+3, r19	; 0x03
     248:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     24a:	89 81       	ldd	r24, Y+1	; 0x01
     24c:	9a 81       	ldd	r25, Y+2	; 0x02
     24e:	2d 81       	ldd	r18, Y+5	; 0x05
     250:	3e 81       	ldd	r19, Y+6	; 0x06
     252:	fc 01       	movw	r30, r24
     254:	35 83       	std	Z+5, r19	; 0x05
     256:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     258:	8d 81       	ldd	r24, Y+5	; 0x05
     25a:	9e 81       	ldd	r25, Y+6	; 0x06
     25c:	2b 81       	ldd	r18, Y+3	; 0x03
     25e:	3c 81       	ldd	r19, Y+4	; 0x04
     260:	fc 01       	movw	r30, r24
     262:	31 87       	std	Z+9, r19	; 0x09
     264:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     266:	8b 81       	ldd	r24, Y+3	; 0x03
     268:	9c 81       	ldd	r25, Y+4	; 0x04
     26a:	fc 01       	movw	r30, r24
     26c:	80 81       	ld	r24, Z
     26e:	21 e0       	ldi	r18, 0x01	; 1
     270:	28 0f       	add	r18, r24
     272:	8b 81       	ldd	r24, Y+3	; 0x03
     274:	9c 81       	ldd	r25, Y+4	; 0x04
     276:	fc 01       	movw	r30, r24
     278:	20 83       	st	Z, r18
}
     27a:	26 96       	adiw	r28, 0x06	; 6
     27c:	0f b6       	in	r0, 0x3f	; 63
     27e:	f8 94       	cli
     280:	de bf       	out	0x3e, r29	; 62
     282:	0f be       	out	0x3f, r0	; 63
     284:	cd bf       	out	0x3d, r28	; 61
     286:	df 91       	pop	r29
     288:	cf 91       	pop	r28
     28a:	08 95       	ret

0000028c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     28c:	cf 93       	push	r28
     28e:	df 93       	push	r29
     290:	cd b7       	in	r28, 0x3d	; 61
     292:	de b7       	in	r29, 0x3e	; 62
     294:	28 97       	sbiw	r28, 0x08	; 8
     296:	0f b6       	in	r0, 0x3f	; 63
     298:	f8 94       	cli
     29a:	de bf       	out	0x3e, r29	; 62
     29c:	0f be       	out	0x3f, r0	; 63
     29e:	cd bf       	out	0x3d, r28	; 61
     2a0:	9e 83       	std	Y+6, r25	; 0x06
     2a2:	8d 83       	std	Y+5, r24	; 0x05
     2a4:	78 87       	std	Y+8, r23	; 0x08
     2a6:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2a8:	8f 81       	ldd	r24, Y+7	; 0x07
     2aa:	98 85       	ldd	r25, Y+8	; 0x08
     2ac:	fc 01       	movw	r30, r24
     2ae:	80 81       	ld	r24, Z
     2b0:	91 81       	ldd	r25, Z+1	; 0x01
     2b2:	9c 83       	std	Y+4, r25	; 0x04
     2b4:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2b6:	8b 81       	ldd	r24, Y+3	; 0x03
     2b8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ba:	01 96       	adiw	r24, 0x01	; 1
     2bc:	41 f4       	brne	.+16     	; 0x2ce <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2be:	8d 81       	ldd	r24, Y+5	; 0x05
     2c0:	9e 81       	ldd	r25, Y+6	; 0x06
     2c2:	fc 01       	movw	r30, r24
     2c4:	87 81       	ldd	r24, Z+7	; 0x07
     2c6:	90 85       	ldd	r25, Z+8	; 0x08
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	1a c0       	rjmp	.+52     	; 0x302 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ce:	8d 81       	ldd	r24, Y+5	; 0x05
     2d0:	9e 81       	ldd	r25, Y+6	; 0x06
     2d2:	03 96       	adiw	r24, 0x03	; 3
     2d4:	9a 83       	std	Y+2, r25	; 0x02
     2d6:	89 83       	std	Y+1, r24	; 0x01
     2d8:	07 c0       	rjmp	.+14     	; 0x2e8 <vListInsert+0x5c>
     2da:	89 81       	ldd	r24, Y+1	; 0x01
     2dc:	9a 81       	ldd	r25, Y+2	; 0x02
     2de:	fc 01       	movw	r30, r24
     2e0:	82 81       	ldd	r24, Z+2	; 0x02
     2e2:	93 81       	ldd	r25, Z+3	; 0x03
     2e4:	9a 83       	std	Y+2, r25	; 0x02
     2e6:	89 83       	std	Y+1, r24	; 0x01
     2e8:	89 81       	ldd	r24, Y+1	; 0x01
     2ea:	9a 81       	ldd	r25, Y+2	; 0x02
     2ec:	fc 01       	movw	r30, r24
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	fc 01       	movw	r30, r24
     2f4:	20 81       	ld	r18, Z
     2f6:	31 81       	ldd	r19, Z+1	; 0x01
     2f8:	8b 81       	ldd	r24, Y+3	; 0x03
     2fa:	9c 81       	ldd	r25, Y+4	; 0x04
     2fc:	82 17       	cp	r24, r18
     2fe:	93 07       	cpc	r25, r19
     300:	60 f7       	brcc	.-40     	; 0x2da <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     302:	89 81       	ldd	r24, Y+1	; 0x01
     304:	9a 81       	ldd	r25, Y+2	; 0x02
     306:	fc 01       	movw	r30, r24
     308:	22 81       	ldd	r18, Z+2	; 0x02
     30a:	33 81       	ldd	r19, Z+3	; 0x03
     30c:	8f 81       	ldd	r24, Y+7	; 0x07
     30e:	98 85       	ldd	r25, Y+8	; 0x08
     310:	fc 01       	movw	r30, r24
     312:	33 83       	std	Z+3, r19	; 0x03
     314:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     316:	8f 81       	ldd	r24, Y+7	; 0x07
     318:	98 85       	ldd	r25, Y+8	; 0x08
     31a:	fc 01       	movw	r30, r24
     31c:	82 81       	ldd	r24, Z+2	; 0x02
     31e:	93 81       	ldd	r25, Z+3	; 0x03
     320:	2f 81       	ldd	r18, Y+7	; 0x07
     322:	38 85       	ldd	r19, Y+8	; 0x08
     324:	fc 01       	movw	r30, r24
     326:	35 83       	std	Z+5, r19	; 0x05
     328:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     32a:	8f 81       	ldd	r24, Y+7	; 0x07
     32c:	98 85       	ldd	r25, Y+8	; 0x08
     32e:	29 81       	ldd	r18, Y+1	; 0x01
     330:	3a 81       	ldd	r19, Y+2	; 0x02
     332:	fc 01       	movw	r30, r24
     334:	35 83       	std	Z+5, r19	; 0x05
     336:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     338:	89 81       	ldd	r24, Y+1	; 0x01
     33a:	9a 81       	ldd	r25, Y+2	; 0x02
     33c:	2f 81       	ldd	r18, Y+7	; 0x07
     33e:	38 85       	ldd	r19, Y+8	; 0x08
     340:	fc 01       	movw	r30, r24
     342:	33 83       	std	Z+3, r19	; 0x03
     344:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     346:	8f 81       	ldd	r24, Y+7	; 0x07
     348:	98 85       	ldd	r25, Y+8	; 0x08
     34a:	2d 81       	ldd	r18, Y+5	; 0x05
     34c:	3e 81       	ldd	r19, Y+6	; 0x06
     34e:	fc 01       	movw	r30, r24
     350:	31 87       	std	Z+9, r19	; 0x09
     352:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     354:	8d 81       	ldd	r24, Y+5	; 0x05
     356:	9e 81       	ldd	r25, Y+6	; 0x06
     358:	fc 01       	movw	r30, r24
     35a:	80 81       	ld	r24, Z
     35c:	21 e0       	ldi	r18, 0x01	; 1
     35e:	28 0f       	add	r18, r24
     360:	8d 81       	ldd	r24, Y+5	; 0x05
     362:	9e 81       	ldd	r25, Y+6	; 0x06
     364:	fc 01       	movw	r30, r24
     366:	20 83       	st	Z, r18
}
     368:	28 96       	adiw	r28, 0x08	; 8
     36a:	0f b6       	in	r0, 0x3f	; 63
     36c:	f8 94       	cli
     36e:	de bf       	out	0x3e, r29	; 62
     370:	0f be       	out	0x3f, r0	; 63
     372:	cd bf       	out	0x3d, r28	; 61
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	00 d0       	rcall	.+0      	; 0x380 <uxListRemove+0x6>
     380:	1f 92       	push	r1
     382:	cd b7       	in	r28, 0x3d	; 61
     384:	de b7       	in	r29, 0x3e	; 62
     386:	9c 83       	std	Y+4, r25	; 0x04
     388:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     38a:	8b 81       	ldd	r24, Y+3	; 0x03
     38c:	9c 81       	ldd	r25, Y+4	; 0x04
     38e:	fc 01       	movw	r30, r24
     390:	80 85       	ldd	r24, Z+8	; 0x08
     392:	91 85       	ldd	r25, Z+9	; 0x09
     394:	9a 83       	std	Y+2, r25	; 0x02
     396:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     398:	8b 81       	ldd	r24, Y+3	; 0x03
     39a:	9c 81       	ldd	r25, Y+4	; 0x04
     39c:	fc 01       	movw	r30, r24
     39e:	82 81       	ldd	r24, Z+2	; 0x02
     3a0:	93 81       	ldd	r25, Z+3	; 0x03
     3a2:	2b 81       	ldd	r18, Y+3	; 0x03
     3a4:	3c 81       	ldd	r19, Y+4	; 0x04
     3a6:	f9 01       	movw	r30, r18
     3a8:	24 81       	ldd	r18, Z+4	; 0x04
     3aa:	35 81       	ldd	r19, Z+5	; 0x05
     3ac:	fc 01       	movw	r30, r24
     3ae:	35 83       	std	Z+5, r19	; 0x05
     3b0:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3b2:	8b 81       	ldd	r24, Y+3	; 0x03
     3b4:	9c 81       	ldd	r25, Y+4	; 0x04
     3b6:	fc 01       	movw	r30, r24
     3b8:	84 81       	ldd	r24, Z+4	; 0x04
     3ba:	95 81       	ldd	r25, Z+5	; 0x05
     3bc:	2b 81       	ldd	r18, Y+3	; 0x03
     3be:	3c 81       	ldd	r19, Y+4	; 0x04
     3c0:	f9 01       	movw	r30, r18
     3c2:	22 81       	ldd	r18, Z+2	; 0x02
     3c4:	33 81       	ldd	r19, Z+3	; 0x03
     3c6:	fc 01       	movw	r30, r24
     3c8:	33 83       	std	Z+3, r19	; 0x03
     3ca:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3cc:	89 81       	ldd	r24, Y+1	; 0x01
     3ce:	9a 81       	ldd	r25, Y+2	; 0x02
     3d0:	fc 01       	movw	r30, r24
     3d2:	21 81       	ldd	r18, Z+1	; 0x01
     3d4:	32 81       	ldd	r19, Z+2	; 0x02
     3d6:	8b 81       	ldd	r24, Y+3	; 0x03
     3d8:	9c 81       	ldd	r25, Y+4	; 0x04
     3da:	28 17       	cp	r18, r24
     3dc:	39 07       	cpc	r19, r25
     3de:	51 f4       	brne	.+20     	; 0x3f4 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3e0:	8b 81       	ldd	r24, Y+3	; 0x03
     3e2:	9c 81       	ldd	r25, Y+4	; 0x04
     3e4:	fc 01       	movw	r30, r24
     3e6:	24 81       	ldd	r18, Z+4	; 0x04
     3e8:	35 81       	ldd	r19, Z+5	; 0x05
     3ea:	89 81       	ldd	r24, Y+1	; 0x01
     3ec:	9a 81       	ldd	r25, Y+2	; 0x02
     3ee:	fc 01       	movw	r30, r24
     3f0:	32 83       	std	Z+2, r19	; 0x02
     3f2:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3f4:	8b 81       	ldd	r24, Y+3	; 0x03
     3f6:	9c 81       	ldd	r25, Y+4	; 0x04
     3f8:	fc 01       	movw	r30, r24
     3fa:	11 86       	std	Z+9, r1	; 0x09
     3fc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3fe:	89 81       	ldd	r24, Y+1	; 0x01
     400:	9a 81       	ldd	r25, Y+2	; 0x02
     402:	fc 01       	movw	r30, r24
     404:	80 81       	ld	r24, Z
     406:	2f ef       	ldi	r18, 0xFF	; 255
     408:	28 0f       	add	r18, r24
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	9a 81       	ldd	r25, Y+2	; 0x02
     40e:	fc 01       	movw	r30, r24
     410:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     412:	89 81       	ldd	r24, Y+1	; 0x01
     414:	9a 81       	ldd	r25, Y+2	; 0x02
     416:	fc 01       	movw	r30, r24
     418:	80 81       	ld	r24, Z
}
     41a:	0f 90       	pop	r0
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	08 95       	ret

00000428 <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	1f 92       	push	r1
     42e:	1f 92       	push	r1
     430:	cd b7       	in	r28, 0x3d	; 61
     432:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     434:	39 c0       	rjmp	.+114    	; 0x4a8 <prvCheckPendingReadyList+0x80>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     436:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     438:	80 91 5f 02 	lds	r24, 0x025F
     43c:	90 91 60 02 	lds	r25, 0x0260
     440:	fc 01       	movw	r30, r24
     442:	86 81       	ldd	r24, Z+6	; 0x06
     444:	97 81       	ldd	r25, Z+7	; 0x07
     446:	9a 83       	std	Y+2, r25	; 0x02
     448:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     44a:	89 81       	ldd	r24, Y+1	; 0x01
     44c:	9a 81       	ldd	r25, Y+2	; 0x02
     44e:	0c 96       	adiw	r24, 0x0c	; 12
     450:	94 df       	rcall	.-216    	; 0x37a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     452:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	9a 81       	ldd	r25, Y+2	; 0x02
     458:	02 96       	adiw	r24, 0x02	; 2
     45a:	8f df       	rcall	.-226    	; 0x37a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     45c:	89 81       	ldd	r24, Y+1	; 0x01
     45e:	9a 81       	ldd	r25, Y+2	; 0x02
     460:	fc 01       	movw	r30, r24
     462:	96 89       	ldd	r25, Z+22	; 0x16
     464:	80 91 65 02 	lds	r24, 0x0265
     468:	89 17       	cp	r24, r25
     46a:	30 f4       	brcc	.+12     	; 0x478 <prvCheckPendingReadyList+0x50>
     46c:	89 81       	ldd	r24, Y+1	; 0x01
     46e:	9a 81       	ldd	r25, Y+2	; 0x02
     470:	fc 01       	movw	r30, r24
     472:	86 89       	ldd	r24, Z+22	; 0x16
     474:	80 93 65 02 	sts	0x0265, r24
     478:	89 81       	ldd	r24, Y+1	; 0x01
     47a:	9a 81       	ldd	r25, Y+2	; 0x02
     47c:	ac 01       	movw	r20, r24
     47e:	4e 5f       	subi	r20, 0xFE	; 254
     480:	5f 4f       	sbci	r21, 0xFF	; 255
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	9a 81       	ldd	r25, Y+2	; 0x02
     486:	fc 01       	movw	r30, r24
     488:	86 89       	ldd	r24, Z+22	; 0x16
     48a:	28 2f       	mov	r18, r24
     48c:	30 e0       	ldi	r19, 0x00	; 0
     48e:	c9 01       	movw	r24, r18
     490:	88 0f       	add	r24, r24
     492:	99 1f       	adc	r25, r25
     494:	88 0f       	add	r24, r24
     496:	99 1f       	adc	r25, r25
     498:	88 0f       	add	r24, r24
     49a:	99 1f       	adc	r25, r25
     49c:	82 0f       	add	r24, r18
     49e:	93 1f       	adc	r25, r19
     4a0:	8c 5b       	subi	r24, 0xBC	; 188
     4a2:	9d 4f       	sbci	r25, 0xFD	; 253
     4a4:	ba 01       	movw	r22, r20
     4a6:	a5 de       	rcall	.-694    	; 0x1f2 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     4a8:	80 91 5a 02 	lds	r24, 0x025A
     4ac:	88 23       	and	r24, r24
     4ae:	09 f0       	breq	.+2      	; 0x4b2 <prvCheckPendingReadyList+0x8a>
     4b0:	c2 cf       	rjmp	.-124    	; 0x436 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     4b2:	0f 90       	pop	r0
     4b4:	0f 90       	pop	r0
     4b6:	df 91       	pop	r29
     4b8:	cf 91       	pop	r28
     4ba:	08 95       	ret

000004bc <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4bc:	cf 93       	push	r28
     4be:	df 93       	push	r29
     4c0:	00 d0       	rcall	.+0      	; 0x4c2 <prvCheckDelayedList+0x6>
     4c2:	1f 92       	push	r1
     4c4:	cd b7       	in	r28, 0x3d	; 61
     4c6:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4c8:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
     4cc:	9c 01       	movw	r18, r24
     4ce:	80 91 68 02 	lds	r24, 0x0268
     4d2:	90 91 69 02 	lds	r25, 0x0269
     4d6:	a9 01       	movw	r20, r18
     4d8:	48 1b       	sub	r20, r24
     4da:	59 0b       	sbc	r21, r25
     4dc:	ca 01       	movw	r24, r20
     4de:	90 93 6b 02 	sts	0x026B, r25
     4e2:	80 93 6a 02 	sts	0x026A, r24
	while( xPassedTicks )
     4e6:	86 c0       	rjmp	.+268    	; 0x5f4 <prvCheckDelayedList+0x138>
	{
		xCoRoutineTickCount++;
     4e8:	80 91 66 02 	lds	r24, 0x0266
     4ec:	90 91 67 02 	lds	r25, 0x0267
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	90 93 67 02 	sts	0x0267, r25
     4f6:	80 93 66 02 	sts	0x0266, r24
		xPassedTicks--;
     4fa:	80 91 6a 02 	lds	r24, 0x026A
     4fe:	90 91 6b 02 	lds	r25, 0x026B
     502:	01 97       	sbiw	r24, 0x01	; 1
     504:	90 93 6b 02 	sts	0x026B, r25
     508:	80 93 6a 02 	sts	0x026A, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     50c:	80 91 66 02 	lds	r24, 0x0266
     510:	90 91 67 02 	lds	r25, 0x0267
     514:	89 2b       	or	r24, r25
     516:	a1 f4       	brne	.+40     	; 0x540 <prvCheckDelayedList+0x84>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     518:	80 91 56 02 	lds	r24, 0x0256
     51c:	90 91 57 02 	lds	r25, 0x0257
     520:	9a 83       	std	Y+2, r25	; 0x02
     522:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     524:	80 91 58 02 	lds	r24, 0x0258
     528:	90 91 59 02 	lds	r25, 0x0259
     52c:	90 93 57 02 	sts	0x0257, r25
     530:	80 93 56 02 	sts	0x0256, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     534:	89 81       	ldd	r24, Y+1	; 0x01
     536:	9a 81       	ldd	r25, Y+2	; 0x02
     538:	90 93 59 02 	sts	0x0259, r25
     53c:	80 93 58 02 	sts	0x0258, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     540:	50 c0       	rjmp	.+160    	; 0x5e2 <prvCheckDelayedList+0x126>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     542:	80 91 56 02 	lds	r24, 0x0256
     546:	90 91 57 02 	lds	r25, 0x0257
     54a:	fc 01       	movw	r30, r24
     54c:	85 81       	ldd	r24, Z+5	; 0x05
     54e:	96 81       	ldd	r25, Z+6	; 0x06
     550:	fc 01       	movw	r30, r24
     552:	86 81       	ldd	r24, Z+6	; 0x06
     554:	97 81       	ldd	r25, Z+7	; 0x07
     556:	9c 83       	std	Y+4, r25	; 0x04
     558:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     55a:	8b 81       	ldd	r24, Y+3	; 0x03
     55c:	9c 81       	ldd	r25, Y+4	; 0x04
     55e:	fc 01       	movw	r30, r24
     560:	22 81       	ldd	r18, Z+2	; 0x02
     562:	33 81       	ldd	r19, Z+3	; 0x03
     564:	80 91 66 02 	lds	r24, 0x0266
     568:	90 91 67 02 	lds	r25, 0x0267
     56c:	82 17       	cp	r24, r18
     56e:	93 07       	cpc	r25, r19
     570:	08 f4       	brcc	.+2      	; 0x574 <prvCheckDelayedList+0xb8>
			{
				/* Timeout not yet expired. */
				break;
     572:	40 c0       	rjmp	.+128    	; 0x5f4 <prvCheckDelayedList+0x138>
			}

			portDISABLE_INTERRUPTS();
     574:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     576:	8b 81       	ldd	r24, Y+3	; 0x03
     578:	9c 81       	ldd	r25, Y+4	; 0x04
     57a:	02 96       	adiw	r24, 0x02	; 2
     57c:	fe de       	rcall	.-516    	; 0x37a <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     57e:	8b 81       	ldd	r24, Y+3	; 0x03
     580:	9c 81       	ldd	r25, Y+4	; 0x04
     582:	fc 01       	movw	r30, r24
     584:	84 89       	ldd	r24, Z+20	; 0x14
     586:	95 89       	ldd	r25, Z+21	; 0x15
     588:	89 2b       	or	r24, r25
     58a:	21 f0       	breq	.+8      	; 0x594 <prvCheckDelayedList+0xd8>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     58c:	8b 81       	ldd	r24, Y+3	; 0x03
     58e:	9c 81       	ldd	r25, Y+4	; 0x04
     590:	0c 96       	adiw	r24, 0x0c	; 12
     592:	f3 de       	rcall	.-538    	; 0x37a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     594:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	96 89       	ldd	r25, Z+22	; 0x16
     59e:	80 91 65 02 	lds	r24, 0x0265
     5a2:	89 17       	cp	r24, r25
     5a4:	30 f4       	brcc	.+12     	; 0x5b2 <prvCheckDelayedList+0xf6>
     5a6:	8b 81       	ldd	r24, Y+3	; 0x03
     5a8:	9c 81       	ldd	r25, Y+4	; 0x04
     5aa:	fc 01       	movw	r30, r24
     5ac:	86 89       	ldd	r24, Z+22	; 0x16
     5ae:	80 93 65 02 	sts	0x0265, r24
     5b2:	8b 81       	ldd	r24, Y+3	; 0x03
     5b4:	9c 81       	ldd	r25, Y+4	; 0x04
     5b6:	ac 01       	movw	r20, r24
     5b8:	4e 5f       	subi	r20, 0xFE	; 254
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	8b 81       	ldd	r24, Y+3	; 0x03
     5be:	9c 81       	ldd	r25, Y+4	; 0x04
     5c0:	fc 01       	movw	r30, r24
     5c2:	86 89       	ldd	r24, Z+22	; 0x16
     5c4:	28 2f       	mov	r18, r24
     5c6:	30 e0       	ldi	r19, 0x00	; 0
     5c8:	c9 01       	movw	r24, r18
     5ca:	88 0f       	add	r24, r24
     5cc:	99 1f       	adc	r25, r25
     5ce:	88 0f       	add	r24, r24
     5d0:	99 1f       	adc	r25, r25
     5d2:	88 0f       	add	r24, r24
     5d4:	99 1f       	adc	r25, r25
     5d6:	82 0f       	add	r24, r18
     5d8:	93 1f       	adc	r25, r19
     5da:	8c 5b       	subi	r24, 0xBC	; 188
     5dc:	9d 4f       	sbci	r25, 0xFD	; 253
     5de:	ba 01       	movw	r22, r20
     5e0:	08 de       	rcall	.-1008   	; 0x1f2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5e2:	80 91 56 02 	lds	r24, 0x0256
     5e6:	90 91 57 02 	lds	r25, 0x0257
     5ea:	fc 01       	movw	r30, r24
     5ec:	80 81       	ld	r24, Z
     5ee:	88 23       	and	r24, r24
     5f0:	09 f0       	breq	.+2      	; 0x5f4 <prvCheckDelayedList+0x138>
     5f2:	a7 cf       	rjmp	.-178    	; 0x542 <prvCheckDelayedList+0x86>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5f4:	80 91 6a 02 	lds	r24, 0x026A
     5f8:	90 91 6b 02 	lds	r25, 0x026B
     5fc:	89 2b       	or	r24, r25
     5fe:	09 f0       	breq	.+2      	; 0x602 <prvCheckDelayedList+0x146>
     600:	73 cf       	rjmp	.-282    	; 0x4e8 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     602:	80 91 66 02 	lds	r24, 0x0266
     606:	90 91 67 02 	lds	r25, 0x0267
     60a:	90 93 69 02 	sts	0x0269, r25
     60e:	80 93 68 02 	sts	0x0268, r24
}
     612:	0f 90       	pop	r0
     614:	0f 90       	pop	r0
     616:	0f 90       	pop	r0
     618:	0f 90       	pop	r0
     61a:	df 91       	pop	r29
     61c:	cf 91       	pop	r28
     61e:	08 95       	ret

00000620 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     620:	cf 93       	push	r28
     622:	df 93       	push	r29
     624:	1f 92       	push	r1
     626:	1f 92       	push	r1
     628:	cd b7       	in	r28, 0x3d	; 61
     62a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     62c:	fd de       	rcall	.-518    	; 0x428 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     62e:	46 df       	rcall	.-372    	; 0x4bc <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     630:	0a c0       	rjmp	.+20     	; 0x646 <vCoRoutineSchedule+0x26>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     632:	80 91 65 02 	lds	r24, 0x0265
     636:	88 23       	and	r24, r24
     638:	09 f4       	brne	.+2      	; 0x63c <vCoRoutineSchedule+0x1c>
		{
			/* No more co-routines to check. */
			return;
     63a:	6f c0       	rjmp	.+222    	; 0x71a <vCoRoutineSchedule+0xfa>
		}
		--uxTopCoRoutineReadyPriority;
     63c:	80 91 65 02 	lds	r24, 0x0265
     640:	81 50       	subi	r24, 0x01	; 1
     642:	80 93 65 02 	sts	0x0265, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     646:	80 91 65 02 	lds	r24, 0x0265
     64a:	28 2f       	mov	r18, r24
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	c9 01       	movw	r24, r18
     650:	88 0f       	add	r24, r24
     652:	99 1f       	adc	r25, r25
     654:	88 0f       	add	r24, r24
     656:	99 1f       	adc	r25, r25
     658:	88 0f       	add	r24, r24
     65a:	99 1f       	adc	r25, r25
     65c:	82 0f       	add	r24, r18
     65e:	93 1f       	adc	r25, r19
     660:	8c 5b       	subi	r24, 0xBC	; 188
     662:	9d 4f       	sbci	r25, 0xFD	; 253
     664:	fc 01       	movw	r30, r24
     666:	80 81       	ld	r24, Z
     668:	88 23       	and	r24, r24
     66a:	19 f3       	breq	.-58     	; 0x632 <vCoRoutineSchedule+0x12>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     66c:	80 91 65 02 	lds	r24, 0x0265
     670:	28 2f       	mov	r18, r24
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	c9 01       	movw	r24, r18
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	88 0f       	add	r24, r24
     67c:	99 1f       	adc	r25, r25
     67e:	88 0f       	add	r24, r24
     680:	99 1f       	adc	r25, r25
     682:	82 0f       	add	r24, r18
     684:	93 1f       	adc	r25, r19
     686:	8c 5b       	subi	r24, 0xBC	; 188
     688:	9d 4f       	sbci	r25, 0xFD	; 253
     68a:	9a 83       	std	Y+2, r25	; 0x02
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	9a 81       	ldd	r25, Y+2	; 0x02
     692:	fc 01       	movw	r30, r24
     694:	81 81       	ldd	r24, Z+1	; 0x01
     696:	92 81       	ldd	r25, Z+2	; 0x02
     698:	fc 01       	movw	r30, r24
     69a:	22 81       	ldd	r18, Z+2	; 0x02
     69c:	33 81       	ldd	r19, Z+3	; 0x03
     69e:	89 81       	ldd	r24, Y+1	; 0x01
     6a0:	9a 81       	ldd	r25, Y+2	; 0x02
     6a2:	fc 01       	movw	r30, r24
     6a4:	32 83       	std	Z+2, r19	; 0x02
     6a6:	21 83       	std	Z+1, r18	; 0x01
     6a8:	89 81       	ldd	r24, Y+1	; 0x01
     6aa:	9a 81       	ldd	r25, Y+2	; 0x02
     6ac:	fc 01       	movw	r30, r24
     6ae:	21 81       	ldd	r18, Z+1	; 0x01
     6b0:	32 81       	ldd	r19, Z+2	; 0x02
     6b2:	89 81       	ldd	r24, Y+1	; 0x01
     6b4:	9a 81       	ldd	r25, Y+2	; 0x02
     6b6:	03 96       	adiw	r24, 0x03	; 3
     6b8:	28 17       	cp	r18, r24
     6ba:	39 07       	cpc	r19, r25
     6bc:	69 f4       	brne	.+26     	; 0x6d8 <vCoRoutineSchedule+0xb8>
     6be:	89 81       	ldd	r24, Y+1	; 0x01
     6c0:	9a 81       	ldd	r25, Y+2	; 0x02
     6c2:	fc 01       	movw	r30, r24
     6c4:	81 81       	ldd	r24, Z+1	; 0x01
     6c6:	92 81       	ldd	r25, Z+2	; 0x02
     6c8:	fc 01       	movw	r30, r24
     6ca:	22 81       	ldd	r18, Z+2	; 0x02
     6cc:	33 81       	ldd	r19, Z+3	; 0x03
     6ce:	89 81       	ldd	r24, Y+1	; 0x01
     6d0:	9a 81       	ldd	r25, Y+2	; 0x02
     6d2:	fc 01       	movw	r30, r24
     6d4:	32 83       	std	Z+2, r19	; 0x02
     6d6:	21 83       	std	Z+1, r18	; 0x01
     6d8:	89 81       	ldd	r24, Y+1	; 0x01
     6da:	9a 81       	ldd	r25, Y+2	; 0x02
     6dc:	fc 01       	movw	r30, r24
     6de:	81 81       	ldd	r24, Z+1	; 0x01
     6e0:	92 81       	ldd	r25, Z+2	; 0x02
     6e2:	fc 01       	movw	r30, r24
     6e4:	86 81       	ldd	r24, Z+6	; 0x06
     6e6:	97 81       	ldd	r25, Z+7	; 0x07
     6e8:	90 93 64 02 	sts	0x0264, r25
     6ec:	80 93 63 02 	sts	0x0263, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     6f0:	80 91 63 02 	lds	r24, 0x0263
     6f4:	90 91 64 02 	lds	r25, 0x0264
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 81       	ld	r18, Z
     6fc:	31 81       	ldd	r19, Z+1	; 0x01
     6fe:	80 91 63 02 	lds	r24, 0x0263
     702:	90 91 64 02 	lds	r25, 0x0264
     706:	fc 01       	movw	r30, r24
     708:	47 89       	ldd	r20, Z+23	; 0x17
     70a:	80 91 63 02 	lds	r24, 0x0263
     70e:	90 91 64 02 	lds	r25, 0x0264
     712:	64 2f       	mov	r22, r20
     714:	f9 01       	movw	r30, r18
     716:	19 95       	eicall

	return;
     718:	00 00       	nop
}
     71a:	0f 90       	pop	r0
     71c:	0f 90       	pop	r0
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	08 95       	ret

00000724 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts

#endif
}
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	28 97       	sbiw	r28, 0x08	; 8
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	f8 94       	cli
     732:	de bf       	out	0x3e, r29	; 62
     734:	0f be       	out	0x3f, r0	; 63
     736:	cd bf       	out	0x3d, r28	; 61
     738:	9c 83       	std	Y+4, r25	; 0x04
     73a:	8b 83       	std	Y+3, r24	; 0x03
     73c:	7e 83       	std	Y+6, r23	; 0x06
     73e:	6d 83       	std	Y+5, r22	; 0x05
     740:	58 87       	std	Y+8, r21	; 0x08
     742:	4f 83       	std	Y+7, r20	; 0x07
     744:	8b 81       	ldd	r24, Y+3	; 0x03
     746:	9c 81       	ldd	r25, Y+4	; 0x04
     748:	21 e1       	ldi	r18, 0x11	; 17
     74a:	fc 01       	movw	r30, r24
     74c:	20 83       	st	Z, r18
     74e:	8b 81       	ldd	r24, Y+3	; 0x03
     750:	9c 81       	ldd	r25, Y+4	; 0x04
     752:	01 97       	sbiw	r24, 0x01	; 1
     754:	9c 83       	std	Y+4, r25	; 0x04
     756:	8b 83       	std	Y+3, r24	; 0x03
     758:	8b 81       	ldd	r24, Y+3	; 0x03
     75a:	9c 81       	ldd	r25, Y+4	; 0x04
     75c:	22 e2       	ldi	r18, 0x22	; 34
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
     762:	8b 81       	ldd	r24, Y+3	; 0x03
     764:	9c 81       	ldd	r25, Y+4	; 0x04
     766:	01 97       	sbiw	r24, 0x01	; 1
     768:	9c 83       	std	Y+4, r25	; 0x04
     76a:	8b 83       	std	Y+3, r24	; 0x03
     76c:	8b 81       	ldd	r24, Y+3	; 0x03
     76e:	9c 81       	ldd	r25, Y+4	; 0x04
     770:	23 e3       	ldi	r18, 0x33	; 51
     772:	fc 01       	movw	r30, r24
     774:	20 83       	st	Z, r18
     776:	8b 81       	ldd	r24, Y+3	; 0x03
     778:	9c 81       	ldd	r25, Y+4	; 0x04
     77a:	01 97       	sbiw	r24, 0x01	; 1
     77c:	9c 83       	std	Y+4, r25	; 0x04
     77e:	8b 83       	std	Y+3, r24	; 0x03
     780:	8d 81       	ldd	r24, Y+5	; 0x05
     782:	9e 81       	ldd	r25, Y+6	; 0x06
     784:	9a 83       	std	Y+2, r25	; 0x02
     786:	89 83       	std	Y+1, r24	; 0x01
     788:	29 81       	ldd	r18, Y+1	; 0x01
     78a:	8b 81       	ldd	r24, Y+3	; 0x03
     78c:	9c 81       	ldd	r25, Y+4	; 0x04
     78e:	fc 01       	movw	r30, r24
     790:	20 83       	st	Z, r18
     792:	8b 81       	ldd	r24, Y+3	; 0x03
     794:	9c 81       	ldd	r25, Y+4	; 0x04
     796:	01 97       	sbiw	r24, 0x01	; 1
     798:	9c 83       	std	Y+4, r25	; 0x04
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	89 81       	ldd	r24, Y+1	; 0x01
     79e:	9a 81       	ldd	r25, Y+2	; 0x02
     7a0:	89 2f       	mov	r24, r25
     7a2:	99 27       	eor	r25, r25
     7a4:	9a 83       	std	Y+2, r25	; 0x02
     7a6:	89 83       	std	Y+1, r24	; 0x01
     7a8:	29 81       	ldd	r18, Y+1	; 0x01
     7aa:	8b 81       	ldd	r24, Y+3	; 0x03
     7ac:	9c 81       	ldd	r25, Y+4	; 0x04
     7ae:	fc 01       	movw	r30, r24
     7b0:	20 83       	st	Z, r18
     7b2:	8b 81       	ldd	r24, Y+3	; 0x03
     7b4:	9c 81       	ldd	r25, Y+4	; 0x04
     7b6:	01 97       	sbiw	r24, 0x01	; 1
     7b8:	9c 83       	std	Y+4, r25	; 0x04
     7ba:	8b 83       	std	Y+3, r24	; 0x03
     7bc:	8b 81       	ldd	r24, Y+3	; 0x03
     7be:	9c 81       	ldd	r25, Y+4	; 0x04
     7c0:	fc 01       	movw	r30, r24
     7c2:	10 82       	st	Z, r1
     7c4:	8b 81       	ldd	r24, Y+3	; 0x03
     7c6:	9c 81       	ldd	r25, Y+4	; 0x04
     7c8:	01 97       	sbiw	r24, 0x01	; 1
     7ca:	9c 83       	std	Y+4, r25	; 0x04
     7cc:	8b 83       	std	Y+3, r24	; 0x03
     7ce:	8b 81       	ldd	r24, Y+3	; 0x03
     7d0:	9c 81       	ldd	r25, Y+4	; 0x04
     7d2:	fc 01       	movw	r30, r24
     7d4:	10 82       	st	Z, r1
     7d6:	8b 81       	ldd	r24, Y+3	; 0x03
     7d8:	9c 81       	ldd	r25, Y+4	; 0x04
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	8b 83       	std	Y+3, r24	; 0x03
     7e0:	8b 81       	ldd	r24, Y+3	; 0x03
     7e2:	9c 81       	ldd	r25, Y+4	; 0x04
     7e4:	20 e8       	ldi	r18, 0x80	; 128
     7e6:	fc 01       	movw	r30, r24
     7e8:	20 83       	st	Z, r18
     7ea:	8b 81       	ldd	r24, Y+3	; 0x03
     7ec:	9c 81       	ldd	r25, Y+4	; 0x04
     7ee:	01 97       	sbiw	r24, 0x01	; 1
     7f0:	9c 83       	std	Y+4, r25	; 0x04
     7f2:	8b 83       	std	Y+3, r24	; 0x03
     7f4:	8b 81       	ldd	r24, Y+3	; 0x03
     7f6:	9c 81       	ldd	r25, Y+4	; 0x04
     7f8:	fc 01       	movw	r30, r24
     7fa:	10 82       	st	Z, r1
     7fc:	8b 81       	ldd	r24, Y+3	; 0x03
     7fe:	9c 81       	ldd	r25, Y+4	; 0x04
     800:	01 97       	sbiw	r24, 0x01	; 1
     802:	9c 83       	std	Y+4, r25	; 0x04
     804:	8b 83       	std	Y+3, r24	; 0x03
     806:	8b 81       	ldd	r24, Y+3	; 0x03
     808:	9c 81       	ldd	r25, Y+4	; 0x04
     80a:	fc 01       	movw	r30, r24
     80c:	10 82       	st	Z, r1
     80e:	8b 81       	ldd	r24, Y+3	; 0x03
     810:	9c 81       	ldd	r25, Y+4	; 0x04
     812:	01 97       	sbiw	r24, 0x01	; 1
     814:	9c 83       	std	Y+4, r25	; 0x04
     816:	8b 83       	std	Y+3, r24	; 0x03
     818:	8b 81       	ldd	r24, Y+3	; 0x03
     81a:	9c 81       	ldd	r25, Y+4	; 0x04
     81c:	fc 01       	movw	r30, r24
     81e:	10 82       	st	Z, r1
     820:	8b 81       	ldd	r24, Y+3	; 0x03
     822:	9c 81       	ldd	r25, Y+4	; 0x04
     824:	01 97       	sbiw	r24, 0x01	; 1
     826:	9c 83       	std	Y+4, r25	; 0x04
     828:	8b 83       	std	Y+3, r24	; 0x03
     82a:	8b 81       	ldd	r24, Y+3	; 0x03
     82c:	9c 81       	ldd	r25, Y+4	; 0x04
     82e:	22 e0       	ldi	r18, 0x02	; 2
     830:	fc 01       	movw	r30, r24
     832:	20 83       	st	Z, r18
     834:	8b 81       	ldd	r24, Y+3	; 0x03
     836:	9c 81       	ldd	r25, Y+4	; 0x04
     838:	01 97       	sbiw	r24, 0x01	; 1
     83a:	9c 83       	std	Y+4, r25	; 0x04
     83c:	8b 83       	std	Y+3, r24	; 0x03
     83e:	8b 81       	ldd	r24, Y+3	; 0x03
     840:	9c 81       	ldd	r25, Y+4	; 0x04
     842:	23 e0       	ldi	r18, 0x03	; 3
     844:	fc 01       	movw	r30, r24
     846:	20 83       	st	Z, r18
     848:	8b 81       	ldd	r24, Y+3	; 0x03
     84a:	9c 81       	ldd	r25, Y+4	; 0x04
     84c:	01 97       	sbiw	r24, 0x01	; 1
     84e:	9c 83       	std	Y+4, r25	; 0x04
     850:	8b 83       	std	Y+3, r24	; 0x03
     852:	8b 81       	ldd	r24, Y+3	; 0x03
     854:	9c 81       	ldd	r25, Y+4	; 0x04
     856:	24 e0       	ldi	r18, 0x04	; 4
     858:	fc 01       	movw	r30, r24
     85a:	20 83       	st	Z, r18
     85c:	8b 81       	ldd	r24, Y+3	; 0x03
     85e:	9c 81       	ldd	r25, Y+4	; 0x04
     860:	01 97       	sbiw	r24, 0x01	; 1
     862:	9c 83       	std	Y+4, r25	; 0x04
     864:	8b 83       	std	Y+3, r24	; 0x03
     866:	8b 81       	ldd	r24, Y+3	; 0x03
     868:	9c 81       	ldd	r25, Y+4	; 0x04
     86a:	25 e0       	ldi	r18, 0x05	; 5
     86c:	fc 01       	movw	r30, r24
     86e:	20 83       	st	Z, r18
     870:	8b 81       	ldd	r24, Y+3	; 0x03
     872:	9c 81       	ldd	r25, Y+4	; 0x04
     874:	01 97       	sbiw	r24, 0x01	; 1
     876:	9c 83       	std	Y+4, r25	; 0x04
     878:	8b 83       	std	Y+3, r24	; 0x03
     87a:	8b 81       	ldd	r24, Y+3	; 0x03
     87c:	9c 81       	ldd	r25, Y+4	; 0x04
     87e:	26 e0       	ldi	r18, 0x06	; 6
     880:	fc 01       	movw	r30, r24
     882:	20 83       	st	Z, r18
     884:	8b 81       	ldd	r24, Y+3	; 0x03
     886:	9c 81       	ldd	r25, Y+4	; 0x04
     888:	01 97       	sbiw	r24, 0x01	; 1
     88a:	9c 83       	std	Y+4, r25	; 0x04
     88c:	8b 83       	std	Y+3, r24	; 0x03
     88e:	8b 81       	ldd	r24, Y+3	; 0x03
     890:	9c 81       	ldd	r25, Y+4	; 0x04
     892:	27 e0       	ldi	r18, 0x07	; 7
     894:	fc 01       	movw	r30, r24
     896:	20 83       	st	Z, r18
     898:	8b 81       	ldd	r24, Y+3	; 0x03
     89a:	9c 81       	ldd	r25, Y+4	; 0x04
     89c:	01 97       	sbiw	r24, 0x01	; 1
     89e:	9c 83       	std	Y+4, r25	; 0x04
     8a0:	8b 83       	std	Y+3, r24	; 0x03
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	9c 81       	ldd	r25, Y+4	; 0x04
     8a6:	28 e0       	ldi	r18, 0x08	; 8
     8a8:	fc 01       	movw	r30, r24
     8aa:	20 83       	st	Z, r18
     8ac:	8b 81       	ldd	r24, Y+3	; 0x03
     8ae:	9c 81       	ldd	r25, Y+4	; 0x04
     8b0:	01 97       	sbiw	r24, 0x01	; 1
     8b2:	9c 83       	std	Y+4, r25	; 0x04
     8b4:	8b 83       	std	Y+3, r24	; 0x03
     8b6:	8b 81       	ldd	r24, Y+3	; 0x03
     8b8:	9c 81       	ldd	r25, Y+4	; 0x04
     8ba:	29 e0       	ldi	r18, 0x09	; 9
     8bc:	fc 01       	movw	r30, r24
     8be:	20 83       	st	Z, r18
     8c0:	8b 81       	ldd	r24, Y+3	; 0x03
     8c2:	9c 81       	ldd	r25, Y+4	; 0x04
     8c4:	01 97       	sbiw	r24, 0x01	; 1
     8c6:	9c 83       	std	Y+4, r25	; 0x04
     8c8:	8b 83       	std	Y+3, r24	; 0x03
     8ca:	8b 81       	ldd	r24, Y+3	; 0x03
     8cc:	9c 81       	ldd	r25, Y+4	; 0x04
     8ce:	20 e1       	ldi	r18, 0x10	; 16
     8d0:	fc 01       	movw	r30, r24
     8d2:	20 83       	st	Z, r18
     8d4:	8b 81       	ldd	r24, Y+3	; 0x03
     8d6:	9c 81       	ldd	r25, Y+4	; 0x04
     8d8:	01 97       	sbiw	r24, 0x01	; 1
     8da:	9c 83       	std	Y+4, r25	; 0x04
     8dc:	8b 83       	std	Y+3, r24	; 0x03
     8de:	8b 81       	ldd	r24, Y+3	; 0x03
     8e0:	9c 81       	ldd	r25, Y+4	; 0x04
     8e2:	21 e1       	ldi	r18, 0x11	; 17
     8e4:	fc 01       	movw	r30, r24
     8e6:	20 83       	st	Z, r18
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	01 97       	sbiw	r24, 0x01	; 1
     8ee:	9c 83       	std	Y+4, r25	; 0x04
     8f0:	8b 83       	std	Y+3, r24	; 0x03
     8f2:	8b 81       	ldd	r24, Y+3	; 0x03
     8f4:	9c 81       	ldd	r25, Y+4	; 0x04
     8f6:	22 e1       	ldi	r18, 0x12	; 18
     8f8:	fc 01       	movw	r30, r24
     8fa:	20 83       	st	Z, r18
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	01 97       	sbiw	r24, 0x01	; 1
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
     906:	8b 81       	ldd	r24, Y+3	; 0x03
     908:	9c 81       	ldd	r25, Y+4	; 0x04
     90a:	23 e1       	ldi	r18, 0x13	; 19
     90c:	fc 01       	movw	r30, r24
     90e:	20 83       	st	Z, r18
     910:	8b 81       	ldd	r24, Y+3	; 0x03
     912:	9c 81       	ldd	r25, Y+4	; 0x04
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	9c 83       	std	Y+4, r25	; 0x04
     918:	8b 83       	std	Y+3, r24	; 0x03
     91a:	8b 81       	ldd	r24, Y+3	; 0x03
     91c:	9c 81       	ldd	r25, Y+4	; 0x04
     91e:	24 e1       	ldi	r18, 0x14	; 20
     920:	fc 01       	movw	r30, r24
     922:	20 83       	st	Z, r18
     924:	8b 81       	ldd	r24, Y+3	; 0x03
     926:	9c 81       	ldd	r25, Y+4	; 0x04
     928:	01 97       	sbiw	r24, 0x01	; 1
     92a:	9c 83       	std	Y+4, r25	; 0x04
     92c:	8b 83       	std	Y+3, r24	; 0x03
     92e:	8b 81       	ldd	r24, Y+3	; 0x03
     930:	9c 81       	ldd	r25, Y+4	; 0x04
     932:	25 e1       	ldi	r18, 0x15	; 21
     934:	fc 01       	movw	r30, r24
     936:	20 83       	st	Z, r18
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	01 97       	sbiw	r24, 0x01	; 1
     93e:	9c 83       	std	Y+4, r25	; 0x04
     940:	8b 83       	std	Y+3, r24	; 0x03
     942:	8b 81       	ldd	r24, Y+3	; 0x03
     944:	9c 81       	ldd	r25, Y+4	; 0x04
     946:	26 e1       	ldi	r18, 0x16	; 22
     948:	fc 01       	movw	r30, r24
     94a:	20 83       	st	Z, r18
     94c:	8b 81       	ldd	r24, Y+3	; 0x03
     94e:	9c 81       	ldd	r25, Y+4	; 0x04
     950:	01 97       	sbiw	r24, 0x01	; 1
     952:	9c 83       	std	Y+4, r25	; 0x04
     954:	8b 83       	std	Y+3, r24	; 0x03
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	9c 81       	ldd	r25, Y+4	; 0x04
     95a:	27 e1       	ldi	r18, 0x17	; 23
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
     960:	8b 81       	ldd	r24, Y+3	; 0x03
     962:	9c 81       	ldd	r25, Y+4	; 0x04
     964:	01 97       	sbiw	r24, 0x01	; 1
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	28 e1       	ldi	r18, 0x18	; 24
     970:	fc 01       	movw	r30, r24
     972:	20 83       	st	Z, r18
     974:	8b 81       	ldd	r24, Y+3	; 0x03
     976:	9c 81       	ldd	r25, Y+4	; 0x04
     978:	01 97       	sbiw	r24, 0x01	; 1
     97a:	9c 83       	std	Y+4, r25	; 0x04
     97c:	8b 83       	std	Y+3, r24	; 0x03
     97e:	8b 81       	ldd	r24, Y+3	; 0x03
     980:	9c 81       	ldd	r25, Y+4	; 0x04
     982:	29 e1       	ldi	r18, 0x19	; 25
     984:	fc 01       	movw	r30, r24
     986:	20 83       	st	Z, r18
     988:	8b 81       	ldd	r24, Y+3	; 0x03
     98a:	9c 81       	ldd	r25, Y+4	; 0x04
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	9c 83       	std	Y+4, r25	; 0x04
     990:	8b 83       	std	Y+3, r24	; 0x03
     992:	8b 81       	ldd	r24, Y+3	; 0x03
     994:	9c 81       	ldd	r25, Y+4	; 0x04
     996:	20 e2       	ldi	r18, 0x20	; 32
     998:	fc 01       	movw	r30, r24
     99a:	20 83       	st	Z, r18
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	9c 81       	ldd	r25, Y+4	; 0x04
     9a0:	01 97       	sbiw	r24, 0x01	; 1
     9a2:	9c 83       	std	Y+4, r25	; 0x04
     9a4:	8b 83       	std	Y+3, r24	; 0x03
     9a6:	8b 81       	ldd	r24, Y+3	; 0x03
     9a8:	9c 81       	ldd	r25, Y+4	; 0x04
     9aa:	21 e2       	ldi	r18, 0x21	; 33
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 83       	st	Z, r18
     9b0:	8b 81       	ldd	r24, Y+3	; 0x03
     9b2:	9c 81       	ldd	r25, Y+4	; 0x04
     9b4:	01 97       	sbiw	r24, 0x01	; 1
     9b6:	9c 83       	std	Y+4, r25	; 0x04
     9b8:	8b 83       	std	Y+3, r24	; 0x03
     9ba:	8b 81       	ldd	r24, Y+3	; 0x03
     9bc:	9c 81       	ldd	r25, Y+4	; 0x04
     9be:	22 e2       	ldi	r18, 0x22	; 34
     9c0:	fc 01       	movw	r30, r24
     9c2:	20 83       	st	Z, r18
     9c4:	8b 81       	ldd	r24, Y+3	; 0x03
     9c6:	9c 81       	ldd	r25, Y+4	; 0x04
     9c8:	01 97       	sbiw	r24, 0x01	; 1
     9ca:	9c 83       	std	Y+4, r25	; 0x04
     9cc:	8b 83       	std	Y+3, r24	; 0x03
     9ce:	8b 81       	ldd	r24, Y+3	; 0x03
     9d0:	9c 81       	ldd	r25, Y+4	; 0x04
     9d2:	23 e2       	ldi	r18, 0x23	; 35
     9d4:	fc 01       	movw	r30, r24
     9d6:	20 83       	st	Z, r18
     9d8:	8b 81       	ldd	r24, Y+3	; 0x03
     9da:	9c 81       	ldd	r25, Y+4	; 0x04
     9dc:	01 97       	sbiw	r24, 0x01	; 1
     9de:	9c 83       	std	Y+4, r25	; 0x04
     9e0:	8b 83       	std	Y+3, r24	; 0x03
     9e2:	8f 81       	ldd	r24, Y+7	; 0x07
     9e4:	98 85       	ldd	r25, Y+8	; 0x08
     9e6:	9a 83       	std	Y+2, r25	; 0x02
     9e8:	89 83       	std	Y+1, r24	; 0x01
     9ea:	29 81       	ldd	r18, Y+1	; 0x01
     9ec:	8b 81       	ldd	r24, Y+3	; 0x03
     9ee:	9c 81       	ldd	r25, Y+4	; 0x04
     9f0:	fc 01       	movw	r30, r24
     9f2:	20 83       	st	Z, r18
     9f4:	8b 81       	ldd	r24, Y+3	; 0x03
     9f6:	9c 81       	ldd	r25, Y+4	; 0x04
     9f8:	01 97       	sbiw	r24, 0x01	; 1
     9fa:	9c 83       	std	Y+4, r25	; 0x04
     9fc:	8b 83       	std	Y+3, r24	; 0x03
     9fe:	89 81       	ldd	r24, Y+1	; 0x01
     a00:	9a 81       	ldd	r25, Y+2	; 0x02
     a02:	89 2f       	mov	r24, r25
     a04:	99 27       	eor	r25, r25
     a06:	9a 83       	std	Y+2, r25	; 0x02
     a08:	89 83       	std	Y+1, r24	; 0x01
     a0a:	29 81       	ldd	r18, Y+1	; 0x01
     a0c:	8b 81       	ldd	r24, Y+3	; 0x03
     a0e:	9c 81       	ldd	r25, Y+4	; 0x04
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
     a14:	8b 81       	ldd	r24, Y+3	; 0x03
     a16:	9c 81       	ldd	r25, Y+4	; 0x04
     a18:	01 97       	sbiw	r24, 0x01	; 1
     a1a:	9c 83       	std	Y+4, r25	; 0x04
     a1c:	8b 83       	std	Y+3, r24	; 0x03
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	9c 81       	ldd	r25, Y+4	; 0x04
     a22:	26 e2       	ldi	r18, 0x26	; 38
     a24:	fc 01       	movw	r30, r24
     a26:	20 83       	st	Z, r18
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	9c 81       	ldd	r25, Y+4	; 0x04
     a2c:	01 97       	sbiw	r24, 0x01	; 1
     a2e:	9c 83       	std	Y+4, r25	; 0x04
     a30:	8b 83       	std	Y+3, r24	; 0x03
     a32:	8b 81       	ldd	r24, Y+3	; 0x03
     a34:	9c 81       	ldd	r25, Y+4	; 0x04
     a36:	27 e2       	ldi	r18, 0x27	; 39
     a38:	fc 01       	movw	r30, r24
     a3a:	20 83       	st	Z, r18
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	01 97       	sbiw	r24, 0x01	; 1
     a42:	9c 83       	std	Y+4, r25	; 0x04
     a44:	8b 83       	std	Y+3, r24	; 0x03
     a46:	8b 81       	ldd	r24, Y+3	; 0x03
     a48:	9c 81       	ldd	r25, Y+4	; 0x04
     a4a:	28 e2       	ldi	r18, 0x28	; 40
     a4c:	fc 01       	movw	r30, r24
     a4e:	20 83       	st	Z, r18
     a50:	8b 81       	ldd	r24, Y+3	; 0x03
     a52:	9c 81       	ldd	r25, Y+4	; 0x04
     a54:	01 97       	sbiw	r24, 0x01	; 1
     a56:	9c 83       	std	Y+4, r25	; 0x04
     a58:	8b 83       	std	Y+3, r24	; 0x03
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	29 e2       	ldi	r18, 0x29	; 41
     a60:	fc 01       	movw	r30, r24
     a62:	20 83       	st	Z, r18
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	9c 83       	std	Y+4, r25	; 0x04
     a6c:	8b 83       	std	Y+3, r24	; 0x03
     a6e:	8b 81       	ldd	r24, Y+3	; 0x03
     a70:	9c 81       	ldd	r25, Y+4	; 0x04
     a72:	20 e3       	ldi	r18, 0x30	; 48
     a74:	fc 01       	movw	r30, r24
     a76:	20 83       	st	Z, r18
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	9c 81       	ldd	r25, Y+4	; 0x04
     a7c:	01 97       	sbiw	r24, 0x01	; 1
     a7e:	9c 83       	std	Y+4, r25	; 0x04
     a80:	8b 83       	std	Y+3, r24	; 0x03
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	9c 81       	ldd	r25, Y+4	; 0x04
     a86:	21 e3       	ldi	r18, 0x31	; 49
     a88:	fc 01       	movw	r30, r24
     a8a:	20 83       	st	Z, r18
     a8c:	8b 81       	ldd	r24, Y+3	; 0x03
     a8e:	9c 81       	ldd	r25, Y+4	; 0x04
     a90:	01 97       	sbiw	r24, 0x01	; 1
     a92:	9c 83       	std	Y+4, r25	; 0x04
     a94:	8b 83       	std	Y+3, r24	; 0x03
     a96:	8b 81       	ldd	r24, Y+3	; 0x03
     a98:	9c 81       	ldd	r25, Y+4	; 0x04
     a9a:	28 96       	adiw	r28, 0x08	; 8
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	f8 94       	cli
     aa0:	de bf       	out	0x3e, r29	; 62
     aa2:	0f be       	out	0x3f, r0	; 63
     aa4:	cd bf       	out	0x3d, r28	; 61
     aa6:	df 91       	pop	r29
     aa8:	cf 91       	pop	r28
     aaa:	08 95       	ret

00000aac <xPortStartScheduler>:
     aac:	cf 93       	push	r28
     aae:	df 93       	push	r29
     ab0:	cd b7       	in	r28, 0x3d	; 61
     ab2:	de b7       	in	r29, 0x3e	; 62
     ab4:	10 d1       	rcall	.+544    	; 0xcd6 <prvSetupTimerInterrupt>
     ab6:	a0 91 38 0c 	lds	r26, 0x0C38
     aba:	b0 91 39 0c 	lds	r27, 0x0C39
     abe:	cd 91       	ld	r28, X+
     ac0:	cd bf       	out	0x3d, r28	; 61
     ac2:	dd 91       	ld	r29, X+
     ac4:	de bf       	out	0x3e, r29	; 62
     ac6:	ff 91       	pop	r31
     ac8:	ef 91       	pop	r30
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	bf 91       	pop	r27
     ad0:	af 91       	pop	r26
     ad2:	9f 91       	pop	r25
     ad4:	8f 91       	pop	r24
     ad6:	7f 91       	pop	r23
     ad8:	6f 91       	pop	r22
     ada:	5f 91       	pop	r21
     adc:	4f 91       	pop	r20
     ade:	3f 91       	pop	r19
     ae0:	2f 91       	pop	r18
     ae2:	1f 91       	pop	r17
     ae4:	0f 91       	pop	r16
     ae6:	ff 90       	pop	r15
     ae8:	ef 90       	pop	r14
     aea:	df 90       	pop	r13
     aec:	cf 90       	pop	r12
     aee:	bf 90       	pop	r11
     af0:	af 90       	pop	r10
     af2:	9f 90       	pop	r9
     af4:	8f 90       	pop	r8
     af6:	7f 90       	pop	r7
     af8:	6f 90       	pop	r6
     afa:	5f 90       	pop	r5
     afc:	4f 90       	pop	r4
     afe:	3f 90       	pop	r3
     b00:	2f 90       	pop	r2
     b02:	1f 90       	pop	r1
     b04:	0f 90       	pop	r0
     b06:	0c be       	out	0x3c, r0	; 60
     b08:	0f 90       	pop	r0
     b0a:	0b be       	out	0x3b, r0	; 59
     b0c:	0f 90       	pop	r0
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	0f 90       	pop	r0
     b12:	08 95       	ret
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	08 95       	ret

00000b1c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b1c:	0f 92       	push	r0
     b1e:	0f b6       	in	r0, 0x3f	; 63
     b20:	f8 94       	cli
     b22:	0f 92       	push	r0
     b24:	0b b6       	in	r0, 0x3b	; 59
     b26:	0f 92       	push	r0
     b28:	0c b6       	in	r0, 0x3c	; 60
     b2a:	0f 92       	push	r0
     b2c:	1f 92       	push	r1
     b2e:	11 24       	eor	r1, r1
     b30:	2f 92       	push	r2
     b32:	3f 92       	push	r3
     b34:	4f 92       	push	r4
     b36:	5f 92       	push	r5
     b38:	6f 92       	push	r6
     b3a:	7f 92       	push	r7
     b3c:	8f 92       	push	r8
     b3e:	9f 92       	push	r9
     b40:	af 92       	push	r10
     b42:	bf 92       	push	r11
     b44:	cf 92       	push	r12
     b46:	df 92       	push	r13
     b48:	ef 92       	push	r14
     b4a:	ff 92       	push	r15
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	2f 93       	push	r18
     b52:	3f 93       	push	r19
     b54:	4f 93       	push	r20
     b56:	5f 93       	push	r21
     b58:	6f 93       	push	r22
     b5a:	7f 93       	push	r23
     b5c:	8f 93       	push	r24
     b5e:	9f 93       	push	r25
     b60:	af 93       	push	r26
     b62:	bf 93       	push	r27
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	ef 93       	push	r30
     b6a:	ff 93       	push	r31
     b6c:	a0 91 38 0c 	lds	r26, 0x0C38
     b70:	b0 91 39 0c 	lds	r27, 0x0C39
     b74:	0d b6       	in	r0, 0x3d	; 61
     b76:	0d 92       	st	X+, r0
     b78:	0e b6       	in	r0, 0x3e	; 62
     b7a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b7c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b80:	a0 91 38 0c 	lds	r26, 0x0C38
     b84:	b0 91 39 0c 	lds	r27, 0x0C39
     b88:	cd 91       	ld	r28, X+
     b8a:	cd bf       	out	0x3d, r28	; 61
     b8c:	dd 91       	ld	r29, X+
     b8e:	de bf       	out	0x3e, r29	; 62
     b90:	ff 91       	pop	r31
     b92:	ef 91       	pop	r30
     b94:	df 91       	pop	r29
     b96:	cf 91       	pop	r28
     b98:	bf 91       	pop	r27
     b9a:	af 91       	pop	r26
     b9c:	9f 91       	pop	r25
     b9e:	8f 91       	pop	r24
     ba0:	7f 91       	pop	r23
     ba2:	6f 91       	pop	r22
     ba4:	5f 91       	pop	r21
     ba6:	4f 91       	pop	r20
     ba8:	3f 91       	pop	r19
     baa:	2f 91       	pop	r18
     bac:	1f 91       	pop	r17
     bae:	0f 91       	pop	r16
     bb0:	ff 90       	pop	r15
     bb2:	ef 90       	pop	r14
     bb4:	df 90       	pop	r13
     bb6:	cf 90       	pop	r12
     bb8:	bf 90       	pop	r11
     bba:	af 90       	pop	r10
     bbc:	9f 90       	pop	r9
     bbe:	8f 90       	pop	r8
     bc0:	7f 90       	pop	r7
     bc2:	6f 90       	pop	r6
     bc4:	5f 90       	pop	r5
     bc6:	4f 90       	pop	r4
     bc8:	3f 90       	pop	r3
     bca:	2f 90       	pop	r2
     bcc:	1f 90       	pop	r1
     bce:	0f 90       	pop	r0
     bd0:	0c be       	out	0x3c, r0	; 60
     bd2:	0f 90       	pop	r0
     bd4:	0b be       	out	0x3b, r0	; 59
     bd6:	0f 90       	pop	r0
     bd8:	0f be       	out	0x3f, r0	; 63
     bda:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     bdc:	08 95       	ret

00000bde <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     bde:	0f 92       	push	r0
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	f8 94       	cli
     be4:	0f 92       	push	r0
     be6:	0b b6       	in	r0, 0x3b	; 59
     be8:	0f 92       	push	r0
     bea:	0c b6       	in	r0, 0x3c	; 60
     bec:	0f 92       	push	r0
     bee:	1f 92       	push	r1
     bf0:	11 24       	eor	r1, r1
     bf2:	2f 92       	push	r2
     bf4:	3f 92       	push	r3
     bf6:	4f 92       	push	r4
     bf8:	5f 92       	push	r5
     bfa:	6f 92       	push	r6
     bfc:	7f 92       	push	r7
     bfe:	8f 92       	push	r8
     c00:	9f 92       	push	r9
     c02:	af 92       	push	r10
     c04:	bf 92       	push	r11
     c06:	cf 92       	push	r12
     c08:	df 92       	push	r13
     c0a:	ef 92       	push	r14
     c0c:	ff 92       	push	r15
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
     c12:	2f 93       	push	r18
     c14:	3f 93       	push	r19
     c16:	4f 93       	push	r20
     c18:	5f 93       	push	r21
     c1a:	6f 93       	push	r22
     c1c:	7f 93       	push	r23
     c1e:	8f 93       	push	r24
     c20:	9f 93       	push	r25
     c22:	af 93       	push	r26
     c24:	bf 93       	push	r27
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	ef 93       	push	r30
     c2c:	ff 93       	push	r31
     c2e:	a0 91 38 0c 	lds	r26, 0x0C38
     c32:	b0 91 39 0c 	lds	r27, 0x0C39
     c36:	0d b6       	in	r0, 0x3d	; 61
     c38:	0d 92       	st	X+, r0
     c3a:	0e b6       	in	r0, 0x3e	; 62
     c3c:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
     c3e:	80 91 6e 02 	lds	r24, 0x026E
     c42:	90 91 6f 02 	lds	r25, 0x026F
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	90 93 6f 02 	sts	0x026F, r25
     c4c:	80 93 6e 02 	sts	0x026E, r24
     c50:	80 91 6e 02 	lds	r24, 0x026E
     c54:	90 91 6f 02 	lds	r25, 0x026F
     c58:	89 2b       	or	r24, r25
     c5a:	41 f4       	brne	.+16     	; 0xc6c <vPortYieldFromTick+0x8e>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
     c5c:	80 91 6c 02 	lds	r24, 0x026C
     c60:	90 91 6d 02 	lds	r25, 0x026D
     c64:	90 93 6f 02 	sts	0x026F, r25
     c68:	80 93 6e 02 	sts	0x026E, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
     c6c:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <xTaskIncrementTick>
     c70:	88 23       	and	r24, r24
     c72:	11 f0       	breq	.+4      	; 0xc78 <vPortYieldFromTick+0x9a>
	{
		vTaskSwitchContext();
     c74:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     c78:	a0 91 38 0c 	lds	r26, 0x0C38
     c7c:	b0 91 39 0c 	lds	r27, 0x0C39
     c80:	cd 91       	ld	r28, X+
     c82:	cd bf       	out	0x3d, r28	; 61
     c84:	dd 91       	ld	r29, X+
     c86:	de bf       	out	0x3e, r29	; 62
     c88:	ff 91       	pop	r31
     c8a:	ef 91       	pop	r30
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	bf 91       	pop	r27
     c92:	af 91       	pop	r26
     c94:	9f 91       	pop	r25
     c96:	8f 91       	pop	r24
     c98:	7f 91       	pop	r23
     c9a:	6f 91       	pop	r22
     c9c:	5f 91       	pop	r21
     c9e:	4f 91       	pop	r20
     ca0:	3f 91       	pop	r19
     ca2:	2f 91       	pop	r18
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	ff 90       	pop	r15
     caa:	ef 90       	pop	r14
     cac:	df 90       	pop	r13
     cae:	cf 90       	pop	r12
     cb0:	bf 90       	pop	r11
     cb2:	af 90       	pop	r10
     cb4:	9f 90       	pop	r9
     cb6:	8f 90       	pop	r8
     cb8:	7f 90       	pop	r7
     cba:	6f 90       	pop	r6
     cbc:	5f 90       	pop	r5
     cbe:	4f 90       	pop	r4
     cc0:	3f 90       	pop	r3
     cc2:	2f 90       	pop	r2
     cc4:	1f 90       	pop	r1
     cc6:	0f 90       	pop	r0
     cc8:	0c be       	out	0x3c, r0	; 60
     cca:	0f 90       	pop	r0
     ccc:	0b be       	out	0x3b, r0	; 59
     cce:	0f 90       	pop	r0
     cd0:	0f be       	out	0x3f, r0	; 63
     cd2:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     cd4:	08 95       	ret

00000cd6 <prvSetupTimerInterrupt>:
#ifndef portUSE_TIMER2
/*
 * Setup timer 0 or 1 or 3 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     cd6:	cf 93       	push	r28
     cd8:	df 93       	push	r29
     cda:	cd b7       	in	r28, 0x3d	; 61
     cdc:	de b7       	in	r29, 0x3e	; 62
     cde:	2a 97       	sbiw	r28, 0x0a	; 10
     ce0:	0f b6       	in	r0, 0x3f	; 63
     ce2:	f8 94       	cli
     ce4:	de bf       	out	0x3e, r29	; 62
     ce6:	0f be       	out	0x3f, r0	; 63
     ce8:	cd bf       	out	0x3d, r28	; 61
    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock.*/

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     cea:	80 e1       	ldi	r24, 0x10	; 16
     cec:	97 e2       	ldi	r25, 0x27	; 39
     cee:	a0 e0       	ldi	r26, 0x00	; 0
     cf0:	b0 e0       	ldi	r27, 0x00	; 0
     cf2:	89 83       	std	Y+1, r24	; 0x01
     cf4:	9a 83       	std	Y+2, r25	; 0x02
     cf6:	ab 83       	std	Y+3, r26	; 0x03
     cf8:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
     cfa:	89 81       	ldd	r24, Y+1	; 0x01
     cfc:	9a 81       	ldd	r25, Y+2	; 0x02
     cfe:	ab 81       	ldd	r26, Y+3	; 0x03
     d00:	bc 81       	ldd	r27, Y+4	; 0x04
     d02:	68 94       	set
     d04:	15 f8       	bld	r1, 5
     d06:	b6 95       	lsr	r27
     d08:	a7 95       	ror	r26
     d0a:	97 95       	ror	r25
     d0c:	87 95       	ror	r24
     d0e:	16 94       	lsr	r1
     d10:	d1 f7       	brne	.-12     	; 0xd06 <prvSetupTimerInterrupt+0x30>
     d12:	89 83       	std	Y+1, r24	; 0x01
     d14:	9a 83       	std	Y+2, r25	; 0x02
     d16:	ab 83       	std	Y+3, r26	; 0x03
     d18:	bc 83       	std	Y+4, r27	; 0x04

 	/* actual port tick rate in Hz, calculated */
	portTickRateHz = (TickType_t) ((uint32_t) configCPU_CLOCK_HZ / ( portCLOCK_PRESCALER * ulCompareMatch ));
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	9a 81       	ldd	r25, Y+2	; 0x02
     d1e:	ab 81       	ldd	r26, Y+3	; 0x03
     d20:	bc 81       	ldd	r27, Y+4	; 0x04
     d22:	88 0f       	add	r24, r24
     d24:	99 1f       	adc	r25, r25
     d26:	aa 1f       	adc	r26, r26
     d28:	bb 1f       	adc	r27, r27
     d2a:	88 0f       	add	r24, r24
     d2c:	99 1f       	adc	r25, r25
     d2e:	aa 1f       	adc	r26, r26
     d30:	bb 1f       	adc	r27, r27
     d32:	88 0f       	add	r24, r24
     d34:	99 1f       	adc	r25, r25
     d36:	aa 1f       	adc	r26, r26
     d38:	bb 1f       	adc	r27, r27
     d3a:	88 0f       	add	r24, r24
     d3c:	99 1f       	adc	r25, r25
     d3e:	aa 1f       	adc	r26, r26
     d40:	bb 1f       	adc	r27, r27
     d42:	88 0f       	add	r24, r24
     d44:	99 1f       	adc	r25, r25
     d46:	aa 1f       	adc	r26, r26
     d48:	bb 1f       	adc	r27, r27
     d4a:	88 0f       	add	r24, r24
     d4c:	99 1f       	adc	r25, r25
     d4e:	aa 1f       	adc	r26, r26
     d50:	bb 1f       	adc	r27, r27
     d52:	9c 01       	movw	r18, r24
     d54:	ad 01       	movw	r20, r26
     d56:	80 e8       	ldi	r24, 0x80	; 128
     d58:	96 e9       	ldi	r25, 0x96	; 150
     d5a:	a8 e9       	ldi	r26, 0x98	; 152
     d5c:	b0 e0       	ldi	r27, 0x00	; 0
     d5e:	bc 01       	movw	r22, r24
     d60:	cd 01       	movw	r24, r26
     d62:	0e 94 84 1a 	call	0x3508	; 0x3508 <__udivmodsi4>
     d66:	da 01       	movw	r26, r20
     d68:	c9 01       	movw	r24, r18
     d6a:	90 93 6d 02 	sts	0x026D, r25
     d6e:	80 93 6c 02 	sts	0x026C, r24
	/* initialise first second of ticks */
	ticksRemainingInSec = portTickRateHz;
     d72:	80 91 6c 02 	lds	r24, 0x026C
     d76:	90 91 6d 02 	lds	r25, 0x026D
     d7a:	90 93 6f 02 	sts	0x026F, r25
     d7e:	80 93 6e 02 	sts	0x026E, r24

    /* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
     d86:	ab 81       	ldd	r26, Y+3	; 0x03
     d88:	bc 81       	ldd	r27, Y+4	; 0x04
     d8a:	01 97       	sbiw	r24, 0x01	; 1
     d8c:	a1 09       	sbc	r26, r1
     d8e:	b1 09       	sbc	r27, r1
     d90:	89 83       	std	Y+1, r24	; 0x01
     d92:	9a 83       	std	Y+2, r25	; 0x02
     d94:	ab 83       	std	Y+3, r26	; 0x03
     d96:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     d98:	89 81       	ldd	r24, Y+1	; 0x01
     d9a:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AH = ucHighByte;
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH
    ulCompareMatch >>= 8;
     d9c:	89 81       	ldd	r24, Y+1	; 0x01
     d9e:	9a 81       	ldd	r25, Y+2	; 0x02
     da0:	ab 81       	ldd	r26, Y+3	; 0x03
     da2:	bc 81       	ldd	r27, Y+4	; 0x04
     da4:	89 2f       	mov	r24, r25
     da6:	9a 2f       	mov	r25, r26
     da8:	ab 2f       	mov	r26, r27
     daa:	bb 27       	eor	r27, r27
     dac:	89 83       	std	Y+1, r24	; 0x01
     dae:	9a 83       	std	Y+2, r25	; 0x02
     db0:	ab 83       	std	Y+3, r26	; 0x03
     db2:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t) 0xff );
     db4:	89 81       	ldd	r24, Y+1	; 0x01
     db6:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
     db8:	89 e9       	ldi	r24, 0x99	; 153
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	2e 81       	ldd	r18, Y+6	; 0x06
     dbe:	fc 01       	movw	r30, r24
     dc0:	20 83       	st	Z, r18
#endif

    portOCRL = ucLowByte;
     dc2:	88 e9       	ldi	r24, 0x98	; 152
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	2d 81       	ldd	r18, Y+5	; 0x05
     dc8:	fc 01       	movw	r30, r24
     dca:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     dcc:	8b e0       	ldi	r24, 0x0B	; 11
     dce:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
     dd0:	81 e9       	ldi	r24, 0x91	; 145
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	2d 81       	ldd	r18, Y+5	; 0x05
     dd6:	fc 01       	movw	r30, r24
     dd8:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     dda:	81 e7       	ldi	r24, 0x71	; 113
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	fc 01       	movw	r30, r24
     de0:	80 81       	ld	r24, Z
     de2:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     de4:	8d 81       	ldd	r24, Y+5	; 0x05
     de6:	82 60       	ori	r24, 0x02	; 2
     de8:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
     dea:	81 e7       	ldi	r24, 0x71	; 113
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	2d 81       	ldd	r18, Y+5	; 0x05
     df0:	fc 01       	movw	r30, r24
     df2:	20 83       	st	Z, r18

}
     df4:	2a 96       	adiw	r28, 0x0a	; 10
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
     e00:	df 91       	pop	r29
     e02:	cf 91       	pop	r28
     e04:	08 95       	ret

00000e06 <__vector_32>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
     e06:	eb de       	rcall	.-554    	; 0xbde <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     e08:	18 95       	reti

00000e0a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e0a:	cf 93       	push	r28
     e0c:	df 93       	push	r29
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <pvPortMalloc+0x6>
     e10:	1f 92       	push	r1
     e12:	cd b7       	in	r28, 0x3d	; 61
     e14:	de b7       	in	r29, 0x3e	; 62
     e16:	9c 83       	std	Y+4, r25	; 0x04
     e18:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     e1a:	1a 82       	std	Y+2, r1	; 0x02
     e1c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     e1e:	22 d7       	rcall	.+3652   	; 0x1c64 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     e20:	80 91 36 0c 	lds	r24, 0x0C36
     e24:	90 91 37 0c 	lds	r25, 0x0C37
     e28:	89 2b       	or	r24, r25
     e2a:	31 f4       	brne	.+12     	; 0xe38 <pvPortMalloc+0x2e>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e2c:	81 e7       	ldi	r24, 0x71	; 113
     e2e:	92 e0       	ldi	r25, 0x02	; 2
     e30:	90 93 37 0c 	sts	0x0C37, r25
     e34:	80 93 36 0c 	sts	0x0C36, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e38:	20 91 34 0c 	lds	r18, 0x0C34
     e3c:	30 91 35 0c 	lds	r19, 0x0C35
     e40:	8b 81       	ldd	r24, Y+3	; 0x03
     e42:	9c 81       	ldd	r25, Y+4	; 0x04
     e44:	82 0f       	add	r24, r18
     e46:	93 1f       	adc	r25, r19
     e48:	83 3c       	cpi	r24, 0xC3	; 195
     e4a:	99 40       	sbci	r25, 0x09	; 9
     e4c:	38 f5       	brcc	.+78     	; 0xe9c <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     e4e:	20 91 34 0c 	lds	r18, 0x0C34
     e52:	30 91 35 0c 	lds	r19, 0x0C35
     e56:	8b 81       	ldd	r24, Y+3	; 0x03
     e58:	9c 81       	ldd	r25, Y+4	; 0x04
     e5a:	28 0f       	add	r18, r24
     e5c:	39 1f       	adc	r19, r25
     e5e:	80 91 34 0c 	lds	r24, 0x0C34
     e62:	90 91 35 0c 	lds	r25, 0x0C35
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e66:	82 17       	cp	r24, r18
     e68:	93 07       	cpc	r25, r19
     e6a:	c0 f4       	brcc	.+48     	; 0xe9c <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     e6c:	20 91 36 0c 	lds	r18, 0x0C36
     e70:	30 91 37 0c 	lds	r19, 0x0C37
     e74:	80 91 34 0c 	lds	r24, 0x0C34
     e78:	90 91 35 0c 	lds	r25, 0x0C35
     e7c:	82 0f       	add	r24, r18
     e7e:	93 1f       	adc	r25, r19
     e80:	9a 83       	std	Y+2, r25	; 0x02
     e82:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     e84:	20 91 34 0c 	lds	r18, 0x0C34
     e88:	30 91 35 0c 	lds	r19, 0x0C35
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	9c 81       	ldd	r25, Y+4	; 0x04
     e90:	82 0f       	add	r24, r18
     e92:	93 1f       	adc	r25, r19
     e94:	90 93 35 0c 	sts	0x0C35, r25
     e98:	80 93 34 0c 	sts	0x0C34, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     e9c:	ef d6       	rcall	.+3550   	; 0x1c7c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     e9e:	89 81       	ldd	r24, Y+1	; 0x01
     ea0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ea2:	0f 90       	pop	r0
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	1f 92       	push	r1
     eb6:	1f 92       	push	r1
     eb8:	cd b7       	in	r28, 0x3d	; 61
     eba:	de b7       	in	r29, 0x3e	; 62
     ebc:	9a 83       	std	Y+2, r25	; 0x02
     ebe:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     ec0:	0f 90       	pop	r0
     ec2:	0f 90       	pop	r0
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	08 95       	ret

00000eca <xQueueGenericReset>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	00 d0       	rcall	.+0      	; 0xed0 <xQueueGenericReset+0x6>
     ed0:	1f 92       	push	r1
     ed2:	1f 92       	push	r1
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03
     edc:	6d 83       	std	Y+5, r22	; 0x05
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	9c 81       	ldd	r25, Y+4	; 0x04
     ee2:	9a 83       	std	Y+2, r25	; 0x02
     ee4:	89 83       	std	Y+1, r24	; 0x01
     ee6:	0f b6       	in	r0, 0x3f	; 63
     ee8:	f8 94       	cli
     eea:	0f 92       	push	r0
     eec:	89 81       	ldd	r24, Y+1	; 0x01
     eee:	9a 81       	ldd	r25, Y+2	; 0x02
     ef0:	fc 01       	movw	r30, r24
     ef2:	80 81       	ld	r24, Z
     ef4:	91 81       	ldd	r25, Z+1	; 0x01
     ef6:	29 81       	ldd	r18, Y+1	; 0x01
     ef8:	3a 81       	ldd	r19, Y+2	; 0x02
     efa:	f9 01       	movw	r30, r18
     efc:	23 8d       	ldd	r18, Z+27	; 0x1b
     efe:	42 2f       	mov	r20, r18
     f00:	50 e0       	ldi	r21, 0x00	; 0
     f02:	29 81       	ldd	r18, Y+1	; 0x01
     f04:	3a 81       	ldd	r19, Y+2	; 0x02
     f06:	f9 01       	movw	r30, r18
     f08:	24 8d       	ldd	r18, Z+28	; 0x1c
     f0a:	22 2f       	mov	r18, r18
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	42 9f       	mul	r20, r18
     f10:	b0 01       	movw	r22, r0
     f12:	43 9f       	mul	r20, r19
     f14:	70 0d       	add	r23, r0
     f16:	52 9f       	mul	r21, r18
     f18:	70 0d       	add	r23, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	9b 01       	movw	r18, r22
     f1e:	28 0f       	add	r18, r24
     f20:	39 1f       	adc	r19, r25
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	9a 81       	ldd	r25, Y+2	; 0x02
     f26:	fc 01       	movw	r30, r24
     f28:	33 83       	std	Z+3, r19	; 0x03
     f2a:	22 83       	std	Z+2, r18	; 0x02
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	9a 81       	ldd	r25, Y+2	; 0x02
     f30:	fc 01       	movw	r30, r24
     f32:	12 8e       	std	Z+26, r1	; 0x1a
     f34:	89 81       	ldd	r24, Y+1	; 0x01
     f36:	9a 81       	ldd	r25, Y+2	; 0x02
     f38:	fc 01       	movw	r30, r24
     f3a:	20 81       	ld	r18, Z
     f3c:	31 81       	ldd	r19, Z+1	; 0x01
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	9a 81       	ldd	r25, Y+2	; 0x02
     f42:	fc 01       	movw	r30, r24
     f44:	35 83       	std	Z+5, r19	; 0x05
     f46:	24 83       	std	Z+4, r18	; 0x04
     f48:	89 81       	ldd	r24, Y+1	; 0x01
     f4a:	9a 81       	ldd	r25, Y+2	; 0x02
     f4c:	fc 01       	movw	r30, r24
     f4e:	80 81       	ld	r24, Z
     f50:	91 81       	ldd	r25, Z+1	; 0x01
     f52:	29 81       	ldd	r18, Y+1	; 0x01
     f54:	3a 81       	ldd	r19, Y+2	; 0x02
     f56:	f9 01       	movw	r30, r18
     f58:	23 8d       	ldd	r18, Z+27	; 0x1b
     f5a:	22 2f       	mov	r18, r18
     f5c:	30 e0       	ldi	r19, 0x00	; 0
     f5e:	a9 01       	movw	r20, r18
     f60:	41 50       	subi	r20, 0x01	; 1
     f62:	51 09       	sbc	r21, r1
     f64:	29 81       	ldd	r18, Y+1	; 0x01
     f66:	3a 81       	ldd	r19, Y+2	; 0x02
     f68:	f9 01       	movw	r30, r18
     f6a:	24 8d       	ldd	r18, Z+28	; 0x1c
     f6c:	22 2f       	mov	r18, r18
     f6e:	30 e0       	ldi	r19, 0x00	; 0
     f70:	42 9f       	mul	r20, r18
     f72:	b0 01       	movw	r22, r0
     f74:	43 9f       	mul	r20, r19
     f76:	70 0d       	add	r23, r0
     f78:	52 9f       	mul	r21, r18
     f7a:	70 0d       	add	r23, r0
     f7c:	11 24       	eor	r1, r1
     f7e:	9b 01       	movw	r18, r22
     f80:	28 0f       	add	r18, r24
     f82:	39 1f       	adc	r19, r25
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	9a 81       	ldd	r25, Y+2	; 0x02
     f88:	fc 01       	movw	r30, r24
     f8a:	37 83       	std	Z+7, r19	; 0x07
     f8c:	26 83       	std	Z+6, r18	; 0x06
     f8e:	89 81       	ldd	r24, Y+1	; 0x01
     f90:	9a 81       	ldd	r25, Y+2	; 0x02
     f92:	2f ef       	ldi	r18, 0xFF	; 255
     f94:	fc 01       	movw	r30, r24
     f96:	25 8f       	std	Z+29, r18	; 0x1d
     f98:	89 81       	ldd	r24, Y+1	; 0x01
     f9a:	9a 81       	ldd	r25, Y+2	; 0x02
     f9c:	2f ef       	ldi	r18, 0xFF	; 255
     f9e:	fc 01       	movw	r30, r24
     fa0:	26 8f       	std	Z+30, r18	; 0x1e
     fa2:	8d 81       	ldd	r24, Y+5	; 0x05
     fa4:	88 23       	and	r24, r24
     fa6:	79 f4       	brne	.+30     	; 0xfc6 <xQueueGenericReset+0xfc>
     fa8:	89 81       	ldd	r24, Y+1	; 0x01
     faa:	9a 81       	ldd	r25, Y+2	; 0x02
     fac:	fc 01       	movw	r30, r24
     fae:	80 85       	ldd	r24, Z+8	; 0x08
     fb0:	88 23       	and	r24, r24
     fb2:	89 f0       	breq	.+34     	; 0xfd6 <xQueueGenericReset+0x10c>
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	9a 81       	ldd	r25, Y+2	; 0x02
     fb8:	08 96       	adiw	r24, 0x08	; 8
     fba:	0e 94 c4 10 	call	0x2188	; 0x2188 <xTaskRemoveFromEventList>
     fbe:	81 30       	cpi	r24, 0x01	; 1
     fc0:	51 f4       	brne	.+20     	; 0xfd6 <xQueueGenericReset+0x10c>
     fc2:	ac dd       	rcall	.-1192   	; 0xb1c <vPortYield>
     fc4:	08 c0       	rjmp	.+16     	; 0xfd6 <xQueueGenericReset+0x10c>
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	9a 81       	ldd	r25, Y+2	; 0x02
     fca:	08 96       	adiw	r24, 0x08	; 8
     fcc:	ca d8       	rcall	.-3692   	; 0x162 <vListInitialise>
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	9a 81       	ldd	r25, Y+2	; 0x02
     fd2:	41 96       	adiw	r24, 0x11	; 17
     fd4:	c6 d8       	rcall	.-3700   	; 0x162 <vListInitialise>
     fd6:	0f 90       	pop	r0
     fd8:	0f be       	out	0x3f, r0	; 63
     fda:	81 e0       	ldi	r24, 0x01	; 1
     fdc:	0f 90       	pop	r0
     fde:	0f 90       	pop	r0
     fe0:	0f 90       	pop	r0
     fe2:	0f 90       	pop	r0
     fe4:	0f 90       	pop	r0
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	08 95       	ret

00000fec <xQueueGenericCreate>:
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	2b 97       	sbiw	r28, 0x0b	; 11
     ff6:	0f b6       	in	r0, 0x3f	; 63
     ff8:	f8 94       	cli
     ffa:	de bf       	out	0x3e, r29	; 62
     ffc:	0f be       	out	0x3f, r0	; 63
     ffe:	cd bf       	out	0x3d, r28	; 61
    1000:	89 87       	std	Y+9, r24	; 0x09
    1002:	6a 87       	std	Y+10, r22	; 0x0a
    1004:	4b 87       	std	Y+11, r20	; 0x0b
    1006:	1c 82       	std	Y+4, r1	; 0x04
    1008:	1b 82       	std	Y+3, r1	; 0x03
    100a:	8a 85       	ldd	r24, Y+10	; 0x0a
    100c:	88 23       	and	r24, r24
    100e:	19 f4       	brne	.+6      	; 0x1016 <xQueueGenericCreate+0x2a>
    1010:	1a 82       	std	Y+2, r1	; 0x02
    1012:	19 82       	std	Y+1, r1	; 0x01
    1014:	11 c0       	rjmp	.+34     	; 0x1038 <xQueueGenericCreate+0x4c>
    1016:	89 85       	ldd	r24, Y+9	; 0x09
    1018:	28 2f       	mov	r18, r24
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	8a 85       	ldd	r24, Y+10	; 0x0a
    101e:	88 2f       	mov	r24, r24
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	28 9f       	mul	r18, r24
    1024:	a0 01       	movw	r20, r0
    1026:	29 9f       	mul	r18, r25
    1028:	50 0d       	add	r21, r0
    102a:	38 9f       	mul	r19, r24
    102c:	50 0d       	add	r21, r0
    102e:	11 24       	eor	r1, r1
    1030:	ca 01       	movw	r24, r20
    1032:	01 96       	adiw	r24, 0x01	; 1
    1034:	9a 83       	std	Y+2, r25	; 0x02
    1036:	89 83       	std	Y+1, r24	; 0x01
    1038:	89 81       	ldd	r24, Y+1	; 0x01
    103a:	9a 81       	ldd	r25, Y+2	; 0x02
    103c:	4f 96       	adiw	r24, 0x1f	; 31
    103e:	e5 de       	rcall	.-566    	; 0xe0a <pvPortMalloc>
    1040:	9e 83       	std	Y+6, r25	; 0x06
    1042:	8d 83       	std	Y+5, r24	; 0x05
    1044:	8d 81       	ldd	r24, Y+5	; 0x05
    1046:	9e 81       	ldd	r25, Y+6	; 0x06
    1048:	89 2b       	or	r24, r25
    104a:	59 f1       	breq	.+86     	; 0x10a2 <xQueueGenericCreate+0xb6>
    104c:	8d 81       	ldd	r24, Y+5	; 0x05
    104e:	9e 81       	ldd	r25, Y+6	; 0x06
    1050:	98 87       	std	Y+8, r25	; 0x08
    1052:	8f 83       	std	Y+7, r24	; 0x07
    1054:	8a 85       	ldd	r24, Y+10	; 0x0a
    1056:	88 23       	and	r24, r24
    1058:	41 f4       	brne	.+16     	; 0x106a <xQueueGenericCreate+0x7e>
    105a:	8f 81       	ldd	r24, Y+7	; 0x07
    105c:	98 85       	ldd	r25, Y+8	; 0x08
    105e:	2f 81       	ldd	r18, Y+7	; 0x07
    1060:	38 85       	ldd	r19, Y+8	; 0x08
    1062:	fc 01       	movw	r30, r24
    1064:	31 83       	std	Z+1, r19	; 0x01
    1066:	20 83       	st	Z, r18
    1068:	0a c0       	rjmp	.+20     	; 0x107e <xQueueGenericCreate+0x92>
    106a:	8d 81       	ldd	r24, Y+5	; 0x05
    106c:	9e 81       	ldd	r25, Y+6	; 0x06
    106e:	9c 01       	movw	r18, r24
    1070:	21 5e       	subi	r18, 0xE1	; 225
    1072:	3f 4f       	sbci	r19, 0xFF	; 255
    1074:	8f 81       	ldd	r24, Y+7	; 0x07
    1076:	98 85       	ldd	r25, Y+8	; 0x08
    1078:	fc 01       	movw	r30, r24
    107a:	31 83       	std	Z+1, r19	; 0x01
    107c:	20 83       	st	Z, r18
    107e:	8f 81       	ldd	r24, Y+7	; 0x07
    1080:	98 85       	ldd	r25, Y+8	; 0x08
    1082:	29 85       	ldd	r18, Y+9	; 0x09
    1084:	fc 01       	movw	r30, r24
    1086:	23 8f       	std	Z+27, r18	; 0x1b
    1088:	8f 81       	ldd	r24, Y+7	; 0x07
    108a:	98 85       	ldd	r25, Y+8	; 0x08
    108c:	2a 85       	ldd	r18, Y+10	; 0x0a
    108e:	fc 01       	movw	r30, r24
    1090:	24 8f       	std	Z+28, r18	; 0x1c
    1092:	8f 81       	ldd	r24, Y+7	; 0x07
    1094:	98 85       	ldd	r25, Y+8	; 0x08
    1096:	61 e0       	ldi	r22, 0x01	; 1
    1098:	18 df       	rcall	.-464    	; 0xeca <xQueueGenericReset>
    109a:	8f 81       	ldd	r24, Y+7	; 0x07
    109c:	98 85       	ldd	r25, Y+8	; 0x08
    109e:	9c 83       	std	Y+4, r25	; 0x04
    10a0:	8b 83       	std	Y+3, r24	; 0x03
    10a2:	8b 81       	ldd	r24, Y+3	; 0x03
    10a4:	9c 81       	ldd	r25, Y+4	; 0x04
    10a6:	2b 96       	adiw	r28, 0x0b	; 11
    10a8:	0f b6       	in	r0, 0x3f	; 63
    10aa:	f8 94       	cli
    10ac:	de bf       	out	0x3e, r29	; 62
    10ae:	0f be       	out	0x3f, r0	; 63
    10b0:	cd bf       	out	0x3d, r28	; 61
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	08 95       	ret

000010b8 <xQueueCreateCountingSemaphore>:
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	00 d0       	rcall	.+0      	; 0x10be <xQueueCreateCountingSemaphore+0x6>
    10be:	1f 92       	push	r1
    10c0:	cd b7       	in	r28, 0x3d	; 61
    10c2:	de b7       	in	r29, 0x3e	; 62
    10c4:	8b 83       	std	Y+3, r24	; 0x03
    10c6:	6c 83       	std	Y+4, r22	; 0x04
    10c8:	42 e0       	ldi	r20, 0x02	; 2
    10ca:	60 e0       	ldi	r22, 0x00	; 0
    10cc:	8b 81       	ldd	r24, Y+3	; 0x03
    10ce:	8e df       	rcall	.-228    	; 0xfec <xQueueGenericCreate>
    10d0:	9a 83       	std	Y+2, r25	; 0x02
    10d2:	89 83       	std	Y+1, r24	; 0x01
    10d4:	89 81       	ldd	r24, Y+1	; 0x01
    10d6:	9a 81       	ldd	r25, Y+2	; 0x02
    10d8:	89 2b       	or	r24, r25
    10da:	29 f0       	breq	.+10     	; 0x10e6 <xQueueCreateCountingSemaphore+0x2e>
    10dc:	89 81       	ldd	r24, Y+1	; 0x01
    10de:	9a 81       	ldd	r25, Y+2	; 0x02
    10e0:	2c 81       	ldd	r18, Y+4	; 0x04
    10e2:	fc 01       	movw	r30, r24
    10e4:	22 8f       	std	Z+26, r18	; 0x1a
    10e6:	89 81       	ldd	r24, Y+1	; 0x01
    10e8:	9a 81       	ldd	r25, Y+2	; 0x02
    10ea:	0f 90       	pop	r0
    10ec:	0f 90       	pop	r0
    10ee:	0f 90       	pop	r0
    10f0:	0f 90       	pop	r0
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	08 95       	ret

000010f8 <xQueueGenericSend>:
    10f8:	cf 93       	push	r28
    10fa:	df 93       	push	r29
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
    1100:	2e 97       	sbiw	r28, 0x0e	; 14
    1102:	0f b6       	in	r0, 0x3f	; 63
    1104:	f8 94       	cli
    1106:	de bf       	out	0x3e, r29	; 62
    1108:	0f be       	out	0x3f, r0	; 63
    110a:	cd bf       	out	0x3d, r28	; 61
    110c:	99 87       	std	Y+9, r25	; 0x09
    110e:	88 87       	std	Y+8, r24	; 0x08
    1110:	7b 87       	std	Y+11, r23	; 0x0b
    1112:	6a 87       	std	Y+10, r22	; 0x0a
    1114:	5d 87       	std	Y+13, r21	; 0x0d
    1116:	4c 87       	std	Y+12, r20	; 0x0c
    1118:	2e 87       	std	Y+14, r18	; 0x0e
    111a:	19 82       	std	Y+1, r1	; 0x01
    111c:	88 85       	ldd	r24, Y+8	; 0x08
    111e:	99 85       	ldd	r25, Y+9	; 0x09
    1120:	9b 83       	std	Y+3, r25	; 0x03
    1122:	8a 83       	std	Y+2, r24	; 0x02
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	f8 94       	cli
    1128:	0f 92       	push	r0
    112a:	8a 81       	ldd	r24, Y+2	; 0x02
    112c:	9b 81       	ldd	r25, Y+3	; 0x03
    112e:	fc 01       	movw	r30, r24
    1130:	22 8d       	ldd	r18, Z+26	; 0x1a
    1132:	8a 81       	ldd	r24, Y+2	; 0x02
    1134:	9b 81       	ldd	r25, Y+3	; 0x03
    1136:	fc 01       	movw	r30, r24
    1138:	83 8d       	ldd	r24, Z+27	; 0x1b
    113a:	28 17       	cp	r18, r24
    113c:	18 f0       	brcs	.+6      	; 0x1144 <xQueueGenericSend+0x4c>
    113e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1140:	82 30       	cpi	r24, 0x02	; 2
    1142:	f9 f4       	brne	.+62     	; 0x1182 <xQueueGenericSend+0x8a>
    1144:	2a 85       	ldd	r18, Y+10	; 0x0a
    1146:	3b 85       	ldd	r19, Y+11	; 0x0b
    1148:	8a 81       	ldd	r24, Y+2	; 0x02
    114a:	9b 81       	ldd	r25, Y+3	; 0x03
    114c:	4e 85       	ldd	r20, Y+14	; 0x0e
    114e:	b9 01       	movw	r22, r18
    1150:	f3 d1       	rcall	.+998    	; 0x1538 <prvCopyDataToQueue>
    1152:	8c 83       	std	Y+4, r24	; 0x04
    1154:	8a 81       	ldd	r24, Y+2	; 0x02
    1156:	9b 81       	ldd	r25, Y+3	; 0x03
    1158:	fc 01       	movw	r30, r24
    115a:	81 89       	ldd	r24, Z+17	; 0x11
    115c:	88 23       	and	r24, r24
    115e:	49 f0       	breq	.+18     	; 0x1172 <xQueueGenericSend+0x7a>
    1160:	8a 81       	ldd	r24, Y+2	; 0x02
    1162:	9b 81       	ldd	r25, Y+3	; 0x03
    1164:	41 96       	adiw	r24, 0x11	; 17
    1166:	0e 94 c4 10 	call	0x2188	; 0x2188 <xTaskRemoveFromEventList>
    116a:	81 30       	cpi	r24, 0x01	; 1
    116c:	31 f4       	brne	.+12     	; 0x117a <xQueueGenericSend+0x82>
    116e:	d6 dc       	rcall	.-1620   	; 0xb1c <vPortYield>
    1170:	04 c0       	rjmp	.+8      	; 0x117a <xQueueGenericSend+0x82>
    1172:	8c 81       	ldd	r24, Y+4	; 0x04
    1174:	88 23       	and	r24, r24
    1176:	09 f0       	breq	.+2      	; 0x117a <xQueueGenericSend+0x82>
    1178:	d1 dc       	rcall	.-1630   	; 0xb1c <vPortYield>
    117a:	0f 90       	pop	r0
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	57 c0       	rjmp	.+174    	; 0x1230 <xQueueGenericSend+0x138>
    1182:	8c 85       	ldd	r24, Y+12	; 0x0c
    1184:	9d 85       	ldd	r25, Y+13	; 0x0d
    1186:	89 2b       	or	r24, r25
    1188:	21 f4       	brne	.+8      	; 0x1192 <xQueueGenericSend+0x9a>
    118a:	0f 90       	pop	r0
    118c:	0f be       	out	0x3f, r0	; 63
    118e:	80 e0       	ldi	r24, 0x00	; 0
    1190:	4f c0       	rjmp	.+158    	; 0x1230 <xQueueGenericSend+0x138>
    1192:	89 81       	ldd	r24, Y+1	; 0x01
    1194:	88 23       	and	r24, r24
    1196:	31 f4       	brne	.+12     	; 0x11a4 <xQueueGenericSend+0xac>
    1198:	ce 01       	movw	r24, r28
    119a:	05 96       	adiw	r24, 0x05	; 5
    119c:	0e 94 31 11 	call	0x2262	; 0x2262 <vTaskSetTimeOutState>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	89 83       	std	Y+1, r24	; 0x01
    11a4:	0f 90       	pop	r0
    11a6:	0f be       	out	0x3f, r0	; 63
    11a8:	5d d5       	rcall	.+2746   	; 0x1c64 <vTaskSuspendAll>
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	0f 92       	push	r0
    11b0:	8a 81       	ldd	r24, Y+2	; 0x02
    11b2:	9b 81       	ldd	r25, Y+3	; 0x03
    11b4:	fc 01       	movw	r30, r24
    11b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    11b8:	8f 3f       	cpi	r24, 0xFF	; 255
    11ba:	21 f4       	brne	.+8      	; 0x11c4 <xQueueGenericSend+0xcc>
    11bc:	8a 81       	ldd	r24, Y+2	; 0x02
    11be:	9b 81       	ldd	r25, Y+3	; 0x03
    11c0:	fc 01       	movw	r30, r24
    11c2:	15 8e       	std	Z+29, r1	; 0x1d
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	9b 81       	ldd	r25, Y+3	; 0x03
    11c8:	fc 01       	movw	r30, r24
    11ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    11cc:	8f 3f       	cpi	r24, 0xFF	; 255
    11ce:	21 f4       	brne	.+8      	; 0x11d8 <xQueueGenericSend+0xe0>
    11d0:	8a 81       	ldd	r24, Y+2	; 0x02
    11d2:	9b 81       	ldd	r25, Y+3	; 0x03
    11d4:	fc 01       	movw	r30, r24
    11d6:	16 8e       	std	Z+30, r1	; 0x1e
    11d8:	0f 90       	pop	r0
    11da:	0f be       	out	0x3f, r0	; 63
    11dc:	9e 01       	movw	r18, r28
    11de:	24 5f       	subi	r18, 0xF4	; 244
    11e0:	3f 4f       	sbci	r19, 0xFF	; 255
    11e2:	ce 01       	movw	r24, r28
    11e4:	05 96       	adiw	r24, 0x05	; 5
    11e6:	b9 01       	movw	r22, r18
    11e8:	0e 94 4d 11 	call	0x229a	; 0x229a <xTaskCheckForTimeOut>
    11ec:	88 23       	and	r24, r24
    11ee:	c9 f4       	brne	.+50     	; 0x1222 <xQueueGenericSend+0x12a>
    11f0:	8a 81       	ldd	r24, Y+2	; 0x02
    11f2:	9b 81       	ldd	r25, Y+3	; 0x03
    11f4:	2e d3       	rcall	.+1628   	; 0x1852 <prvIsQueueFull>
    11f6:	88 23       	and	r24, r24
    11f8:	79 f0       	breq	.+30     	; 0x1218 <xQueueGenericSend+0x120>
    11fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    11fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    11fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1200:	9b 81       	ldd	r25, Y+3	; 0x03
    1202:	08 96       	adiw	r24, 0x08	; 8
    1204:	b9 01       	movw	r22, r18
    1206:	5a d7       	rcall	.+3764   	; 0x20bc <vTaskPlaceOnEventList>
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	9b 81       	ldd	r25, Y+3	; 0x03
    120c:	a4 d2       	rcall	.+1352   	; 0x1756 <prvUnlockQueue>
    120e:	36 d5       	rcall	.+2668   	; 0x1c7c <xTaskResumeAll>
    1210:	88 23       	and	r24, r24
    1212:	69 f4       	brne	.+26     	; 0x122e <xQueueGenericSend+0x136>
    1214:	83 dc       	rcall	.-1786   	; 0xb1c <vPortYield>
    1216:	0b c0       	rjmp	.+22     	; 0x122e <xQueueGenericSend+0x136>
    1218:	8a 81       	ldd	r24, Y+2	; 0x02
    121a:	9b 81       	ldd	r25, Y+3	; 0x03
    121c:	9c d2       	rcall	.+1336   	; 0x1756 <prvUnlockQueue>
    121e:	2e d5       	rcall	.+2652   	; 0x1c7c <xTaskResumeAll>
    1220:	81 cf       	rjmp	.-254    	; 0x1124 <xQueueGenericSend+0x2c>
    1222:	8a 81       	ldd	r24, Y+2	; 0x02
    1224:	9b 81       	ldd	r25, Y+3	; 0x03
    1226:	97 d2       	rcall	.+1326   	; 0x1756 <prvUnlockQueue>
    1228:	29 d5       	rcall	.+2642   	; 0x1c7c <xTaskResumeAll>
    122a:	80 e0       	ldi	r24, 0x00	; 0
    122c:	01 c0       	rjmp	.+2      	; 0x1230 <xQueueGenericSend+0x138>
    122e:	7a cf       	rjmp	.-268    	; 0x1124 <xQueueGenericSend+0x2c>
    1230:	2e 96       	adiw	r28, 0x0e	; 14
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	08 95       	ret

00001242 <xQueueGenericSendFromISR>:
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	cd b7       	in	r28, 0x3d	; 61
    1248:	de b7       	in	r29, 0x3e	; 62
    124a:	2b 97       	sbiw	r28, 0x0b	; 11
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	f8 94       	cli
    1250:	de bf       	out	0x3e, r29	; 62
    1252:	0f be       	out	0x3f, r0	; 63
    1254:	cd bf       	out	0x3d, r28	; 61
    1256:	9e 83       	std	Y+6, r25	; 0x06
    1258:	8d 83       	std	Y+5, r24	; 0x05
    125a:	78 87       	std	Y+8, r23	; 0x08
    125c:	6f 83       	std	Y+7, r22	; 0x07
    125e:	5a 87       	std	Y+10, r21	; 0x0a
    1260:	49 87       	std	Y+9, r20	; 0x09
    1262:	2b 87       	std	Y+11, r18	; 0x0b
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	9e 81       	ldd	r25, Y+6	; 0x06
    1268:	9b 83       	std	Y+3, r25	; 0x03
    126a:	8a 83       	std	Y+2, r24	; 0x02
    126c:	1c 82       	std	Y+4, r1	; 0x04
    126e:	8a 81       	ldd	r24, Y+2	; 0x02
    1270:	9b 81       	ldd	r25, Y+3	; 0x03
    1272:	fc 01       	movw	r30, r24
    1274:	22 8d       	ldd	r18, Z+26	; 0x1a
    1276:	8a 81       	ldd	r24, Y+2	; 0x02
    1278:	9b 81       	ldd	r25, Y+3	; 0x03
    127a:	fc 01       	movw	r30, r24
    127c:	83 8d       	ldd	r24, Z+27	; 0x1b
    127e:	28 17       	cp	r18, r24
    1280:	18 f0       	brcs	.+6      	; 0x1288 <xQueueGenericSendFromISR+0x46>
    1282:	8b 85       	ldd	r24, Y+11	; 0x0b
    1284:	82 30       	cpi	r24, 0x02	; 2
    1286:	81 f5       	brne	.+96     	; 0x12e8 <xQueueGenericSendFromISR+0xa6>
    1288:	2f 81       	ldd	r18, Y+7	; 0x07
    128a:	38 85       	ldd	r19, Y+8	; 0x08
    128c:	8a 81       	ldd	r24, Y+2	; 0x02
    128e:	9b 81       	ldd	r25, Y+3	; 0x03
    1290:	4b 85       	ldd	r20, Y+11	; 0x0b
    1292:	b9 01       	movw	r22, r18
    1294:	51 d1       	rcall	.+674    	; 0x1538 <prvCopyDataToQueue>
    1296:	8a 81       	ldd	r24, Y+2	; 0x02
    1298:	9b 81       	ldd	r25, Y+3	; 0x03
    129a:	fc 01       	movw	r30, r24
    129c:	86 8d       	ldd	r24, Z+30	; 0x1e
    129e:	8f 3f       	cpi	r24, 0xFF	; 255
    12a0:	b1 f4       	brne	.+44     	; 0x12ce <xQueueGenericSendFromISR+0x8c>
    12a2:	8a 81       	ldd	r24, Y+2	; 0x02
    12a4:	9b 81       	ldd	r25, Y+3	; 0x03
    12a6:	fc 01       	movw	r30, r24
    12a8:	81 89       	ldd	r24, Z+17	; 0x11
    12aa:	88 23       	and	r24, r24
    12ac:	d1 f0       	breq	.+52     	; 0x12e2 <xQueueGenericSendFromISR+0xa0>
    12ae:	8a 81       	ldd	r24, Y+2	; 0x02
    12b0:	9b 81       	ldd	r25, Y+3	; 0x03
    12b2:	41 96       	adiw	r24, 0x11	; 17
    12b4:	69 d7       	rcall	.+3794   	; 0x2188 <xTaskRemoveFromEventList>
    12b6:	88 23       	and	r24, r24
    12b8:	a1 f0       	breq	.+40     	; 0x12e2 <xQueueGenericSendFromISR+0xa0>
    12ba:	89 85       	ldd	r24, Y+9	; 0x09
    12bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    12be:	89 2b       	or	r24, r25
    12c0:	81 f0       	breq	.+32     	; 0x12e2 <xQueueGenericSendFromISR+0xa0>
    12c2:	89 85       	ldd	r24, Y+9	; 0x09
    12c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    12c6:	21 e0       	ldi	r18, 0x01	; 1
    12c8:	fc 01       	movw	r30, r24
    12ca:	20 83       	st	Z, r18
    12cc:	0a c0       	rjmp	.+20     	; 0x12e2 <xQueueGenericSendFromISR+0xa0>
    12ce:	8a 81       	ldd	r24, Y+2	; 0x02
    12d0:	9b 81       	ldd	r25, Y+3	; 0x03
    12d2:	fc 01       	movw	r30, r24
    12d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    12d6:	8f 5f       	subi	r24, 0xFF	; 255
    12d8:	28 2f       	mov	r18, r24
    12da:	8a 81       	ldd	r24, Y+2	; 0x02
    12dc:	9b 81       	ldd	r25, Y+3	; 0x03
    12de:	fc 01       	movw	r30, r24
    12e0:	26 8f       	std	Z+30, r18	; 0x1e
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	89 83       	std	Y+1, r24	; 0x01
    12e6:	01 c0       	rjmp	.+2      	; 0x12ea <xQueueGenericSendFromISR+0xa8>
    12e8:	19 82       	std	Y+1, r1	; 0x01
    12ea:	89 81       	ldd	r24, Y+1	; 0x01
    12ec:	2b 96       	adiw	r28, 0x0b	; 11
    12ee:	0f b6       	in	r0, 0x3f	; 63
    12f0:	f8 94       	cli
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <xQueueGenericReceive>:
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
    1306:	2f 97       	sbiw	r28, 0x0f	; 15
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	f8 94       	cli
    130c:	de bf       	out	0x3e, r29	; 62
    130e:	0f be       	out	0x3f, r0	; 63
    1310:	cd bf       	out	0x3d, r28	; 61
    1312:	9a 87       	std	Y+10, r25	; 0x0a
    1314:	89 87       	std	Y+9, r24	; 0x09
    1316:	7c 87       	std	Y+12, r23	; 0x0c
    1318:	6b 87       	std	Y+11, r22	; 0x0b
    131a:	5e 87       	std	Y+14, r21	; 0x0e
    131c:	4d 87       	std	Y+13, r20	; 0x0d
    131e:	2f 87       	std	Y+15, r18	; 0x0f
    1320:	19 82       	std	Y+1, r1	; 0x01
    1322:	89 85       	ldd	r24, Y+9	; 0x09
    1324:	9a 85       	ldd	r25, Y+10	; 0x0a
    1326:	9b 83       	std	Y+3, r25	; 0x03
    1328:	8a 83       	std	Y+2, r24	; 0x02
    132a:	0f b6       	in	r0, 0x3f	; 63
    132c:	f8 94       	cli
    132e:	0f 92       	push	r0
    1330:	8a 81       	ldd	r24, Y+2	; 0x02
    1332:	9b 81       	ldd	r25, Y+3	; 0x03
    1334:	fc 01       	movw	r30, r24
    1336:	82 8d       	ldd	r24, Z+26	; 0x1a
    1338:	88 23       	and	r24, r24
    133a:	09 f4       	brne	.+2      	; 0x133e <xQueueGenericReceive+0x40>
    133c:	40 c0       	rjmp	.+128    	; 0x13be <xQueueGenericReceive+0xc0>
    133e:	8a 81       	ldd	r24, Y+2	; 0x02
    1340:	9b 81       	ldd	r25, Y+3	; 0x03
    1342:	fc 01       	movw	r30, r24
    1344:	86 81       	ldd	r24, Z+6	; 0x06
    1346:	97 81       	ldd	r25, Z+7	; 0x07
    1348:	9d 83       	std	Y+5, r25	; 0x05
    134a:	8c 83       	std	Y+4, r24	; 0x04
    134c:	2b 85       	ldd	r18, Y+11	; 0x0b
    134e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1350:	8a 81       	ldd	r24, Y+2	; 0x02
    1352:	9b 81       	ldd	r25, Y+3	; 0x03
    1354:	b9 01       	movw	r22, r18
    1356:	af d1       	rcall	.+862    	; 0x16b6 <prvCopyDataFromQueue>
    1358:	8f 85       	ldd	r24, Y+15	; 0x0f
    135a:	88 23       	and	r24, r24
    135c:	c1 f4       	brne	.+48     	; 0x138e <xQueueGenericReceive+0x90>
    135e:	8a 81       	ldd	r24, Y+2	; 0x02
    1360:	9b 81       	ldd	r25, Y+3	; 0x03
    1362:	fc 01       	movw	r30, r24
    1364:	82 8d       	ldd	r24, Z+26	; 0x1a
    1366:	2f ef       	ldi	r18, 0xFF	; 255
    1368:	28 0f       	add	r18, r24
    136a:	8a 81       	ldd	r24, Y+2	; 0x02
    136c:	9b 81       	ldd	r25, Y+3	; 0x03
    136e:	fc 01       	movw	r30, r24
    1370:	22 8f       	std	Z+26, r18	; 0x1a
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	9b 81       	ldd	r25, Y+3	; 0x03
    1376:	fc 01       	movw	r30, r24
    1378:	80 85       	ldd	r24, Z+8	; 0x08
    137a:	88 23       	and	r24, r24
    137c:	e1 f0       	breq	.+56     	; 0x13b6 <xQueueGenericReceive+0xb8>
    137e:	8a 81       	ldd	r24, Y+2	; 0x02
    1380:	9b 81       	ldd	r25, Y+3	; 0x03
    1382:	08 96       	adiw	r24, 0x08	; 8
    1384:	01 d7       	rcall	.+3586   	; 0x2188 <xTaskRemoveFromEventList>
    1386:	81 30       	cpi	r24, 0x01	; 1
    1388:	b1 f4       	brne	.+44     	; 0x13b6 <xQueueGenericReceive+0xb8>
    138a:	c8 db       	rcall	.-2160   	; 0xb1c <vPortYield>
    138c:	14 c0       	rjmp	.+40     	; 0x13b6 <xQueueGenericReceive+0xb8>
    138e:	8a 81       	ldd	r24, Y+2	; 0x02
    1390:	9b 81       	ldd	r25, Y+3	; 0x03
    1392:	2c 81       	ldd	r18, Y+4	; 0x04
    1394:	3d 81       	ldd	r19, Y+5	; 0x05
    1396:	fc 01       	movw	r30, r24
    1398:	37 83       	std	Z+7, r19	; 0x07
    139a:	26 83       	std	Z+6, r18	; 0x06
    139c:	8a 81       	ldd	r24, Y+2	; 0x02
    139e:	9b 81       	ldd	r25, Y+3	; 0x03
    13a0:	fc 01       	movw	r30, r24
    13a2:	81 89       	ldd	r24, Z+17	; 0x11
    13a4:	88 23       	and	r24, r24
    13a6:	39 f0       	breq	.+14     	; 0x13b6 <xQueueGenericReceive+0xb8>
    13a8:	8a 81       	ldd	r24, Y+2	; 0x02
    13aa:	9b 81       	ldd	r25, Y+3	; 0x03
    13ac:	41 96       	adiw	r24, 0x11	; 17
    13ae:	ec d6       	rcall	.+3544   	; 0x2188 <xTaskRemoveFromEventList>
    13b0:	88 23       	and	r24, r24
    13b2:	09 f0       	breq	.+2      	; 0x13b6 <xQueueGenericReceive+0xb8>
    13b4:	b3 db       	rcall	.-2202   	; 0xb1c <vPortYield>
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	55 c0       	rjmp	.+170    	; 0x1468 <xQueueGenericReceive+0x16a>
    13be:	8d 85       	ldd	r24, Y+13	; 0x0d
    13c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    13c2:	89 2b       	or	r24, r25
    13c4:	21 f4       	brne	.+8      	; 0x13ce <xQueueGenericReceive+0xd0>
    13c6:	0f 90       	pop	r0
    13c8:	0f be       	out	0x3f, r0	; 63
    13ca:	80 e0       	ldi	r24, 0x00	; 0
    13cc:	4d c0       	rjmp	.+154    	; 0x1468 <xQueueGenericReceive+0x16a>
    13ce:	89 81       	ldd	r24, Y+1	; 0x01
    13d0:	88 23       	and	r24, r24
    13d2:	29 f4       	brne	.+10     	; 0x13de <xQueueGenericReceive+0xe0>
    13d4:	ce 01       	movw	r24, r28
    13d6:	06 96       	adiw	r24, 0x06	; 6
    13d8:	44 d7       	rcall	.+3720   	; 0x2262 <vTaskSetTimeOutState>
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	89 83       	std	Y+1, r24	; 0x01
    13de:	0f 90       	pop	r0
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	40 d4       	rcall	.+2176   	; 0x1c64 <vTaskSuspendAll>
    13e4:	0f b6       	in	r0, 0x3f	; 63
    13e6:	f8 94       	cli
    13e8:	0f 92       	push	r0
    13ea:	8a 81       	ldd	r24, Y+2	; 0x02
    13ec:	9b 81       	ldd	r25, Y+3	; 0x03
    13ee:	fc 01       	movw	r30, r24
    13f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    13f2:	8f 3f       	cpi	r24, 0xFF	; 255
    13f4:	21 f4       	brne	.+8      	; 0x13fe <xQueueGenericReceive+0x100>
    13f6:	8a 81       	ldd	r24, Y+2	; 0x02
    13f8:	9b 81       	ldd	r25, Y+3	; 0x03
    13fa:	fc 01       	movw	r30, r24
    13fc:	15 8e       	std	Z+29, r1	; 0x1d
    13fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1400:	9b 81       	ldd	r25, Y+3	; 0x03
    1402:	fc 01       	movw	r30, r24
    1404:	86 8d       	ldd	r24, Z+30	; 0x1e
    1406:	8f 3f       	cpi	r24, 0xFF	; 255
    1408:	21 f4       	brne	.+8      	; 0x1412 <xQueueGenericReceive+0x114>
    140a:	8a 81       	ldd	r24, Y+2	; 0x02
    140c:	9b 81       	ldd	r25, Y+3	; 0x03
    140e:	fc 01       	movw	r30, r24
    1410:	16 8e       	std	Z+30, r1	; 0x1e
    1412:	0f 90       	pop	r0
    1414:	0f be       	out	0x3f, r0	; 63
    1416:	9e 01       	movw	r18, r28
    1418:	23 5f       	subi	r18, 0xF3	; 243
    141a:	3f 4f       	sbci	r19, 0xFF	; 255
    141c:	ce 01       	movw	r24, r28
    141e:	06 96       	adiw	r24, 0x06	; 6
    1420:	b9 01       	movw	r22, r18
    1422:	3b d7       	rcall	.+3702   	; 0x229a <xTaskCheckForTimeOut>
    1424:	88 23       	and	r24, r24
    1426:	c9 f4       	brne	.+50     	; 0x145a <xQueueGenericReceive+0x15c>
    1428:	8a 81       	ldd	r24, Y+2	; 0x02
    142a:	9b 81       	ldd	r25, Y+3	; 0x03
    142c:	f5 d1       	rcall	.+1002   	; 0x1818 <prvIsQueueEmpty>
    142e:	88 23       	and	r24, r24
    1430:	79 f0       	breq	.+30     	; 0x1450 <xQueueGenericReceive+0x152>
    1432:	2d 85       	ldd	r18, Y+13	; 0x0d
    1434:	3e 85       	ldd	r19, Y+14	; 0x0e
    1436:	8a 81       	ldd	r24, Y+2	; 0x02
    1438:	9b 81       	ldd	r25, Y+3	; 0x03
    143a:	41 96       	adiw	r24, 0x11	; 17
    143c:	b9 01       	movw	r22, r18
    143e:	3e d6       	rcall	.+3196   	; 0x20bc <vTaskPlaceOnEventList>
    1440:	8a 81       	ldd	r24, Y+2	; 0x02
    1442:	9b 81       	ldd	r25, Y+3	; 0x03
    1444:	88 d1       	rcall	.+784    	; 0x1756 <prvUnlockQueue>
    1446:	1a d4       	rcall	.+2100   	; 0x1c7c <xTaskResumeAll>
    1448:	88 23       	and	r24, r24
    144a:	69 f4       	brne	.+26     	; 0x1466 <xQueueGenericReceive+0x168>
    144c:	67 db       	rcall	.-2354   	; 0xb1c <vPortYield>
    144e:	0b c0       	rjmp	.+22     	; 0x1466 <xQueueGenericReceive+0x168>
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	9b 81       	ldd	r25, Y+3	; 0x03
    1454:	80 d1       	rcall	.+768    	; 0x1756 <prvUnlockQueue>
    1456:	12 d4       	rcall	.+2084   	; 0x1c7c <xTaskResumeAll>
    1458:	68 cf       	rjmp	.-304    	; 0x132a <xQueueGenericReceive+0x2c>
    145a:	8a 81       	ldd	r24, Y+2	; 0x02
    145c:	9b 81       	ldd	r25, Y+3	; 0x03
    145e:	7b d1       	rcall	.+758    	; 0x1756 <prvUnlockQueue>
    1460:	0d d4       	rcall	.+2074   	; 0x1c7c <xTaskResumeAll>
    1462:	80 e0       	ldi	r24, 0x00	; 0
    1464:	01 c0       	rjmp	.+2      	; 0x1468 <xQueueGenericReceive+0x16a>
    1466:	61 cf       	rjmp	.-318    	; 0x132a <xQueueGenericReceive+0x2c>
    1468:	2f 96       	adiw	r28, 0x0f	; 15
    146a:	0f b6       	in	r0, 0x3f	; 63
    146c:	f8 94       	cli
    146e:	de bf       	out	0x3e, r29	; 62
    1470:	0f be       	out	0x3f, r0	; 63
    1472:	cd bf       	out	0x3d, r28	; 61
    1474:	df 91       	pop	r29
    1476:	cf 91       	pop	r28
    1478:	08 95       	ret

0000147a <xQueueReceiveFromISR>:
    147a:	cf 93       	push	r28
    147c:	df 93       	push	r29
    147e:	cd b7       	in	r28, 0x3d	; 61
    1480:	de b7       	in	r29, 0x3e	; 62
    1482:	2a 97       	sbiw	r28, 0x0a	; 10
    1484:	0f b6       	in	r0, 0x3f	; 63
    1486:	f8 94       	cli
    1488:	de bf       	out	0x3e, r29	; 62
    148a:	0f be       	out	0x3f, r0	; 63
    148c:	cd bf       	out	0x3d, r28	; 61
    148e:	9e 83       	std	Y+6, r25	; 0x06
    1490:	8d 83       	std	Y+5, r24	; 0x05
    1492:	78 87       	std	Y+8, r23	; 0x08
    1494:	6f 83       	std	Y+7, r22	; 0x07
    1496:	5a 87       	std	Y+10, r21	; 0x0a
    1498:	49 87       	std	Y+9, r20	; 0x09
    149a:	8d 81       	ldd	r24, Y+5	; 0x05
    149c:	9e 81       	ldd	r25, Y+6	; 0x06
    149e:	9b 83       	std	Y+3, r25	; 0x03
    14a0:	8a 83       	std	Y+2, r24	; 0x02
    14a2:	1c 82       	std	Y+4, r1	; 0x04
    14a4:	8a 81       	ldd	r24, Y+2	; 0x02
    14a6:	9b 81       	ldd	r25, Y+3	; 0x03
    14a8:	fc 01       	movw	r30, r24
    14aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ac:	88 23       	and	r24, r24
    14ae:	c9 f1       	breq	.+114    	; 0x1522 <xQueueReceiveFromISR+0xa8>
    14b0:	2f 81       	ldd	r18, Y+7	; 0x07
    14b2:	38 85       	ldd	r19, Y+8	; 0x08
    14b4:	8a 81       	ldd	r24, Y+2	; 0x02
    14b6:	9b 81       	ldd	r25, Y+3	; 0x03
    14b8:	b9 01       	movw	r22, r18
    14ba:	fd d0       	rcall	.+506    	; 0x16b6 <prvCopyDataFromQueue>
    14bc:	8a 81       	ldd	r24, Y+2	; 0x02
    14be:	9b 81       	ldd	r25, Y+3	; 0x03
    14c0:	fc 01       	movw	r30, r24
    14c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    14c4:	2f ef       	ldi	r18, 0xFF	; 255
    14c6:	28 0f       	add	r18, r24
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	9b 81       	ldd	r25, Y+3	; 0x03
    14cc:	fc 01       	movw	r30, r24
    14ce:	22 8f       	std	Z+26, r18	; 0x1a
    14d0:	8a 81       	ldd	r24, Y+2	; 0x02
    14d2:	9b 81       	ldd	r25, Y+3	; 0x03
    14d4:	fc 01       	movw	r30, r24
    14d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14d8:	8f 3f       	cpi	r24, 0xFF	; 255
    14da:	b1 f4       	brne	.+44     	; 0x1508 <xQueueReceiveFromISR+0x8e>
    14dc:	8a 81       	ldd	r24, Y+2	; 0x02
    14de:	9b 81       	ldd	r25, Y+3	; 0x03
    14e0:	fc 01       	movw	r30, r24
    14e2:	80 85       	ldd	r24, Z+8	; 0x08
    14e4:	88 23       	and	r24, r24
    14e6:	d1 f0       	breq	.+52     	; 0x151c <xQueueReceiveFromISR+0xa2>
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	9b 81       	ldd	r25, Y+3	; 0x03
    14ec:	08 96       	adiw	r24, 0x08	; 8
    14ee:	4c d6       	rcall	.+3224   	; 0x2188 <xTaskRemoveFromEventList>
    14f0:	88 23       	and	r24, r24
    14f2:	a1 f0       	breq	.+40     	; 0x151c <xQueueReceiveFromISR+0xa2>
    14f4:	89 85       	ldd	r24, Y+9	; 0x09
    14f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    14f8:	89 2b       	or	r24, r25
    14fa:	81 f0       	breq	.+32     	; 0x151c <xQueueReceiveFromISR+0xa2>
    14fc:	89 85       	ldd	r24, Y+9	; 0x09
    14fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1500:	21 e0       	ldi	r18, 0x01	; 1
    1502:	fc 01       	movw	r30, r24
    1504:	20 83       	st	Z, r18
    1506:	0a c0       	rjmp	.+20     	; 0x151c <xQueueReceiveFromISR+0xa2>
    1508:	8a 81       	ldd	r24, Y+2	; 0x02
    150a:	9b 81       	ldd	r25, Y+3	; 0x03
    150c:	fc 01       	movw	r30, r24
    150e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1510:	8f 5f       	subi	r24, 0xFF	; 255
    1512:	28 2f       	mov	r18, r24
    1514:	8a 81       	ldd	r24, Y+2	; 0x02
    1516:	9b 81       	ldd	r25, Y+3	; 0x03
    1518:	fc 01       	movw	r30, r24
    151a:	25 8f       	std	Z+29, r18	; 0x1d
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	89 83       	std	Y+1, r24	; 0x01
    1520:	01 c0       	rjmp	.+2      	; 0x1524 <xQueueReceiveFromISR+0xaa>
    1522:	19 82       	std	Y+1, r1	; 0x01
    1524:	89 81       	ldd	r24, Y+1	; 0x01
    1526:	2a 96       	adiw	r28, 0x0a	; 10
    1528:	0f b6       	in	r0, 0x3f	; 63
    152a:	f8 94       	cli
    152c:	de bf       	out	0x3e, r29	; 62
    152e:	0f be       	out	0x3f, r0	; 63
    1530:	cd bf       	out	0x3d, r28	; 61
    1532:	df 91       	pop	r29
    1534:	cf 91       	pop	r28
    1536:	08 95       	ret

00001538 <prvCopyDataToQueue>:
    1538:	cf 93       	push	r28
    153a:	df 93       	push	r29
    153c:	00 d0       	rcall	.+0      	; 0x153e <prvCopyDataToQueue+0x6>
    153e:	00 d0       	rcall	.+0      	; 0x1540 <prvCopyDataToQueue+0x8>
    1540:	cd b7       	in	r28, 0x3d	; 61
    1542:	de b7       	in	r29, 0x3e	; 62
    1544:	9b 83       	std	Y+3, r25	; 0x03
    1546:	8a 83       	std	Y+2, r24	; 0x02
    1548:	7d 83       	std	Y+5, r23	; 0x05
    154a:	6c 83       	std	Y+4, r22	; 0x04
    154c:	4e 83       	std	Y+6, r20	; 0x06
    154e:	19 82       	std	Y+1, r1	; 0x01
    1550:	8a 81       	ldd	r24, Y+2	; 0x02
    1552:	9b 81       	ldd	r25, Y+3	; 0x03
    1554:	fc 01       	movw	r30, r24
    1556:	84 8d       	ldd	r24, Z+28	; 0x1c
    1558:	88 23       	and	r24, r24
    155a:	09 f4       	brne	.+2      	; 0x155e <prvCopyDataToQueue+0x26>
    155c:	98 c0       	rjmp	.+304    	; 0x168e <prvCopyDataToQueue+0x156>
    155e:	8e 81       	ldd	r24, Y+6	; 0x06
    1560:	88 23       	and	r24, r24
    1562:	d9 f5       	brne	.+118    	; 0x15da <prvCopyDataToQueue+0xa2>
    1564:	8a 81       	ldd	r24, Y+2	; 0x02
    1566:	9b 81       	ldd	r25, Y+3	; 0x03
    1568:	fc 01       	movw	r30, r24
    156a:	84 8d       	ldd	r24, Z+28	; 0x1c
    156c:	48 2f       	mov	r20, r24
    156e:	50 e0       	ldi	r21, 0x00	; 0
    1570:	8a 81       	ldd	r24, Y+2	; 0x02
    1572:	9b 81       	ldd	r25, Y+3	; 0x03
    1574:	fc 01       	movw	r30, r24
    1576:	84 81       	ldd	r24, Z+4	; 0x04
    1578:	95 81       	ldd	r25, Z+5	; 0x05
    157a:	2c 81       	ldd	r18, Y+4	; 0x04
    157c:	3d 81       	ldd	r19, Y+5	; 0x05
    157e:	b9 01       	movw	r22, r18
    1580:	0e 94 ae 1a 	call	0x355c	; 0x355c <memcpy>
    1584:	8a 81       	ldd	r24, Y+2	; 0x02
    1586:	9b 81       	ldd	r25, Y+3	; 0x03
    1588:	fc 01       	movw	r30, r24
    158a:	24 81       	ldd	r18, Z+4	; 0x04
    158c:	35 81       	ldd	r19, Z+5	; 0x05
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	9b 81       	ldd	r25, Y+3	; 0x03
    1592:	fc 01       	movw	r30, r24
    1594:	84 8d       	ldd	r24, Z+28	; 0x1c
    1596:	88 2f       	mov	r24, r24
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	28 0f       	add	r18, r24
    159c:	39 1f       	adc	r19, r25
    159e:	8a 81       	ldd	r24, Y+2	; 0x02
    15a0:	9b 81       	ldd	r25, Y+3	; 0x03
    15a2:	fc 01       	movw	r30, r24
    15a4:	35 83       	std	Z+5, r19	; 0x05
    15a6:	24 83       	std	Z+4, r18	; 0x04
    15a8:	8a 81       	ldd	r24, Y+2	; 0x02
    15aa:	9b 81       	ldd	r25, Y+3	; 0x03
    15ac:	fc 01       	movw	r30, r24
    15ae:	24 81       	ldd	r18, Z+4	; 0x04
    15b0:	35 81       	ldd	r19, Z+5	; 0x05
    15b2:	8a 81       	ldd	r24, Y+2	; 0x02
    15b4:	9b 81       	ldd	r25, Y+3	; 0x03
    15b6:	fc 01       	movw	r30, r24
    15b8:	82 81       	ldd	r24, Z+2	; 0x02
    15ba:	93 81       	ldd	r25, Z+3	; 0x03
    15bc:	28 17       	cp	r18, r24
    15be:	39 07       	cpc	r19, r25
    15c0:	08 f4       	brcc	.+2      	; 0x15c4 <prvCopyDataToQueue+0x8c>
    15c2:	65 c0       	rjmp	.+202    	; 0x168e <prvCopyDataToQueue+0x156>
    15c4:	8a 81       	ldd	r24, Y+2	; 0x02
    15c6:	9b 81       	ldd	r25, Y+3	; 0x03
    15c8:	fc 01       	movw	r30, r24
    15ca:	20 81       	ld	r18, Z
    15cc:	31 81       	ldd	r19, Z+1	; 0x01
    15ce:	8a 81       	ldd	r24, Y+2	; 0x02
    15d0:	9b 81       	ldd	r25, Y+3	; 0x03
    15d2:	fc 01       	movw	r30, r24
    15d4:	35 83       	std	Z+5, r19	; 0x05
    15d6:	24 83       	std	Z+4, r18	; 0x04
    15d8:	5a c0       	rjmp	.+180    	; 0x168e <prvCopyDataToQueue+0x156>
    15da:	8a 81       	ldd	r24, Y+2	; 0x02
    15dc:	9b 81       	ldd	r25, Y+3	; 0x03
    15de:	fc 01       	movw	r30, r24
    15e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    15e2:	48 2f       	mov	r20, r24
    15e4:	50 e0       	ldi	r21, 0x00	; 0
    15e6:	8a 81       	ldd	r24, Y+2	; 0x02
    15e8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ea:	fc 01       	movw	r30, r24
    15ec:	86 81       	ldd	r24, Z+6	; 0x06
    15ee:	97 81       	ldd	r25, Z+7	; 0x07
    15f0:	2c 81       	ldd	r18, Y+4	; 0x04
    15f2:	3d 81       	ldd	r19, Y+5	; 0x05
    15f4:	b9 01       	movw	r22, r18
    15f6:	0e 94 ae 1a 	call	0x355c	; 0x355c <memcpy>
    15fa:	8a 81       	ldd	r24, Y+2	; 0x02
    15fc:	9b 81       	ldd	r25, Y+3	; 0x03
    15fe:	fc 01       	movw	r30, r24
    1600:	26 81       	ldd	r18, Z+6	; 0x06
    1602:	37 81       	ldd	r19, Z+7	; 0x07
    1604:	8a 81       	ldd	r24, Y+2	; 0x02
    1606:	9b 81       	ldd	r25, Y+3	; 0x03
    1608:	fc 01       	movw	r30, r24
    160a:	84 8d       	ldd	r24, Z+28	; 0x1c
    160c:	88 2f       	mov	r24, r24
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	91 95       	neg	r25
    1612:	81 95       	neg	r24
    1614:	91 09       	sbc	r25, r1
    1616:	28 0f       	add	r18, r24
    1618:	39 1f       	adc	r19, r25
    161a:	8a 81       	ldd	r24, Y+2	; 0x02
    161c:	9b 81       	ldd	r25, Y+3	; 0x03
    161e:	fc 01       	movw	r30, r24
    1620:	37 83       	std	Z+7, r19	; 0x07
    1622:	26 83       	std	Z+6, r18	; 0x06
    1624:	8a 81       	ldd	r24, Y+2	; 0x02
    1626:	9b 81       	ldd	r25, Y+3	; 0x03
    1628:	fc 01       	movw	r30, r24
    162a:	26 81       	ldd	r18, Z+6	; 0x06
    162c:	37 81       	ldd	r19, Z+7	; 0x07
    162e:	8a 81       	ldd	r24, Y+2	; 0x02
    1630:	9b 81       	ldd	r25, Y+3	; 0x03
    1632:	fc 01       	movw	r30, r24
    1634:	80 81       	ld	r24, Z
    1636:	91 81       	ldd	r25, Z+1	; 0x01
    1638:	28 17       	cp	r18, r24
    163a:	39 07       	cpc	r19, r25
    163c:	a8 f4       	brcc	.+42     	; 0x1668 <prvCopyDataToQueue+0x130>
    163e:	8a 81       	ldd	r24, Y+2	; 0x02
    1640:	9b 81       	ldd	r25, Y+3	; 0x03
    1642:	fc 01       	movw	r30, r24
    1644:	22 81       	ldd	r18, Z+2	; 0x02
    1646:	33 81       	ldd	r19, Z+3	; 0x03
    1648:	8a 81       	ldd	r24, Y+2	; 0x02
    164a:	9b 81       	ldd	r25, Y+3	; 0x03
    164c:	fc 01       	movw	r30, r24
    164e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1650:	88 2f       	mov	r24, r24
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	91 95       	neg	r25
    1656:	81 95       	neg	r24
    1658:	91 09       	sbc	r25, r1
    165a:	28 0f       	add	r18, r24
    165c:	39 1f       	adc	r19, r25
    165e:	8a 81       	ldd	r24, Y+2	; 0x02
    1660:	9b 81       	ldd	r25, Y+3	; 0x03
    1662:	fc 01       	movw	r30, r24
    1664:	37 83       	std	Z+7, r19	; 0x07
    1666:	26 83       	std	Z+6, r18	; 0x06
    1668:	8e 81       	ldd	r24, Y+6	; 0x06
    166a:	82 30       	cpi	r24, 0x02	; 2
    166c:	81 f4       	brne	.+32     	; 0x168e <prvCopyDataToQueue+0x156>
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	9b 81       	ldd	r25, Y+3	; 0x03
    1672:	fc 01       	movw	r30, r24
    1674:	82 8d       	ldd	r24, Z+26	; 0x1a
    1676:	88 23       	and	r24, r24
    1678:	51 f0       	breq	.+20     	; 0x168e <prvCopyDataToQueue+0x156>
    167a:	8a 81       	ldd	r24, Y+2	; 0x02
    167c:	9b 81       	ldd	r25, Y+3	; 0x03
    167e:	fc 01       	movw	r30, r24
    1680:	82 8d       	ldd	r24, Z+26	; 0x1a
    1682:	2f ef       	ldi	r18, 0xFF	; 255
    1684:	28 0f       	add	r18, r24
    1686:	8a 81       	ldd	r24, Y+2	; 0x02
    1688:	9b 81       	ldd	r25, Y+3	; 0x03
    168a:	fc 01       	movw	r30, r24
    168c:	22 8f       	std	Z+26, r18	; 0x1a
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	9b 81       	ldd	r25, Y+3	; 0x03
    1692:	fc 01       	movw	r30, r24
    1694:	82 8d       	ldd	r24, Z+26	; 0x1a
    1696:	21 e0       	ldi	r18, 0x01	; 1
    1698:	28 0f       	add	r18, r24
    169a:	8a 81       	ldd	r24, Y+2	; 0x02
    169c:	9b 81       	ldd	r25, Y+3	; 0x03
    169e:	fc 01       	movw	r30, r24
    16a0:	22 8f       	std	Z+26, r18	; 0x1a
    16a2:	89 81       	ldd	r24, Y+1	; 0x01
    16a4:	26 96       	adiw	r28, 0x06	; 6
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	de bf       	out	0x3e, r29	; 62
    16ac:	0f be       	out	0x3f, r0	; 63
    16ae:	cd bf       	out	0x3d, r28	; 61
    16b0:	df 91       	pop	r29
    16b2:	cf 91       	pop	r28
    16b4:	08 95       	ret

000016b6 <prvCopyDataFromQueue>:
    16b6:	cf 93       	push	r28
    16b8:	df 93       	push	r29
    16ba:	00 d0       	rcall	.+0      	; 0x16bc <prvCopyDataFromQueue+0x6>
    16bc:	1f 92       	push	r1
    16be:	cd b7       	in	r28, 0x3d	; 61
    16c0:	de b7       	in	r29, 0x3e	; 62
    16c2:	9a 83       	std	Y+2, r25	; 0x02
    16c4:	89 83       	std	Y+1, r24	; 0x01
    16c6:	7c 83       	std	Y+4, r23	; 0x04
    16c8:	6b 83       	std	Y+3, r22	; 0x03
    16ca:	89 81       	ldd	r24, Y+1	; 0x01
    16cc:	9a 81       	ldd	r25, Y+2	; 0x02
    16ce:	fc 01       	movw	r30, r24
    16d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d2:	88 23       	and	r24, r24
    16d4:	c9 f1       	breq	.+114    	; 0x1748 <prvCopyDataFromQueue+0x92>
    16d6:	89 81       	ldd	r24, Y+1	; 0x01
    16d8:	9a 81       	ldd	r25, Y+2	; 0x02
    16da:	fc 01       	movw	r30, r24
    16dc:	26 81       	ldd	r18, Z+6	; 0x06
    16de:	37 81       	ldd	r19, Z+7	; 0x07
    16e0:	89 81       	ldd	r24, Y+1	; 0x01
    16e2:	9a 81       	ldd	r25, Y+2	; 0x02
    16e4:	fc 01       	movw	r30, r24
    16e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    16e8:	88 2f       	mov	r24, r24
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	28 0f       	add	r18, r24
    16ee:	39 1f       	adc	r19, r25
    16f0:	89 81       	ldd	r24, Y+1	; 0x01
    16f2:	9a 81       	ldd	r25, Y+2	; 0x02
    16f4:	fc 01       	movw	r30, r24
    16f6:	37 83       	std	Z+7, r19	; 0x07
    16f8:	26 83       	std	Z+6, r18	; 0x06
    16fa:	89 81       	ldd	r24, Y+1	; 0x01
    16fc:	9a 81       	ldd	r25, Y+2	; 0x02
    16fe:	fc 01       	movw	r30, r24
    1700:	26 81       	ldd	r18, Z+6	; 0x06
    1702:	37 81       	ldd	r19, Z+7	; 0x07
    1704:	89 81       	ldd	r24, Y+1	; 0x01
    1706:	9a 81       	ldd	r25, Y+2	; 0x02
    1708:	fc 01       	movw	r30, r24
    170a:	82 81       	ldd	r24, Z+2	; 0x02
    170c:	93 81       	ldd	r25, Z+3	; 0x03
    170e:	28 17       	cp	r18, r24
    1710:	39 07       	cpc	r19, r25
    1712:	50 f0       	brcs	.+20     	; 0x1728 <prvCopyDataFromQueue+0x72>
    1714:	89 81       	ldd	r24, Y+1	; 0x01
    1716:	9a 81       	ldd	r25, Y+2	; 0x02
    1718:	fc 01       	movw	r30, r24
    171a:	20 81       	ld	r18, Z
    171c:	31 81       	ldd	r19, Z+1	; 0x01
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	9a 81       	ldd	r25, Y+2	; 0x02
    1722:	fc 01       	movw	r30, r24
    1724:	37 83       	std	Z+7, r19	; 0x07
    1726:	26 83       	std	Z+6, r18	; 0x06
    1728:	89 81       	ldd	r24, Y+1	; 0x01
    172a:	9a 81       	ldd	r25, Y+2	; 0x02
    172c:	fc 01       	movw	r30, r24
    172e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1730:	48 2f       	mov	r20, r24
    1732:	50 e0       	ldi	r21, 0x00	; 0
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	9a 81       	ldd	r25, Y+2	; 0x02
    1738:	fc 01       	movw	r30, r24
    173a:	26 81       	ldd	r18, Z+6	; 0x06
    173c:	37 81       	ldd	r19, Z+7	; 0x07
    173e:	8b 81       	ldd	r24, Y+3	; 0x03
    1740:	9c 81       	ldd	r25, Y+4	; 0x04
    1742:	b9 01       	movw	r22, r18
    1744:	0e 94 ae 1a 	call	0x355c	; 0x355c <memcpy>
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	08 95       	ret

00001756 <prvUnlockQueue>:
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	1f 92       	push	r1
    175c:	1f 92       	push	r1
    175e:	cd b7       	in	r28, 0x3d	; 61
    1760:	de b7       	in	r29, 0x3e	; 62
    1762:	9a 83       	std	Y+2, r25	; 0x02
    1764:	89 83       	std	Y+1, r24	; 0x01
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	0f 92       	push	r0
    176c:	19 c0       	rjmp	.+50     	; 0x17a0 <prvUnlockQueue+0x4a>
    176e:	89 81       	ldd	r24, Y+1	; 0x01
    1770:	9a 81       	ldd	r25, Y+2	; 0x02
    1772:	fc 01       	movw	r30, r24
    1774:	81 89       	ldd	r24, Z+17	; 0x11
    1776:	88 23       	and	r24, r24
    1778:	41 f0       	breq	.+16     	; 0x178a <prvUnlockQueue+0x34>
    177a:	89 81       	ldd	r24, Y+1	; 0x01
    177c:	9a 81       	ldd	r25, Y+2	; 0x02
    177e:	41 96       	adiw	r24, 0x11	; 17
    1780:	03 d5       	rcall	.+2566   	; 0x2188 <xTaskRemoveFromEventList>
    1782:	88 23       	and	r24, r24
    1784:	19 f0       	breq	.+6      	; 0x178c <prvUnlockQueue+0x36>
    1786:	f0 d5       	rcall	.+3040   	; 0x2368 <vTaskMissedYield>
    1788:	01 c0       	rjmp	.+2      	; 0x178c <prvUnlockQueue+0x36>
    178a:	10 c0       	rjmp	.+32     	; 0x17ac <prvUnlockQueue+0x56>
    178c:	89 81       	ldd	r24, Y+1	; 0x01
    178e:	9a 81       	ldd	r25, Y+2	; 0x02
    1790:	fc 01       	movw	r30, r24
    1792:	86 8d       	ldd	r24, Z+30	; 0x1e
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	28 2f       	mov	r18, r24
    1798:	89 81       	ldd	r24, Y+1	; 0x01
    179a:	9a 81       	ldd	r25, Y+2	; 0x02
    179c:	fc 01       	movw	r30, r24
    179e:	26 8f       	std	Z+30, r18	; 0x1e
    17a0:	89 81       	ldd	r24, Y+1	; 0x01
    17a2:	9a 81       	ldd	r25, Y+2	; 0x02
    17a4:	fc 01       	movw	r30, r24
    17a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    17a8:	18 16       	cp	r1, r24
    17aa:	0c f3       	brlt	.-62     	; 0x176e <prvUnlockQueue+0x18>
    17ac:	89 81       	ldd	r24, Y+1	; 0x01
    17ae:	9a 81       	ldd	r25, Y+2	; 0x02
    17b0:	2f ef       	ldi	r18, 0xFF	; 255
    17b2:	fc 01       	movw	r30, r24
    17b4:	26 8f       	std	Z+30, r18	; 0x1e
    17b6:	0f 90       	pop	r0
    17b8:	0f be       	out	0x3f, r0	; 63
    17ba:	0f b6       	in	r0, 0x3f	; 63
    17bc:	f8 94       	cli
    17be:	0f 92       	push	r0
    17c0:	19 c0       	rjmp	.+50     	; 0x17f4 <prvUnlockQueue+0x9e>
    17c2:	89 81       	ldd	r24, Y+1	; 0x01
    17c4:	9a 81       	ldd	r25, Y+2	; 0x02
    17c6:	fc 01       	movw	r30, r24
    17c8:	80 85       	ldd	r24, Z+8	; 0x08
    17ca:	88 23       	and	r24, r24
    17cc:	91 f0       	breq	.+36     	; 0x17f2 <prvUnlockQueue+0x9c>
    17ce:	89 81       	ldd	r24, Y+1	; 0x01
    17d0:	9a 81       	ldd	r25, Y+2	; 0x02
    17d2:	08 96       	adiw	r24, 0x08	; 8
    17d4:	d9 d4       	rcall	.+2482   	; 0x2188 <xTaskRemoveFromEventList>
    17d6:	88 23       	and	r24, r24
    17d8:	09 f0       	breq	.+2      	; 0x17dc <prvUnlockQueue+0x86>
    17da:	c6 d5       	rcall	.+2956   	; 0x2368 <vTaskMissedYield>
    17dc:	89 81       	ldd	r24, Y+1	; 0x01
    17de:	9a 81       	ldd	r25, Y+2	; 0x02
    17e0:	fc 01       	movw	r30, r24
    17e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    17e4:	81 50       	subi	r24, 0x01	; 1
    17e6:	28 2f       	mov	r18, r24
    17e8:	89 81       	ldd	r24, Y+1	; 0x01
    17ea:	9a 81       	ldd	r25, Y+2	; 0x02
    17ec:	fc 01       	movw	r30, r24
    17ee:	25 8f       	std	Z+29, r18	; 0x1d
    17f0:	01 c0       	rjmp	.+2      	; 0x17f4 <prvUnlockQueue+0x9e>
    17f2:	06 c0       	rjmp	.+12     	; 0x1800 <prvUnlockQueue+0xaa>
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	fc 01       	movw	r30, r24
    17fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    17fc:	18 16       	cp	r1, r24
    17fe:	0c f3       	brlt	.-62     	; 0x17c2 <prvUnlockQueue+0x6c>
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	2f ef       	ldi	r18, 0xFF	; 255
    1806:	fc 01       	movw	r30, r24
    1808:	25 8f       	std	Z+29, r18	; 0x1d
    180a:	0f 90       	pop	r0
    180c:	0f be       	out	0x3f, r0	; 63
    180e:	0f 90       	pop	r0
    1810:	0f 90       	pop	r0
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	08 95       	ret

00001818 <prvIsQueueEmpty>:
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	00 d0       	rcall	.+0      	; 0x181e <prvIsQueueEmpty+0x6>
    181e:	cd b7       	in	r28, 0x3d	; 61
    1820:	de b7       	in	r29, 0x3e	; 62
    1822:	9b 83       	std	Y+3, r25	; 0x03
    1824:	8a 83       	std	Y+2, r24	; 0x02
    1826:	0f b6       	in	r0, 0x3f	; 63
    1828:	f8 94       	cli
    182a:	0f 92       	push	r0
    182c:	8a 81       	ldd	r24, Y+2	; 0x02
    182e:	9b 81       	ldd	r25, Y+3	; 0x03
    1830:	fc 01       	movw	r30, r24
    1832:	82 8d       	ldd	r24, Z+26	; 0x1a
    1834:	88 23       	and	r24, r24
    1836:	19 f4       	brne	.+6      	; 0x183e <prvIsQueueEmpty+0x26>
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	89 83       	std	Y+1, r24	; 0x01
    183c:	01 c0       	rjmp	.+2      	; 0x1840 <prvIsQueueEmpty+0x28>
    183e:	19 82       	std	Y+1, r1	; 0x01
    1840:	0f 90       	pop	r0
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	89 81       	ldd	r24, Y+1	; 0x01
    1846:	0f 90       	pop	r0
    1848:	0f 90       	pop	r0
    184a:	0f 90       	pop	r0
    184c:	df 91       	pop	r29
    184e:	cf 91       	pop	r28
    1850:	08 95       	ret

00001852 <prvIsQueueFull>:
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	00 d0       	rcall	.+0      	; 0x1858 <prvIsQueueFull+0x6>
    1858:	cd b7       	in	r28, 0x3d	; 61
    185a:	de b7       	in	r29, 0x3e	; 62
    185c:	9b 83       	std	Y+3, r25	; 0x03
    185e:	8a 83       	std	Y+2, r24	; 0x02
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	f8 94       	cli
    1864:	0f 92       	push	r0
    1866:	8a 81       	ldd	r24, Y+2	; 0x02
    1868:	9b 81       	ldd	r25, Y+3	; 0x03
    186a:	fc 01       	movw	r30, r24
    186c:	22 8d       	ldd	r18, Z+26	; 0x1a
    186e:	8a 81       	ldd	r24, Y+2	; 0x02
    1870:	9b 81       	ldd	r25, Y+3	; 0x03
    1872:	fc 01       	movw	r30, r24
    1874:	83 8d       	ldd	r24, Z+27	; 0x1b
    1876:	28 17       	cp	r18, r24
    1878:	19 f4       	brne	.+6      	; 0x1880 <prvIsQueueFull+0x2e>
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	89 83       	std	Y+1, r24	; 0x01
    187e:	01 c0       	rjmp	.+2      	; 0x1882 <prvIsQueueFull+0x30>
    1880:	19 82       	std	Y+1, r1	; 0x01
    1882:	0f 90       	pop	r0
    1884:	0f be       	out	0x3f, r0	; 63
    1886:	89 81       	ldd	r24, Y+1	; 0x01
    1888:	0f 90       	pop	r0
    188a:	0f 90       	pop	r0
    188c:	0f 90       	pop	r0
    188e:	df 91       	pop	r29
    1890:	cf 91       	pop	r28
    1892:	08 95       	ret

00001894 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    1894:	cf 93       	push	r28
    1896:	df 93       	push	r29
    1898:	00 d0       	rcall	.+0      	; 0x189a <vQueueWaitForMessageRestricted+0x6>
    189a:	00 d0       	rcall	.+0      	; 0x189c <vQueueWaitForMessageRestricted+0x8>
    189c:	cd b7       	in	r28, 0x3d	; 61
    189e:	de b7       	in	r29, 0x3e	; 62
    18a0:	9c 83       	std	Y+4, r25	; 0x04
    18a2:	8b 83       	std	Y+3, r24	; 0x03
    18a4:	7e 83       	std	Y+6, r23	; 0x06
    18a6:	6d 83       	std	Y+5, r22	; 0x05
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	9a 83       	std	Y+2, r25	; 0x02
    18ae:	89 83       	std	Y+1, r24	; 0x01
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
    18b6:	89 81       	ldd	r24, Y+1	; 0x01
    18b8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ba:	fc 01       	movw	r30, r24
    18bc:	85 8d       	ldd	r24, Z+29	; 0x1d
    18be:	8f 3f       	cpi	r24, 0xFF	; 255
    18c0:	21 f4       	brne	.+8      	; 0x18ca <vQueueWaitForMessageRestricted+0x36>
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	9a 81       	ldd	r25, Y+2	; 0x02
    18c6:	fc 01       	movw	r30, r24
    18c8:	15 8e       	std	Z+29, r1	; 0x1d
    18ca:	89 81       	ldd	r24, Y+1	; 0x01
    18cc:	9a 81       	ldd	r25, Y+2	; 0x02
    18ce:	fc 01       	movw	r30, r24
    18d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    18d2:	8f 3f       	cpi	r24, 0xFF	; 255
    18d4:	21 f4       	brne	.+8      	; 0x18de <vQueueWaitForMessageRestricted+0x4a>
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	9a 81       	ldd	r25, Y+2	; 0x02
    18da:	fc 01       	movw	r30, r24
    18dc:	16 8e       	std	Z+30, r1	; 0x1e
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    18e2:	89 81       	ldd	r24, Y+1	; 0x01
    18e4:	9a 81       	ldd	r25, Y+2	; 0x02
    18e6:	fc 01       	movw	r30, r24
    18e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ea:	88 23       	and	r24, r24
    18ec:	39 f4       	brne	.+14     	; 0x18fc <vQueueWaitForMessageRestricted+0x68>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ee:	89 81       	ldd	r24, Y+1	; 0x01
    18f0:	9a 81       	ldd	r25, Y+2	; 0x02
    18f2:	41 96       	adiw	r24, 0x11	; 17
    18f4:	2d 81       	ldd	r18, Y+5	; 0x05
    18f6:	3e 81       	ldd	r19, Y+6	; 0x06
    18f8:	b9 01       	movw	r22, r18
    18fa:	13 d4       	rcall	.+2086   	; 0x2122 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    18fc:	89 81       	ldd	r24, Y+1	; 0x01
    18fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1900:	2a df       	rcall	.-428    	; 0x1756 <prvUnlockQueue>
	}
    1902:	26 96       	adiw	r28, 0x06	; 6
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	de bf       	out	0x3e, r29	; 62
    190a:	0f be       	out	0x3f, r0	; 63
    190c:	cd bf       	out	0x3d, r28	; 61
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	08 95       	ret

00001914 <xTaskGenericCreate>:
    1914:	af 92       	push	r10
    1916:	bf 92       	push	r11
    1918:	cf 92       	push	r12
    191a:	df 92       	push	r13
    191c:	ef 92       	push	r14
    191e:	ff 92       	push	r15
    1920:	0f 93       	push	r16
    1922:	1f 93       	push	r17
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	cd b7       	in	r28, 0x3d	; 61
    192a:	de b7       	in	r29, 0x3e	; 62
    192c:	64 97       	sbiw	r28, 0x14	; 20
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	de bf       	out	0x3e, r29	; 62
    1934:	0f be       	out	0x3f, r0	; 63
    1936:	cd bf       	out	0x3d, r28	; 61
    1938:	9f 83       	std	Y+7, r25	; 0x07
    193a:	8e 83       	std	Y+6, r24	; 0x06
    193c:	79 87       	std	Y+9, r23	; 0x09
    193e:	68 87       	std	Y+8, r22	; 0x08
    1940:	5b 87       	std	Y+11, r21	; 0x0b
    1942:	4a 87       	std	Y+10, r20	; 0x0a
    1944:	3d 87       	std	Y+13, r19	; 0x0d
    1946:	2c 87       	std	Y+12, r18	; 0x0c
    1948:	0e 87       	std	Y+14, r16	; 0x0e
    194a:	f8 8a       	std	Y+16, r15	; 0x10
    194c:	ef 86       	std	Y+15, r14	; 0x0f
    194e:	da 8a       	std	Y+18, r13	; 0x12
    1950:	c9 8a       	std	Y+17, r12	; 0x11
    1952:	bc 8a       	std	Y+20, r11	; 0x14
    1954:	ab 8a       	std	Y+19, r10	; 0x13
    1956:	29 89       	ldd	r18, Y+17	; 0x11
    1958:	3a 89       	ldd	r19, Y+18	; 0x12
    195a:	8a 85       	ldd	r24, Y+10	; 0x0a
    195c:	9b 85       	ldd	r25, Y+11	; 0x0b
    195e:	b9 01       	movw	r22, r18
    1960:	55 d6       	rcall	.+3242   	; 0x260c <prvAllocateTCBAndStack>
    1962:	9b 83       	std	Y+3, r25	; 0x03
    1964:	8a 83       	std	Y+2, r24	; 0x02
    1966:	8a 81       	ldd	r24, Y+2	; 0x02
    1968:	9b 81       	ldd	r25, Y+3	; 0x03
    196a:	89 2b       	or	r24, r25
    196c:	09 f4       	brne	.+2      	; 0x1970 <xTaskGenericCreate+0x5c>
    196e:	8f c0       	rjmp	.+286    	; 0x1a8e <xTaskGenericCreate+0x17a>
    1970:	8a 81       	ldd	r24, Y+2	; 0x02
    1972:	9b 81       	ldd	r25, Y+3	; 0x03
    1974:	fc 01       	movw	r30, r24
    1976:	27 89       	ldd	r18, Z+23	; 0x17
    1978:	30 8d       	ldd	r19, Z+24	; 0x18
    197a:	8a 85       	ldd	r24, Y+10	; 0x0a
    197c:	9b 85       	ldd	r25, Y+11	; 0x0b
    197e:	01 97       	sbiw	r24, 0x01	; 1
    1980:	82 0f       	add	r24, r18
    1982:	93 1f       	adc	r25, r19
    1984:	9d 83       	std	Y+5, r25	; 0x05
    1986:	8c 83       	std	Y+4, r24	; 0x04
    1988:	4a 85       	ldd	r20, Y+10	; 0x0a
    198a:	5b 85       	ldd	r21, Y+11	; 0x0b
    198c:	2b 89       	ldd	r18, Y+19	; 0x13
    198e:	3c 89       	ldd	r19, Y+20	; 0x14
    1990:	68 85       	ldd	r22, Y+8	; 0x08
    1992:	79 85       	ldd	r23, Y+9	; 0x09
    1994:	8a 81       	ldd	r24, Y+2	; 0x02
    1996:	9b 81       	ldd	r25, Y+3	; 0x03
    1998:	8a 01       	movw	r16, r20
    199a:	4e 85       	ldd	r20, Y+14	; 0x0e
    199c:	ef d4       	rcall	.+2526   	; 0x237c <prvInitialiseTCBVariables>
    199e:	4c 85       	ldd	r20, Y+12	; 0x0c
    19a0:	5d 85       	ldd	r21, Y+13	; 0x0d
    19a2:	2e 81       	ldd	r18, Y+6	; 0x06
    19a4:	3f 81       	ldd	r19, Y+7	; 0x07
    19a6:	8c 81       	ldd	r24, Y+4	; 0x04
    19a8:	9d 81       	ldd	r25, Y+5	; 0x05
    19aa:	b9 01       	movw	r22, r18
    19ac:	0e 94 92 03 	call	0x724	; 0x724 <pxPortInitialiseStack>
    19b0:	9c 01       	movw	r18, r24
    19b2:	8a 81       	ldd	r24, Y+2	; 0x02
    19b4:	9b 81       	ldd	r25, Y+3	; 0x03
    19b6:	fc 01       	movw	r30, r24
    19b8:	31 83       	std	Z+1, r19	; 0x01
    19ba:	20 83       	st	Z, r18
    19bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    19be:	98 89       	ldd	r25, Y+16	; 0x10
    19c0:	89 2b       	or	r24, r25
    19c2:	39 f0       	breq	.+14     	; 0x19d2 <xTaskGenericCreate+0xbe>
    19c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    19c6:	98 89       	ldd	r25, Y+16	; 0x10
    19c8:	2a 81       	ldd	r18, Y+2	; 0x02
    19ca:	3b 81       	ldd	r19, Y+3	; 0x03
    19cc:	fc 01       	movw	r30, r24
    19ce:	31 83       	std	Z+1, r19	; 0x01
    19d0:	20 83       	st	Z, r18
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	0f 92       	push	r0
    19d8:	80 91 87 0c 	lds	r24, 0x0C87
    19dc:	8f 5f       	subi	r24, 0xFF	; 255
    19de:	80 93 87 0c 	sts	0x0C87, r24
    19e2:	80 91 38 0c 	lds	r24, 0x0C38
    19e6:	90 91 39 0c 	lds	r25, 0x0C39
    19ea:	89 2b       	or	r24, r25
    19ec:	61 f4       	brne	.+24     	; 0x1a06 <xTaskGenericCreate+0xf2>
    19ee:	8a 81       	ldd	r24, Y+2	; 0x02
    19f0:	9b 81       	ldd	r25, Y+3	; 0x03
    19f2:	90 93 39 0c 	sts	0x0C39, r25
    19f6:	80 93 38 0c 	sts	0x0C38, r24
    19fa:	80 91 87 0c 	lds	r24, 0x0C87
    19fe:	81 30       	cpi	r24, 0x01	; 1
    1a00:	a9 f4       	brne	.+42     	; 0x1a2c <xTaskGenericCreate+0x118>
    1a02:	40 d5       	rcall	.+2688   	; 0x2484 <prvInitialiseTaskLists>
    1a04:	13 c0       	rjmp	.+38     	; 0x1a2c <xTaskGenericCreate+0x118>
    1a06:	80 91 8b 0c 	lds	r24, 0x0C8B
    1a0a:	88 23       	and	r24, r24
    1a0c:	79 f4       	brne	.+30     	; 0x1a2c <xTaskGenericCreate+0x118>
    1a0e:	80 91 38 0c 	lds	r24, 0x0C38
    1a12:	90 91 39 0c 	lds	r25, 0x0C39
    1a16:	fc 01       	movw	r30, r24
    1a18:	96 89       	ldd	r25, Z+22	; 0x16
    1a1a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a1c:	89 17       	cp	r24, r25
    1a1e:	30 f0       	brcs	.+12     	; 0x1a2c <xTaskGenericCreate+0x118>
    1a20:	8a 81       	ldd	r24, Y+2	; 0x02
    1a22:	9b 81       	ldd	r25, Y+3	; 0x03
    1a24:	90 93 39 0c 	sts	0x0C39, r25
    1a28:	80 93 38 0c 	sts	0x0C38, r24
    1a2c:	80 91 8f 0c 	lds	r24, 0x0C8F
    1a30:	8f 5f       	subi	r24, 0xFF	; 255
    1a32:	80 93 8f 0c 	sts	0x0C8F, r24
    1a36:	8a 81       	ldd	r24, Y+2	; 0x02
    1a38:	9b 81       	ldd	r25, Y+3	; 0x03
    1a3a:	fc 01       	movw	r30, r24
    1a3c:	96 89       	ldd	r25, Z+22	; 0x16
    1a3e:	80 91 8a 0c 	lds	r24, 0x0C8A
    1a42:	89 17       	cp	r24, r25
    1a44:	30 f4       	brcc	.+12     	; 0x1a52 <xTaskGenericCreate+0x13e>
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	9b 81       	ldd	r25, Y+3	; 0x03
    1a4a:	fc 01       	movw	r30, r24
    1a4c:	86 89       	ldd	r24, Z+22	; 0x16
    1a4e:	80 93 8a 0c 	sts	0x0C8A, r24
    1a52:	8a 81       	ldd	r24, Y+2	; 0x02
    1a54:	9b 81       	ldd	r25, Y+3	; 0x03
    1a56:	ac 01       	movw	r20, r24
    1a58:	4e 5f       	subi	r20, 0xFE	; 254
    1a5a:	5f 4f       	sbci	r21, 0xFF	; 255
    1a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a60:	fc 01       	movw	r30, r24
    1a62:	86 89       	ldd	r24, Z+22	; 0x16
    1a64:	28 2f       	mov	r18, r24
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	c9 01       	movw	r24, r18
    1a6a:	88 0f       	add	r24, r24
    1a6c:	99 1f       	adc	r25, r25
    1a6e:	88 0f       	add	r24, r24
    1a70:	99 1f       	adc	r25, r25
    1a72:	88 0f       	add	r24, r24
    1a74:	99 1f       	adc	r25, r25
    1a76:	82 0f       	add	r24, r18
    1a78:	93 1f       	adc	r25, r19
    1a7a:	86 5c       	subi	r24, 0xC6	; 198
    1a7c:	93 4f       	sbci	r25, 0xF3	; 243
    1a7e:	ba 01       	movw	r22, r20
    1a80:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	89 83       	std	Y+1, r24	; 0x01
    1a88:	0f 90       	pop	r0
    1a8a:	0f be       	out	0x3f, r0	; 63
    1a8c:	02 c0       	rjmp	.+4      	; 0x1a92 <xTaskGenericCreate+0x17e>
    1a8e:	8f ef       	ldi	r24, 0xFF	; 255
    1a90:	89 83       	std	Y+1, r24	; 0x01
    1a92:	89 81       	ldd	r24, Y+1	; 0x01
    1a94:	81 30       	cpi	r24, 0x01	; 1
    1a96:	71 f4       	brne	.+28     	; 0x1ab4 <xTaskGenericCreate+0x1a0>
    1a98:	80 91 8b 0c 	lds	r24, 0x0C8B
    1a9c:	88 23       	and	r24, r24
    1a9e:	51 f0       	breq	.+20     	; 0x1ab4 <xTaskGenericCreate+0x1a0>
    1aa0:	80 91 38 0c 	lds	r24, 0x0C38
    1aa4:	90 91 39 0c 	lds	r25, 0x0C39
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	96 89       	ldd	r25, Z+22	; 0x16
    1aac:	8e 85       	ldd	r24, Y+14	; 0x0e
    1aae:	98 17       	cp	r25, r24
    1ab0:	08 f4       	brcc	.+2      	; 0x1ab4 <xTaskGenericCreate+0x1a0>
    1ab2:	34 d8       	rcall	.-3992   	; 0xb1c <vPortYield>
    1ab4:	89 81       	ldd	r24, Y+1	; 0x01
    1ab6:	64 96       	adiw	r28, 0x14	; 20
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	f8 94       	cli
    1abc:	de bf       	out	0x3e, r29	; 62
    1abe:	0f be       	out	0x3f, r0	; 63
    1ac0:	cd bf       	out	0x3d, r28	; 61
    1ac2:	df 91       	pop	r29
    1ac4:	cf 91       	pop	r28
    1ac6:	1f 91       	pop	r17
    1ac8:	0f 91       	pop	r16
    1aca:	ff 90       	pop	r15
    1acc:	ef 90       	pop	r14
    1ace:	df 90       	pop	r13
    1ad0:	cf 90       	pop	r12
    1ad2:	bf 90       	pop	r11
    1ad4:	af 90       	pop	r10
    1ad6:	08 95       	ret

00001ad8 <vTaskDelete>:
    1ad8:	cf 93       	push	r28
    1ada:	df 93       	push	r29
    1adc:	00 d0       	rcall	.+0      	; 0x1ade <vTaskDelete+0x6>
    1ade:	1f 92       	push	r1
    1ae0:	cd b7       	in	r28, 0x3d	; 61
    1ae2:	de b7       	in	r29, 0x3e	; 62
    1ae4:	9c 83       	std	Y+4, r25	; 0x04
    1ae6:	8b 83       	std	Y+3, r24	; 0x03
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	0f 92       	push	r0
    1aee:	8b 81       	ldd	r24, Y+3	; 0x03
    1af0:	9c 81       	ldd	r25, Y+4	; 0x04
    1af2:	89 2b       	or	r24, r25
    1af4:	29 f4       	brne	.+10     	; 0x1b00 <vTaskDelete+0x28>
    1af6:	80 91 38 0c 	lds	r24, 0x0C38
    1afa:	90 91 39 0c 	lds	r25, 0x0C39
    1afe:	02 c0       	rjmp	.+4      	; 0x1b04 <vTaskDelete+0x2c>
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	9c 81       	ldd	r25, Y+4	; 0x04
    1b04:	9a 83       	std	Y+2, r25	; 0x02
    1b06:	89 83       	std	Y+1, r24	; 0x01
    1b08:	89 81       	ldd	r24, Y+1	; 0x01
    1b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0c:	02 96       	adiw	r24, 0x02	; 2
    1b0e:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1b12:	89 81       	ldd	r24, Y+1	; 0x01
    1b14:	9a 81       	ldd	r25, Y+2	; 0x02
    1b16:	fc 01       	movw	r30, r24
    1b18:	84 89       	ldd	r24, Z+20	; 0x14
    1b1a:	95 89       	ldd	r25, Z+21	; 0x15
    1b1c:	89 2b       	or	r24, r25
    1b1e:	29 f0       	breq	.+10     	; 0x1b2a <vTaskDelete+0x52>
    1b20:	89 81       	ldd	r24, Y+1	; 0x01
    1b22:	9a 81       	ldd	r25, Y+2	; 0x02
    1b24:	0c 96       	adiw	r24, 0x0c	; 12
    1b26:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1b2a:	89 81       	ldd	r24, Y+1	; 0x01
    1b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2e:	02 96       	adiw	r24, 0x02	; 2
    1b30:	bc 01       	movw	r22, r24
    1b32:	8d e7       	ldi	r24, 0x7D	; 125
    1b34:	9c e0       	ldi	r25, 0x0C	; 12
    1b36:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    1b3a:	80 91 86 0c 	lds	r24, 0x0C86
    1b3e:	8f 5f       	subi	r24, 0xFF	; 255
    1b40:	80 93 86 0c 	sts	0x0C86, r24
    1b44:	80 91 8f 0c 	lds	r24, 0x0C8F
    1b48:	8f 5f       	subi	r24, 0xFF	; 255
    1b4a:	80 93 8f 0c 	sts	0x0C8F, r24
    1b4e:	0f 90       	pop	r0
    1b50:	0f be       	out	0x3f, r0	; 63
    1b52:	80 91 8b 0c 	lds	r24, 0x0C8B
    1b56:	88 23       	and	r24, r24
    1b58:	91 f0       	breq	.+36     	; 0x1b7e <vTaskDelete+0xa6>
    1b5a:	80 91 38 0c 	lds	r24, 0x0C38
    1b5e:	90 91 39 0c 	lds	r25, 0x0C39
    1b62:	29 81       	ldd	r18, Y+1	; 0x01
    1b64:	3a 81       	ldd	r19, Y+2	; 0x02
    1b66:	28 17       	cp	r18, r24
    1b68:	39 07       	cpc	r19, r25
    1b6a:	19 f4       	brne	.+6      	; 0x1b72 <vTaskDelete+0x9a>
    1b6c:	0e 94 8e 05 	call	0xb1c	; 0xb1c <vPortYield>
    1b70:	06 c0       	rjmp	.+12     	; 0x1b7e <vTaskDelete+0xa6>
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	0f 92       	push	r0
    1b78:	a4 d5       	rcall	.+2888   	; 0x26c2 <prvResetNextTaskUnblockTime>
    1b7a:	0f 90       	pop	r0
    1b7c:	0f be       	out	0x3f, r0	; 63
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	0f 90       	pop	r0
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	08 95       	ret

00001b8c <vTaskDelay>:
    1b8c:	cf 93       	push	r28
    1b8e:	df 93       	push	r29
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <vTaskDelay+0x6>
    1b92:	1f 92       	push	r1
    1b94:	1f 92       	push	r1
    1b96:	cd b7       	in	r28, 0x3d	; 61
    1b98:	de b7       	in	r29, 0x3e	; 62
    1b9a:	9d 83       	std	Y+5, r25	; 0x05
    1b9c:	8c 83       	std	Y+4, r24	; 0x04
    1b9e:	19 82       	std	Y+1, r1	; 0x01
    1ba0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba4:	89 2b       	or	r24, r25
    1ba6:	b9 f0       	breq	.+46     	; 0x1bd6 <vTaskDelay+0x4a>
    1ba8:	5d d0       	rcall	.+186    	; 0x1c64 <vTaskSuspendAll>
    1baa:	20 91 88 0c 	lds	r18, 0x0C88
    1bae:	30 91 89 0c 	lds	r19, 0x0C89
    1bb2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb4:	9d 81       	ldd	r25, Y+5	; 0x05
    1bb6:	82 0f       	add	r24, r18
    1bb8:	93 1f       	adc	r25, r19
    1bba:	9b 83       	std	Y+3, r25	; 0x03
    1bbc:	8a 83       	std	Y+2, r24	; 0x02
    1bbe:	80 91 38 0c 	lds	r24, 0x0C38
    1bc2:	90 91 39 0c 	lds	r25, 0x0C39
    1bc6:	02 96       	adiw	r24, 0x02	; 2
    1bc8:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bce:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd0:	d2 d4       	rcall	.+2468   	; 0x2576 <prvAddCurrentTaskToDelayedList>
    1bd2:	54 d0       	rcall	.+168    	; 0x1c7c <xTaskResumeAll>
    1bd4:	89 83       	std	Y+1, r24	; 0x01
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	88 23       	and	r24, r24
    1bda:	11 f4       	brne	.+4      	; 0x1be0 <vTaskDelay+0x54>
    1bdc:	0e 94 8e 05 	call	0xb1c	; 0xb1c <vPortYield>
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	08 95       	ret

00001bf0 <vTaskStartScheduler>:
    1bf0:	af 92       	push	r10
    1bf2:	bf 92       	push	r11
    1bf4:	cf 92       	push	r12
    1bf6:	df 92       	push	r13
    1bf8:	ef 92       	push	r14
    1bfa:	ff 92       	push	r15
    1bfc:	0f 93       	push	r16
    1bfe:	cf 93       	push	r28
    1c00:	df 93       	push	r29
    1c02:	1f 92       	push	r1
    1c04:	cd b7       	in	r28, 0x3d	; 61
    1c06:	de b7       	in	r29, 0x3e	; 62
    1c08:	a1 2c       	mov	r10, r1
    1c0a:	b1 2c       	mov	r11, r1
    1c0c:	c1 2c       	mov	r12, r1
    1c0e:	d1 2c       	mov	r13, r1
    1c10:	e1 2c       	mov	r14, r1
    1c12:	f1 2c       	mov	r15, r1
    1c14:	00 e0       	ldi	r16, 0x00	; 0
    1c16:	20 e0       	ldi	r18, 0x00	; 0
    1c18:	30 e0       	ldi	r19, 0x00	; 0
    1c1a:	49 eb       	ldi	r20, 0xB9	; 185
    1c1c:	50 e0       	ldi	r21, 0x00	; 0
    1c1e:	62 e0       	ldi	r22, 0x02	; 2
    1c20:	72 e0       	ldi	r23, 0x02	; 2
    1c22:	8c e7       	ldi	r24, 0x7C	; 124
    1c24:	90 e0       	ldi	r25, 0x00	; 0
    1c26:	76 de       	rcall	.-788    	; 0x1914 <xTaskGenericCreate>
    1c28:	89 83       	std	Y+1, r24	; 0x01
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	81 30       	cpi	r24, 0x01	; 1
    1c2e:	11 f4       	brne	.+4      	; 0x1c34 <vTaskStartScheduler+0x44>
    1c30:	90 d5       	rcall	.+2848   	; 0x2752 <xTimerCreateTimerTask>
    1c32:	89 83       	std	Y+1, r24	; 0x01
    1c34:	89 81       	ldd	r24, Y+1	; 0x01
    1c36:	81 30       	cpi	r24, 0x01	; 1
    1c38:	51 f4       	brne	.+20     	; 0x1c4e <vTaskStartScheduler+0x5e>
    1c3a:	f8 94       	cli
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	80 93 8b 0c 	sts	0x0C8B, r24
    1c42:	10 92 89 0c 	sts	0x0C89, r1
    1c46:	10 92 88 0c 	sts	0x0C88, r1
    1c4a:	0e 94 56 05 	call	0xaac	; 0xaac <xPortStartScheduler>
    1c4e:	0f 90       	pop	r0
    1c50:	df 91       	pop	r29
    1c52:	cf 91       	pop	r28
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	cf 90       	pop	r12
    1c5e:	bf 90       	pop	r11
    1c60:	af 90       	pop	r10
    1c62:	08 95       	ret

00001c64 <vTaskSuspendAll>:
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	80 91 90 0c 	lds	r24, 0x0C90
    1c70:	8f 5f       	subi	r24, 0xFF	; 255
    1c72:	80 93 90 0c 	sts	0x0C90, r24
    1c76:	df 91       	pop	r29
    1c78:	cf 91       	pop	r28
    1c7a:	08 95       	ret

00001c7c <xTaskResumeAll>:
    1c7c:	cf 93       	push	r28
    1c7e:	df 93       	push	r29
    1c80:	00 d0       	rcall	.+0      	; 0x1c82 <xTaskResumeAll+0x6>
    1c82:	cd b7       	in	r28, 0x3d	; 61
    1c84:	de b7       	in	r29, 0x3e	; 62
    1c86:	19 82       	std	Y+1, r1	; 0x01
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	0f 92       	push	r0
    1c8e:	80 91 90 0c 	lds	r24, 0x0C90
    1c92:	81 50       	subi	r24, 0x01	; 1
    1c94:	80 93 90 0c 	sts	0x0C90, r24
    1c98:	80 91 90 0c 	lds	r24, 0x0C90
    1c9c:	88 23       	and	r24, r24
    1c9e:	09 f0       	breq	.+2      	; 0x1ca2 <xTaskResumeAll+0x26>
    1ca0:	70 c0       	rjmp	.+224    	; 0x1d82 <xTaskResumeAll+0x106>
    1ca2:	80 91 87 0c 	lds	r24, 0x0C87
    1ca6:	88 23       	and	r24, r24
    1ca8:	09 f4       	brne	.+2      	; 0x1cac <xTaskResumeAll+0x30>
    1caa:	6b c0       	rjmp	.+214    	; 0x1d82 <xTaskResumeAll+0x106>
    1cac:	49 c0       	rjmp	.+146    	; 0x1d40 <xTaskResumeAll+0xc4>
    1cae:	80 91 79 0c 	lds	r24, 0x0C79
    1cb2:	90 91 7a 0c 	lds	r25, 0x0C7A
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	86 81       	ldd	r24, Z+6	; 0x06
    1cba:	97 81       	ldd	r25, Z+7	; 0x07
    1cbc:	9b 83       	std	Y+3, r25	; 0x03
    1cbe:	8a 83       	std	Y+2, r24	; 0x02
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc4:	0c 96       	adiw	r24, 0x0c	; 12
    1cc6:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1cca:	8a 81       	ldd	r24, Y+2	; 0x02
    1ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    1cce:	02 96       	adiw	r24, 0x02	; 2
    1cd0:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1cd4:	8a 81       	ldd	r24, Y+2	; 0x02
    1cd6:	9b 81       	ldd	r25, Y+3	; 0x03
    1cd8:	fc 01       	movw	r30, r24
    1cda:	96 89       	ldd	r25, Z+22	; 0x16
    1cdc:	80 91 8a 0c 	lds	r24, 0x0C8A
    1ce0:	89 17       	cp	r24, r25
    1ce2:	30 f4       	brcc	.+12     	; 0x1cf0 <xTaskResumeAll+0x74>
    1ce4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce8:	fc 01       	movw	r30, r24
    1cea:	86 89       	ldd	r24, Z+22	; 0x16
    1cec:	80 93 8a 0c 	sts	0x0C8A, r24
    1cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cf4:	ac 01       	movw	r20, r24
    1cf6:	4e 5f       	subi	r20, 0xFE	; 254
    1cf8:	5f 4f       	sbci	r21, 0xFF	; 255
    1cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    1cfe:	fc 01       	movw	r30, r24
    1d00:	86 89       	ldd	r24, Z+22	; 0x16
    1d02:	28 2f       	mov	r18, r24
    1d04:	30 e0       	ldi	r19, 0x00	; 0
    1d06:	c9 01       	movw	r24, r18
    1d08:	88 0f       	add	r24, r24
    1d0a:	99 1f       	adc	r25, r25
    1d0c:	88 0f       	add	r24, r24
    1d0e:	99 1f       	adc	r25, r25
    1d10:	88 0f       	add	r24, r24
    1d12:	99 1f       	adc	r25, r25
    1d14:	82 0f       	add	r24, r18
    1d16:	93 1f       	adc	r25, r19
    1d18:	86 5c       	subi	r24, 0xC6	; 198
    1d1a:	93 4f       	sbci	r25, 0xF3	; 243
    1d1c:	ba 01       	movw	r22, r20
    1d1e:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    1d22:	8a 81       	ldd	r24, Y+2	; 0x02
    1d24:	9b 81       	ldd	r25, Y+3	; 0x03
    1d26:	fc 01       	movw	r30, r24
    1d28:	26 89       	ldd	r18, Z+22	; 0x16
    1d2a:	80 91 38 0c 	lds	r24, 0x0C38
    1d2e:	90 91 39 0c 	lds	r25, 0x0C39
    1d32:	fc 01       	movw	r30, r24
    1d34:	86 89       	ldd	r24, Z+22	; 0x16
    1d36:	28 17       	cp	r18, r24
    1d38:	18 f0       	brcs	.+6      	; 0x1d40 <xTaskResumeAll+0xc4>
    1d3a:	81 e0       	ldi	r24, 0x01	; 1
    1d3c:	80 93 8d 0c 	sts	0x0C8D, r24
    1d40:	80 91 74 0c 	lds	r24, 0x0C74
    1d44:	88 23       	and	r24, r24
    1d46:	09 f0       	breq	.+2      	; 0x1d4a <xTaskResumeAll+0xce>
    1d48:	b2 cf       	rjmp	.-156    	; 0x1cae <xTaskResumeAll+0x32>
    1d4a:	80 91 8c 0c 	lds	r24, 0x0C8C
    1d4e:	88 23       	and	r24, r24
    1d50:	81 f0       	breq	.+32     	; 0x1d72 <xTaskResumeAll+0xf6>
    1d52:	0b c0       	rjmp	.+22     	; 0x1d6a <xTaskResumeAll+0xee>
    1d54:	37 d0       	rcall	.+110    	; 0x1dc4 <xTaskIncrementTick>
    1d56:	88 23       	and	r24, r24
    1d58:	19 f0       	breq	.+6      	; 0x1d60 <xTaskResumeAll+0xe4>
    1d5a:	81 e0       	ldi	r24, 0x01	; 1
    1d5c:	80 93 8d 0c 	sts	0x0C8D, r24
    1d60:	80 91 8c 0c 	lds	r24, 0x0C8C
    1d64:	81 50       	subi	r24, 0x01	; 1
    1d66:	80 93 8c 0c 	sts	0x0C8C, r24
    1d6a:	80 91 8c 0c 	lds	r24, 0x0C8C
    1d6e:	88 23       	and	r24, r24
    1d70:	89 f7       	brne	.-30     	; 0x1d54 <xTaskResumeAll+0xd8>
    1d72:	80 91 8d 0c 	lds	r24, 0x0C8D
    1d76:	81 30       	cpi	r24, 0x01	; 1
    1d78:	21 f4       	brne	.+8      	; 0x1d82 <xTaskResumeAll+0x106>
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	89 83       	std	Y+1, r24	; 0x01
    1d7e:	0e 94 8e 05 	call	0xb1c	; 0xb1c <vPortYield>
    1d82:	0f 90       	pop	r0
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	89 81       	ldd	r24, Y+1	; 0x01
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
    1d8e:	df 91       	pop	r29
    1d90:	cf 91       	pop	r28
    1d92:	08 95       	ret

00001d94 <xTaskGetTickCount>:
    1d94:	cf 93       	push	r28
    1d96:	df 93       	push	r29
    1d98:	1f 92       	push	r1
    1d9a:	1f 92       	push	r1
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	0f 92       	push	r0
    1da6:	80 91 88 0c 	lds	r24, 0x0C88
    1daa:	90 91 89 0c 	lds	r25, 0x0C89
    1dae:	9a 83       	std	Y+2, r25	; 0x02
    1db0:	89 83       	std	Y+1, r24	; 0x01
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	89 81       	ldd	r24, Y+1	; 0x01
    1db8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	08 95       	ret

00001dc4 <xTaskIncrementTick>:
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
    1dc8:	cd b7       	in	r28, 0x3d	; 61
    1dca:	de b7       	in	r29, 0x3e	; 62
    1dcc:	29 97       	sbiw	r28, 0x09	; 9
    1dce:	0f b6       	in	r0, 0x3f	; 63
    1dd0:	f8 94       	cli
    1dd2:	de bf       	out	0x3e, r29	; 62
    1dd4:	0f be       	out	0x3f, r0	; 63
    1dd6:	cd bf       	out	0x3d, r28	; 61
    1dd8:	19 82       	std	Y+1, r1	; 0x01
    1dda:	80 91 90 0c 	lds	r24, 0x0C90
    1dde:	88 23       	and	r24, r24
    1de0:	09 f0       	breq	.+2      	; 0x1de4 <xTaskIncrementTick+0x20>
    1de2:	c8 c0       	rjmp	.+400    	; 0x1f74 <xTaskIncrementTick+0x1b0>
    1de4:	80 91 88 0c 	lds	r24, 0x0C88
    1de8:	90 91 89 0c 	lds	r25, 0x0C89
    1dec:	01 96       	adiw	r24, 0x01	; 1
    1dee:	90 93 89 0c 	sts	0x0C89, r25
    1df2:	80 93 88 0c 	sts	0x0C88, r24
    1df6:	80 91 88 0c 	lds	r24, 0x0C88
    1dfa:	90 91 89 0c 	lds	r25, 0x0C89
    1dfe:	9b 83       	std	Y+3, r25	; 0x03
    1e00:	8a 83       	std	Y+2, r24	; 0x02
    1e02:	8a 81       	ldd	r24, Y+2	; 0x02
    1e04:	9b 81       	ldd	r25, Y+3	; 0x03
    1e06:	89 2b       	or	r24, r25
    1e08:	d1 f4       	brne	.+52     	; 0x1e3e <xTaskIncrementTick+0x7a>
    1e0a:	80 91 70 0c 	lds	r24, 0x0C70
    1e0e:	90 91 71 0c 	lds	r25, 0x0C71
    1e12:	9d 83       	std	Y+5, r25	; 0x05
    1e14:	8c 83       	std	Y+4, r24	; 0x04
    1e16:	80 91 72 0c 	lds	r24, 0x0C72
    1e1a:	90 91 73 0c 	lds	r25, 0x0C73
    1e1e:	90 93 71 0c 	sts	0x0C71, r25
    1e22:	80 93 70 0c 	sts	0x0C70, r24
    1e26:	8c 81       	ldd	r24, Y+4	; 0x04
    1e28:	9d 81       	ldd	r25, Y+5	; 0x05
    1e2a:	90 93 73 0c 	sts	0x0C73, r25
    1e2e:	80 93 72 0c 	sts	0x0C72, r24
    1e32:	80 91 8e 0c 	lds	r24, 0x0C8E
    1e36:	8f 5f       	subi	r24, 0xFF	; 255
    1e38:	80 93 8e 0c 	sts	0x0C8E, r24
    1e3c:	42 d4       	rcall	.+2180   	; 0x26c2 <prvResetNextTaskUnblockTime>
    1e3e:	80 91 00 02 	lds	r24, 0x0200
    1e42:	90 91 01 02 	lds	r25, 0x0201
    1e46:	2a 81       	ldd	r18, Y+2	; 0x02
    1e48:	3b 81       	ldd	r19, Y+3	; 0x03
    1e4a:	28 17       	cp	r18, r24
    1e4c:	39 07       	cpc	r19, r25
    1e4e:	08 f4       	brcc	.+2      	; 0x1e52 <xTaskIncrementTick+0x8e>
    1e50:	77 c0       	rjmp	.+238    	; 0x1f40 <xTaskIncrementTick+0x17c>
    1e52:	80 91 70 0c 	lds	r24, 0x0C70
    1e56:	90 91 71 0c 	lds	r25, 0x0C71
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	80 81       	ld	r24, Z
    1e5e:	88 23       	and	r24, r24
    1e60:	39 f4       	brne	.+14     	; 0x1e70 <xTaskIncrementTick+0xac>
    1e62:	8f ef       	ldi	r24, 0xFF	; 255
    1e64:	9f ef       	ldi	r25, 0xFF	; 255
    1e66:	90 93 01 02 	sts	0x0201, r25
    1e6a:	80 93 00 02 	sts	0x0200, r24
    1e6e:	68 c0       	rjmp	.+208    	; 0x1f40 <xTaskIncrementTick+0x17c>
    1e70:	80 91 70 0c 	lds	r24, 0x0C70
    1e74:	90 91 71 0c 	lds	r25, 0x0C71
    1e78:	fc 01       	movw	r30, r24
    1e7a:	85 81       	ldd	r24, Z+5	; 0x05
    1e7c:	96 81       	ldd	r25, Z+6	; 0x06
    1e7e:	fc 01       	movw	r30, r24
    1e80:	86 81       	ldd	r24, Z+6	; 0x06
    1e82:	97 81       	ldd	r25, Z+7	; 0x07
    1e84:	9f 83       	std	Y+7, r25	; 0x07
    1e86:	8e 83       	std	Y+6, r24	; 0x06
    1e88:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1e8c:	fc 01       	movw	r30, r24
    1e8e:	82 81       	ldd	r24, Z+2	; 0x02
    1e90:	93 81       	ldd	r25, Z+3	; 0x03
    1e92:	99 87       	std	Y+9, r25	; 0x09
    1e94:	88 87       	std	Y+8, r24	; 0x08
    1e96:	2a 81       	ldd	r18, Y+2	; 0x02
    1e98:	3b 81       	ldd	r19, Y+3	; 0x03
    1e9a:	88 85       	ldd	r24, Y+8	; 0x08
    1e9c:	99 85       	ldd	r25, Y+9	; 0x09
    1e9e:	28 17       	cp	r18, r24
    1ea0:	39 07       	cpc	r19, r25
    1ea2:	38 f4       	brcc	.+14     	; 0x1eb2 <xTaskIncrementTick+0xee>
    1ea4:	88 85       	ldd	r24, Y+8	; 0x08
    1ea6:	99 85       	ldd	r25, Y+9	; 0x09
    1ea8:	90 93 01 02 	sts	0x0201, r25
    1eac:	80 93 00 02 	sts	0x0200, r24
    1eb0:	47 c0       	rjmp	.+142    	; 0x1f40 <xTaskIncrementTick+0x17c>
    1eb2:	8e 81       	ldd	r24, Y+6	; 0x06
    1eb4:	9f 81       	ldd	r25, Y+7	; 0x07
    1eb6:	02 96       	adiw	r24, 0x02	; 2
    1eb8:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1ebc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ebe:	9f 81       	ldd	r25, Y+7	; 0x07
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	84 89       	ldd	r24, Z+20	; 0x14
    1ec4:	95 89       	ldd	r25, Z+21	; 0x15
    1ec6:	89 2b       	or	r24, r25
    1ec8:	29 f0       	breq	.+10     	; 0x1ed4 <xTaskIncrementTick+0x110>
    1eca:	8e 81       	ldd	r24, Y+6	; 0x06
    1ecc:	9f 81       	ldd	r25, Y+7	; 0x07
    1ece:	0c 96       	adiw	r24, 0x0c	; 12
    1ed0:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    1ed4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ed8:	fc 01       	movw	r30, r24
    1eda:	96 89       	ldd	r25, Z+22	; 0x16
    1edc:	80 91 8a 0c 	lds	r24, 0x0C8A
    1ee0:	89 17       	cp	r24, r25
    1ee2:	30 f4       	brcc	.+12     	; 0x1ef0 <xTaskIncrementTick+0x12c>
    1ee4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ee6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ee8:	fc 01       	movw	r30, r24
    1eea:	86 89       	ldd	r24, Z+22	; 0x16
    1eec:	80 93 8a 0c 	sts	0x0C8A, r24
    1ef0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ef2:	9f 81       	ldd	r25, Y+7	; 0x07
    1ef4:	ac 01       	movw	r20, r24
    1ef6:	4e 5f       	subi	r20, 0xFE	; 254
    1ef8:	5f 4f       	sbci	r21, 0xFF	; 255
    1efa:	8e 81       	ldd	r24, Y+6	; 0x06
    1efc:	9f 81       	ldd	r25, Y+7	; 0x07
    1efe:	fc 01       	movw	r30, r24
    1f00:	86 89       	ldd	r24, Z+22	; 0x16
    1f02:	28 2f       	mov	r18, r24
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	c9 01       	movw	r24, r18
    1f08:	88 0f       	add	r24, r24
    1f0a:	99 1f       	adc	r25, r25
    1f0c:	88 0f       	add	r24, r24
    1f0e:	99 1f       	adc	r25, r25
    1f10:	88 0f       	add	r24, r24
    1f12:	99 1f       	adc	r25, r25
    1f14:	82 0f       	add	r24, r18
    1f16:	93 1f       	adc	r25, r19
    1f18:	86 5c       	subi	r24, 0xC6	; 198
    1f1a:	93 4f       	sbci	r25, 0xF3	; 243
    1f1c:	ba 01       	movw	r22, r20
    1f1e:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    1f22:	8e 81       	ldd	r24, Y+6	; 0x06
    1f24:	9f 81       	ldd	r25, Y+7	; 0x07
    1f26:	fc 01       	movw	r30, r24
    1f28:	26 89       	ldd	r18, Z+22	; 0x16
    1f2a:	80 91 38 0c 	lds	r24, 0x0C38
    1f2e:	90 91 39 0c 	lds	r25, 0x0C39
    1f32:	fc 01       	movw	r30, r24
    1f34:	86 89       	ldd	r24, Z+22	; 0x16
    1f36:	28 17       	cp	r18, r24
    1f38:	10 f0       	brcs	.+4      	; 0x1f3e <xTaskIncrementTick+0x17a>
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	89 83       	std	Y+1, r24	; 0x01
    1f3e:	89 cf       	rjmp	.-238    	; 0x1e52 <xTaskIncrementTick+0x8e>
    1f40:	80 91 38 0c 	lds	r24, 0x0C38
    1f44:	90 91 39 0c 	lds	r25, 0x0C39
    1f48:	fc 01       	movw	r30, r24
    1f4a:	86 89       	ldd	r24, Z+22	; 0x16
    1f4c:	28 2f       	mov	r18, r24
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	c9 01       	movw	r24, r18
    1f52:	88 0f       	add	r24, r24
    1f54:	99 1f       	adc	r25, r25
    1f56:	88 0f       	add	r24, r24
    1f58:	99 1f       	adc	r25, r25
    1f5a:	88 0f       	add	r24, r24
    1f5c:	99 1f       	adc	r25, r25
    1f5e:	82 0f       	add	r24, r18
    1f60:	93 1f       	adc	r25, r19
    1f62:	86 5c       	subi	r24, 0xC6	; 198
    1f64:	93 4f       	sbci	r25, 0xF3	; 243
    1f66:	fc 01       	movw	r30, r24
    1f68:	80 81       	ld	r24, Z
    1f6a:	82 30       	cpi	r24, 0x02	; 2
    1f6c:	40 f0       	brcs	.+16     	; 0x1f7e <xTaskIncrementTick+0x1ba>
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	89 83       	std	Y+1, r24	; 0x01
    1f72:	05 c0       	rjmp	.+10     	; 0x1f7e <xTaskIncrementTick+0x1ba>
    1f74:	80 91 8c 0c 	lds	r24, 0x0C8C
    1f78:	8f 5f       	subi	r24, 0xFF	; 255
    1f7a:	80 93 8c 0c 	sts	0x0C8C, r24
    1f7e:	80 91 8d 0c 	lds	r24, 0x0C8D
    1f82:	88 23       	and	r24, r24
    1f84:	11 f0       	breq	.+4      	; 0x1f8a <xTaskIncrementTick+0x1c6>
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	89 83       	std	Y+1, r24	; 0x01
    1f8a:	89 81       	ldd	r24, Y+1	; 0x01
    1f8c:	29 96       	adiw	r28, 0x09	; 9
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	cd bf       	out	0x3d, r28	; 61
    1f98:	df 91       	pop	r29
    1f9a:	cf 91       	pop	r28
    1f9c:	08 95       	ret

00001f9e <vTaskSwitchContext>:
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
    1fa2:	1f 92       	push	r1
    1fa4:	1f 92       	push	r1
    1fa6:	cd b7       	in	r28, 0x3d	; 61
    1fa8:	de b7       	in	r29, 0x3e	; 62
    1faa:	80 91 90 0c 	lds	r24, 0x0C90
    1fae:	88 23       	and	r24, r24
    1fb0:	21 f0       	breq	.+8      	; 0x1fba <vTaskSwitchContext+0x1c>
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	80 93 8d 0c 	sts	0x0C8D, r24
    1fb8:	7c c0       	rjmp	.+248    	; 0x20b2 <vTaskSwitchContext+0x114>
    1fba:	10 92 8d 0c 	sts	0x0C8D, r1
    1fbe:	80 91 38 0c 	lds	r24, 0x0C38
    1fc2:	90 91 39 0c 	lds	r25, 0x0C39
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	20 81       	ld	r18, Z
    1fca:	31 81       	ldd	r19, Z+1	; 0x01
    1fcc:	80 91 38 0c 	lds	r24, 0x0C38
    1fd0:	90 91 39 0c 	lds	r25, 0x0C39
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	87 89       	ldd	r24, Z+23	; 0x17
    1fd8:	90 8d       	ldd	r25, Z+24	; 0x18
    1fda:	82 17       	cp	r24, r18
    1fdc:	93 07       	cpc	r25, r19
    1fde:	70 f0       	brcs	.+28     	; 0x1ffc <vTaskSwitchContext+0x5e>
    1fe0:	80 91 38 0c 	lds	r24, 0x0C38
    1fe4:	90 91 39 0c 	lds	r25, 0x0C39
    1fe8:	9c 01       	movw	r18, r24
    1fea:	27 5e       	subi	r18, 0xE7	; 231
    1fec:	3f 4f       	sbci	r19, 0xFF	; 255
    1fee:	80 91 38 0c 	lds	r24, 0x0C38
    1ff2:	90 91 39 0c 	lds	r25, 0x0C39
    1ff6:	b9 01       	movw	r22, r18
    1ff8:	0e 94 c8 19 	call	0x3390	; 0x3390 <vApplicationStackOverflowHook>
    1ffc:	05 c0       	rjmp	.+10     	; 0x2008 <vTaskSwitchContext+0x6a>
    1ffe:	80 91 8a 0c 	lds	r24, 0x0C8A
    2002:	81 50       	subi	r24, 0x01	; 1
    2004:	80 93 8a 0c 	sts	0x0C8A, r24
    2008:	80 91 8a 0c 	lds	r24, 0x0C8A
    200c:	28 2f       	mov	r18, r24
    200e:	30 e0       	ldi	r19, 0x00	; 0
    2010:	c9 01       	movw	r24, r18
    2012:	88 0f       	add	r24, r24
    2014:	99 1f       	adc	r25, r25
    2016:	88 0f       	add	r24, r24
    2018:	99 1f       	adc	r25, r25
    201a:	88 0f       	add	r24, r24
    201c:	99 1f       	adc	r25, r25
    201e:	82 0f       	add	r24, r18
    2020:	93 1f       	adc	r25, r19
    2022:	86 5c       	subi	r24, 0xC6	; 198
    2024:	93 4f       	sbci	r25, 0xF3	; 243
    2026:	fc 01       	movw	r30, r24
    2028:	80 81       	ld	r24, Z
    202a:	88 23       	and	r24, r24
    202c:	41 f3       	breq	.-48     	; 0x1ffe <vTaskSwitchContext+0x60>
    202e:	80 91 8a 0c 	lds	r24, 0x0C8A
    2032:	28 2f       	mov	r18, r24
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	c9 01       	movw	r24, r18
    2038:	88 0f       	add	r24, r24
    203a:	99 1f       	adc	r25, r25
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	88 0f       	add	r24, r24
    2042:	99 1f       	adc	r25, r25
    2044:	82 0f       	add	r24, r18
    2046:	93 1f       	adc	r25, r19
    2048:	86 5c       	subi	r24, 0xC6	; 198
    204a:	93 4f       	sbci	r25, 0xF3	; 243
    204c:	9a 83       	std	Y+2, r25	; 0x02
    204e:	89 83       	std	Y+1, r24	; 0x01
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	9a 81       	ldd	r25, Y+2	; 0x02
    2054:	fc 01       	movw	r30, r24
    2056:	81 81       	ldd	r24, Z+1	; 0x01
    2058:	92 81       	ldd	r25, Z+2	; 0x02
    205a:	fc 01       	movw	r30, r24
    205c:	22 81       	ldd	r18, Z+2	; 0x02
    205e:	33 81       	ldd	r19, Z+3	; 0x03
    2060:	89 81       	ldd	r24, Y+1	; 0x01
    2062:	9a 81       	ldd	r25, Y+2	; 0x02
    2064:	fc 01       	movw	r30, r24
    2066:	32 83       	std	Z+2, r19	; 0x02
    2068:	21 83       	std	Z+1, r18	; 0x01
    206a:	89 81       	ldd	r24, Y+1	; 0x01
    206c:	9a 81       	ldd	r25, Y+2	; 0x02
    206e:	fc 01       	movw	r30, r24
    2070:	21 81       	ldd	r18, Z+1	; 0x01
    2072:	32 81       	ldd	r19, Z+2	; 0x02
    2074:	89 81       	ldd	r24, Y+1	; 0x01
    2076:	9a 81       	ldd	r25, Y+2	; 0x02
    2078:	03 96       	adiw	r24, 0x03	; 3
    207a:	28 17       	cp	r18, r24
    207c:	39 07       	cpc	r19, r25
    207e:	69 f4       	brne	.+26     	; 0x209a <vTaskSwitchContext+0xfc>
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	9a 81       	ldd	r25, Y+2	; 0x02
    2084:	fc 01       	movw	r30, r24
    2086:	81 81       	ldd	r24, Z+1	; 0x01
    2088:	92 81       	ldd	r25, Z+2	; 0x02
    208a:	fc 01       	movw	r30, r24
    208c:	22 81       	ldd	r18, Z+2	; 0x02
    208e:	33 81       	ldd	r19, Z+3	; 0x03
    2090:	89 81       	ldd	r24, Y+1	; 0x01
    2092:	9a 81       	ldd	r25, Y+2	; 0x02
    2094:	fc 01       	movw	r30, r24
    2096:	32 83       	std	Z+2, r19	; 0x02
    2098:	21 83       	std	Z+1, r18	; 0x01
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	9a 81       	ldd	r25, Y+2	; 0x02
    209e:	fc 01       	movw	r30, r24
    20a0:	81 81       	ldd	r24, Z+1	; 0x01
    20a2:	92 81       	ldd	r25, Z+2	; 0x02
    20a4:	fc 01       	movw	r30, r24
    20a6:	86 81       	ldd	r24, Z+6	; 0x06
    20a8:	97 81       	ldd	r25, Z+7	; 0x07
    20aa:	90 93 39 0c 	sts	0x0C39, r25
    20ae:	80 93 38 0c 	sts	0x0C38, r24
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	08 95       	ret

000020bc <vTaskPlaceOnEventList>:
    20bc:	cf 93       	push	r28
    20be:	df 93       	push	r29
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <vTaskPlaceOnEventList+0x6>
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <vTaskPlaceOnEventList+0x8>
    20c4:	cd b7       	in	r28, 0x3d	; 61
    20c6:	de b7       	in	r29, 0x3e	; 62
    20c8:	9c 83       	std	Y+4, r25	; 0x04
    20ca:	8b 83       	std	Y+3, r24	; 0x03
    20cc:	7e 83       	std	Y+6, r23	; 0x06
    20ce:	6d 83       	std	Y+5, r22	; 0x05
    20d0:	80 91 38 0c 	lds	r24, 0x0C38
    20d4:	90 91 39 0c 	lds	r25, 0x0C39
    20d8:	9c 01       	movw	r18, r24
    20da:	24 5f       	subi	r18, 0xF4	; 244
    20dc:	3f 4f       	sbci	r19, 0xFF	; 255
    20de:	8b 81       	ldd	r24, Y+3	; 0x03
    20e0:	9c 81       	ldd	r25, Y+4	; 0x04
    20e2:	b9 01       	movw	r22, r18
    20e4:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>
    20e8:	80 91 38 0c 	lds	r24, 0x0C38
    20ec:	90 91 39 0c 	lds	r25, 0x0C39
    20f0:	02 96       	adiw	r24, 0x02	; 2
    20f2:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    20f6:	20 91 88 0c 	lds	r18, 0x0C88
    20fa:	30 91 89 0c 	lds	r19, 0x0C89
    20fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2100:	9e 81       	ldd	r25, Y+6	; 0x06
    2102:	82 0f       	add	r24, r18
    2104:	93 1f       	adc	r25, r19
    2106:	9a 83       	std	Y+2, r25	; 0x02
    2108:	89 83       	std	Y+1, r24	; 0x01
    210a:	89 81       	ldd	r24, Y+1	; 0x01
    210c:	9a 81       	ldd	r25, Y+2	; 0x02
    210e:	33 d2       	rcall	.+1126   	; 0x2576 <prvAddCurrentTaskToDelayedList>
    2110:	26 96       	adiw	r28, 0x06	; 6
    2112:	0f b6       	in	r0, 0x3f	; 63
    2114:	f8 94       	cli
    2116:	de bf       	out	0x3e, r29	; 62
    2118:	0f be       	out	0x3f, r0	; 63
    211a:	cd bf       	out	0x3d, r28	; 61
    211c:	df 91       	pop	r29
    211e:	cf 91       	pop	r28
    2120:	08 95       	ret

00002122 <vTaskPlaceOnEventListRestricted>:
    2122:	cf 93       	push	r28
    2124:	df 93       	push	r29
    2126:	00 d0       	rcall	.+0      	; 0x2128 <vTaskPlaceOnEventListRestricted+0x6>
    2128:	00 d0       	rcall	.+0      	; 0x212a <vTaskPlaceOnEventListRestricted+0x8>
    212a:	cd b7       	in	r28, 0x3d	; 61
    212c:	de b7       	in	r29, 0x3e	; 62
    212e:	9c 83       	std	Y+4, r25	; 0x04
    2130:	8b 83       	std	Y+3, r24	; 0x03
    2132:	7e 83       	std	Y+6, r23	; 0x06
    2134:	6d 83       	std	Y+5, r22	; 0x05
    2136:	80 91 38 0c 	lds	r24, 0x0C38
    213a:	90 91 39 0c 	lds	r25, 0x0C39
    213e:	9c 01       	movw	r18, r24
    2140:	24 5f       	subi	r18, 0xF4	; 244
    2142:	3f 4f       	sbci	r19, 0xFF	; 255
    2144:	8b 81       	ldd	r24, Y+3	; 0x03
    2146:	9c 81       	ldd	r25, Y+4	; 0x04
    2148:	b9 01       	movw	r22, r18
    214a:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    214e:	80 91 38 0c 	lds	r24, 0x0C38
    2152:	90 91 39 0c 	lds	r25, 0x0C39
    2156:	02 96       	adiw	r24, 0x02	; 2
    2158:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    215c:	20 91 88 0c 	lds	r18, 0x0C88
    2160:	30 91 89 0c 	lds	r19, 0x0C89
    2164:	8d 81       	ldd	r24, Y+5	; 0x05
    2166:	9e 81       	ldd	r25, Y+6	; 0x06
    2168:	82 0f       	add	r24, r18
    216a:	93 1f       	adc	r25, r19
    216c:	9a 83       	std	Y+2, r25	; 0x02
    216e:	89 83       	std	Y+1, r24	; 0x01
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	9a 81       	ldd	r25, Y+2	; 0x02
    2174:	00 d2       	rcall	.+1024   	; 0x2576 <prvAddCurrentTaskToDelayedList>
    2176:	26 96       	adiw	r28, 0x06	; 6
    2178:	0f b6       	in	r0, 0x3f	; 63
    217a:	f8 94       	cli
    217c:	de bf       	out	0x3e, r29	; 62
    217e:	0f be       	out	0x3f, r0	; 63
    2180:	cd bf       	out	0x3d, r28	; 61
    2182:	df 91       	pop	r29
    2184:	cf 91       	pop	r28
    2186:	08 95       	ret

00002188 <xTaskRemoveFromEventList>:
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
    218c:	00 d0       	rcall	.+0      	; 0x218e <xTaskRemoveFromEventList+0x6>
    218e:	1f 92       	push	r1
    2190:	1f 92       	push	r1
    2192:	cd b7       	in	r28, 0x3d	; 61
    2194:	de b7       	in	r29, 0x3e	; 62
    2196:	9d 83       	std	Y+5, r25	; 0x05
    2198:	8c 83       	std	Y+4, r24	; 0x04
    219a:	8c 81       	ldd	r24, Y+4	; 0x04
    219c:	9d 81       	ldd	r25, Y+5	; 0x05
    219e:	fc 01       	movw	r30, r24
    21a0:	85 81       	ldd	r24, Z+5	; 0x05
    21a2:	96 81       	ldd	r25, Z+6	; 0x06
    21a4:	fc 01       	movw	r30, r24
    21a6:	86 81       	ldd	r24, Z+6	; 0x06
    21a8:	97 81       	ldd	r25, Z+7	; 0x07
    21aa:	9b 83       	std	Y+3, r25	; 0x03
    21ac:	8a 83       	std	Y+2, r24	; 0x02
    21ae:	8a 81       	ldd	r24, Y+2	; 0x02
    21b0:	9b 81       	ldd	r25, Y+3	; 0x03
    21b2:	0c 96       	adiw	r24, 0x0c	; 12
    21b4:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    21b8:	80 91 90 0c 	lds	r24, 0x0C90
    21bc:	88 23       	and	r24, r24
    21be:	69 f5       	brne	.+90     	; 0x221a <__stack+0x1b>
    21c0:	8a 81       	ldd	r24, Y+2	; 0x02
    21c2:	9b 81       	ldd	r25, Y+3	; 0x03
    21c4:	02 96       	adiw	r24, 0x02	; 2
    21c6:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
    21ca:	8a 81       	ldd	r24, Y+2	; 0x02
    21cc:	9b 81       	ldd	r25, Y+3	; 0x03
    21ce:	fc 01       	movw	r30, r24
    21d0:	96 89       	ldd	r25, Z+22	; 0x16
    21d2:	80 91 8a 0c 	lds	r24, 0x0C8A
    21d6:	89 17       	cp	r24, r25
    21d8:	30 f4       	brcc	.+12     	; 0x21e6 <xTaskRemoveFromEventList+0x5e>
    21da:	8a 81       	ldd	r24, Y+2	; 0x02
    21dc:	9b 81       	ldd	r25, Y+3	; 0x03
    21de:	fc 01       	movw	r30, r24
    21e0:	86 89       	ldd	r24, Z+22	; 0x16
    21e2:	80 93 8a 0c 	sts	0x0C8A, r24
    21e6:	8a 81       	ldd	r24, Y+2	; 0x02
    21e8:	9b 81       	ldd	r25, Y+3	; 0x03
    21ea:	ac 01       	movw	r20, r24
    21ec:	4e 5f       	subi	r20, 0xFE	; 254
    21ee:	5f 4f       	sbci	r21, 0xFF	; 255
    21f0:	8a 81       	ldd	r24, Y+2	; 0x02
    21f2:	9b 81       	ldd	r25, Y+3	; 0x03
    21f4:	fc 01       	movw	r30, r24
    21f6:	86 89       	ldd	r24, Z+22	; 0x16
    21f8:	28 2f       	mov	r18, r24
    21fa:	30 e0       	ldi	r19, 0x00	; 0
    21fc:	c9 01       	movw	r24, r18
    21fe:	88 0f       	add	r24, r24
    2200:	99 1f       	adc	r25, r25
    2202:	88 0f       	add	r24, r24
    2204:	99 1f       	adc	r25, r25
    2206:	88 0f       	add	r24, r24
    2208:	99 1f       	adc	r25, r25
    220a:	82 0f       	add	r24, r18
    220c:	93 1f       	adc	r25, r19
    220e:	86 5c       	subi	r24, 0xC6	; 198
    2210:	93 4f       	sbci	r25, 0xF3	; 243
    2212:	ba 01       	movw	r22, r20
    2214:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    2218:	08 c0       	rjmp	.+16     	; 0x222a <__stack+0x2b>
    221a:	8a 81       	ldd	r24, Y+2	; 0x02
    221c:	9b 81       	ldd	r25, Y+3	; 0x03
    221e:	0c 96       	adiw	r24, 0x0c	; 12
    2220:	bc 01       	movw	r22, r24
    2222:	84 e7       	ldi	r24, 0x74	; 116
    2224:	9c e0       	ldi	r25, 0x0C	; 12
    2226:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <vListInsertEnd>
    222a:	8a 81       	ldd	r24, Y+2	; 0x02
    222c:	9b 81       	ldd	r25, Y+3	; 0x03
    222e:	fc 01       	movw	r30, r24
    2230:	26 89       	ldd	r18, Z+22	; 0x16
    2232:	80 91 38 0c 	lds	r24, 0x0C38
    2236:	90 91 39 0c 	lds	r25, 0x0C39
    223a:	fc 01       	movw	r30, r24
    223c:	86 89       	ldd	r24, Z+22	; 0x16
    223e:	82 17       	cp	r24, r18
    2240:	30 f4       	brcc	.+12     	; 0x224e <__stack+0x4f>
    2242:	81 e0       	ldi	r24, 0x01	; 1
    2244:	89 83       	std	Y+1, r24	; 0x01
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	80 93 8d 0c 	sts	0x0C8D, r24
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <__stack+0x51>
    224e:	19 82       	std	Y+1, r1	; 0x01
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	0f 90       	pop	r0
    2254:	0f 90       	pop	r0
    2256:	0f 90       	pop	r0
    2258:	0f 90       	pop	r0
    225a:	0f 90       	pop	r0
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	08 95       	ret

00002262 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
    2266:	1f 92       	push	r1
    2268:	1f 92       	push	r1
    226a:	cd b7       	in	r28, 0x3d	; 61
    226c:	de b7       	in	r29, 0x3e	; 62
    226e:	9a 83       	std	Y+2, r25	; 0x02
    2270:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2272:	20 91 8e 0c 	lds	r18, 0x0C8E
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	9a 81       	ldd	r25, Y+2	; 0x02
    227a:	fc 01       	movw	r30, r24
    227c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    227e:	20 91 88 0c 	lds	r18, 0x0C88
    2282:	30 91 89 0c 	lds	r19, 0x0C89
    2286:	89 81       	ldd	r24, Y+1	; 0x01
    2288:	9a 81       	ldd	r25, Y+2	; 0x02
    228a:	fc 01       	movw	r30, r24
    228c:	32 83       	std	Z+2, r19	; 0x02
    228e:	21 83       	std	Z+1, r18	; 0x01
}
    2290:	0f 90       	pop	r0
    2292:	0f 90       	pop	r0
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	08 95       	ret

0000229a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    229a:	cf 93       	push	r28
    229c:	df 93       	push	r29
    229e:	cd b7       	in	r28, 0x3d	; 61
    22a0:	de b7       	in	r29, 0x3e	; 62
    22a2:	27 97       	sbiw	r28, 0x07	; 7
    22a4:	0f b6       	in	r0, 0x3f	; 63
    22a6:	f8 94       	cli
    22a8:	de bf       	out	0x3e, r29	; 62
    22aa:	0f be       	out	0x3f, r0	; 63
    22ac:	cd bf       	out	0x3d, r28	; 61
    22ae:	9d 83       	std	Y+5, r25	; 0x05
    22b0:	8c 83       	std	Y+4, r24	; 0x04
    22b2:	7f 83       	std	Y+7, r23	; 0x07
    22b4:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    22b6:	0f b6       	in	r0, 0x3f	; 63
    22b8:	f8 94       	cli
    22ba:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    22bc:	80 91 88 0c 	lds	r24, 0x0C88
    22c0:	90 91 89 0c 	lds	r25, 0x0C89
    22c4:	9b 83       	std	Y+3, r25	; 0x03
    22c6:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    22c8:	8c 81       	ldd	r24, Y+4	; 0x04
    22ca:	9d 81       	ldd	r25, Y+5	; 0x05
    22cc:	fc 01       	movw	r30, r24
    22ce:	90 81       	ld	r25, Z
    22d0:	80 91 8e 0c 	lds	r24, 0x0C8E
    22d4:	98 17       	cp	r25, r24
    22d6:	69 f0       	breq	.+26     	; 0x22f2 <xTaskCheckForTimeOut+0x58>
    22d8:	8c 81       	ldd	r24, Y+4	; 0x04
    22da:	9d 81       	ldd	r25, Y+5	; 0x05
    22dc:	fc 01       	movw	r30, r24
    22de:	21 81       	ldd	r18, Z+1	; 0x01
    22e0:	32 81       	ldd	r19, Z+2	; 0x02
    22e2:	8a 81       	ldd	r24, Y+2	; 0x02
    22e4:	9b 81       	ldd	r25, Y+3	; 0x03
    22e6:	82 17       	cp	r24, r18
    22e8:	93 07       	cpc	r25, r19
    22ea:	18 f0       	brcs	.+6      	; 0x22f2 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	89 83       	std	Y+1, r24	; 0x01
    22f0:	2f c0       	rjmp	.+94     	; 0x2350 <xTaskCheckForTimeOut+0xb6>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    22f2:	8c 81       	ldd	r24, Y+4	; 0x04
    22f4:	9d 81       	ldd	r25, Y+5	; 0x05
    22f6:	fc 01       	movw	r30, r24
    22f8:	81 81       	ldd	r24, Z+1	; 0x01
    22fa:	92 81       	ldd	r25, Z+2	; 0x02
    22fc:	2a 81       	ldd	r18, Y+2	; 0x02
    22fe:	3b 81       	ldd	r19, Y+3	; 0x03
    2300:	28 1b       	sub	r18, r24
    2302:	39 0b       	sbc	r19, r25
    2304:	8e 81       	ldd	r24, Y+6	; 0x06
    2306:	9f 81       	ldd	r25, Y+7	; 0x07
    2308:	fc 01       	movw	r30, r24
    230a:	80 81       	ld	r24, Z
    230c:	91 81       	ldd	r25, Z+1	; 0x01
    230e:	28 17       	cp	r18, r24
    2310:	39 07       	cpc	r19, r25
    2312:	e0 f4       	brcc	.+56     	; 0x234c <xTaskCheckForTimeOut+0xb2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2314:	8e 81       	ldd	r24, Y+6	; 0x06
    2316:	9f 81       	ldd	r25, Y+7	; 0x07
    2318:	fc 01       	movw	r30, r24
    231a:	20 81       	ld	r18, Z
    231c:	31 81       	ldd	r19, Z+1	; 0x01
    231e:	8c 81       	ldd	r24, Y+4	; 0x04
    2320:	9d 81       	ldd	r25, Y+5	; 0x05
    2322:	fc 01       	movw	r30, r24
    2324:	41 81       	ldd	r20, Z+1	; 0x01
    2326:	52 81       	ldd	r21, Z+2	; 0x02
    2328:	8a 81       	ldd	r24, Y+2	; 0x02
    232a:	9b 81       	ldd	r25, Y+3	; 0x03
    232c:	ba 01       	movw	r22, r20
    232e:	68 1b       	sub	r22, r24
    2330:	79 0b       	sbc	r23, r25
    2332:	cb 01       	movw	r24, r22
    2334:	28 0f       	add	r18, r24
    2336:	39 1f       	adc	r19, r25
    2338:	8e 81       	ldd	r24, Y+6	; 0x06
    233a:	9f 81       	ldd	r25, Y+7	; 0x07
    233c:	fc 01       	movw	r30, r24
    233e:	31 83       	std	Z+1, r19	; 0x01
    2340:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    2342:	8c 81       	ldd	r24, Y+4	; 0x04
    2344:	9d 81       	ldd	r25, Y+5	; 0x05
    2346:	8d df       	rcall	.-230    	; 0x2262 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2348:	19 82       	std	Y+1, r1	; 0x01
    234a:	02 c0       	rjmp	.+4      	; 0x2350 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2350:	0f 90       	pop	r0
    2352:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2354:	89 81       	ldd	r24, Y+1	; 0x01
}
    2356:	27 96       	adiw	r28, 0x07	; 7
    2358:	0f b6       	in	r0, 0x3f	; 63
    235a:	f8 94       	cli
    235c:	de bf       	out	0x3e, r29	; 62
    235e:	0f be       	out	0x3f, r0	; 63
    2360:	cd bf       	out	0x3d, r28	; 61
    2362:	df 91       	pop	r29
    2364:	cf 91       	pop	r28
    2366:	08 95       	ret

00002368 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2368:	cf 93       	push	r28
    236a:	df 93       	push	r29
    236c:	cd b7       	in	r28, 0x3d	; 61
    236e:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	80 93 8d 0c 	sts	0x0C8D, r24
}
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	08 95       	ret

0000237c <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    237c:	0f 93       	push	r16
    237e:	1f 93       	push	r17
    2380:	cf 93       	push	r28
    2382:	df 93       	push	r29
    2384:	cd b7       	in	r28, 0x3d	; 61
    2386:	de b7       	in	r29, 0x3e	; 62
    2388:	2a 97       	sbiw	r28, 0x0a	; 10
    238a:	0f b6       	in	r0, 0x3f	; 63
    238c:	f8 94       	cli
    238e:	de bf       	out	0x3e, r29	; 62
    2390:	0f be       	out	0x3f, r0	; 63
    2392:	cd bf       	out	0x3d, r28	; 61
    2394:	9b 83       	std	Y+3, r25	; 0x03
    2396:	8a 83       	std	Y+2, r24	; 0x02
    2398:	7d 83       	std	Y+5, r23	; 0x05
    239a:	6c 83       	std	Y+4, r22	; 0x04
    239c:	4e 83       	std	Y+6, r20	; 0x06
    239e:	38 87       	std	Y+8, r19	; 0x08
    23a0:	2f 83       	std	Y+7, r18	; 0x07
    23a2:	1a 87       	std	Y+10, r17	; 0x0a
    23a4:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    23a6:	19 82       	std	Y+1, r1	; 0x01
    23a8:	22 c0       	rjmp	.+68     	; 0x23ee <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	88 2f       	mov	r24, r24
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	29 81       	ldd	r18, Y+1	; 0x01
    23b2:	22 2f       	mov	r18, r18
    23b4:	30 e0       	ldi	r19, 0x00	; 0
    23b6:	4c 81       	ldd	r20, Y+4	; 0x04
    23b8:	5d 81       	ldd	r21, Y+5	; 0x05
    23ba:	24 0f       	add	r18, r20
    23bc:	35 1f       	adc	r19, r21
    23be:	f9 01       	movw	r30, r18
    23c0:	40 81       	ld	r20, Z
    23c2:	2a 81       	ldd	r18, Y+2	; 0x02
    23c4:	3b 81       	ldd	r19, Y+3	; 0x03
    23c6:	82 0f       	add	r24, r18
    23c8:	93 1f       	adc	r25, r19
    23ca:	49 96       	adiw	r24, 0x19	; 25
    23cc:	fc 01       	movw	r30, r24
    23ce:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    23d0:	89 81       	ldd	r24, Y+1	; 0x01
    23d2:	88 2f       	mov	r24, r24
    23d4:	90 e0       	ldi	r25, 0x00	; 0
    23d6:	2c 81       	ldd	r18, Y+4	; 0x04
    23d8:	3d 81       	ldd	r19, Y+5	; 0x05
    23da:	82 0f       	add	r24, r18
    23dc:	93 1f       	adc	r25, r19
    23de:	fc 01       	movw	r30, r24
    23e0:	80 81       	ld	r24, Z
    23e2:	88 23       	and	r24, r24
    23e4:	09 f4       	brne	.+2      	; 0x23e8 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    23e6:	06 c0       	rjmp	.+12     	; 0x23f4 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    23e8:	89 81       	ldd	r24, Y+1	; 0x01
    23ea:	8f 5f       	subi	r24, 0xFF	; 255
    23ec:	89 83       	std	Y+1, r24	; 0x01
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	88 30       	cpi	r24, 0x08	; 8
    23f2:	d8 f2       	brcs	.-74     	; 0x23aa <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    23f4:	8a 81       	ldd	r24, Y+2	; 0x02
    23f6:	9b 81       	ldd	r25, Y+3	; 0x03
    23f8:	fc 01       	movw	r30, r24
    23fa:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    23fc:	8e 81       	ldd	r24, Y+6	; 0x06
    23fe:	84 30       	cpi	r24, 0x04	; 4
    2400:	10 f0       	brcs	.+4      	; 0x2406 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2402:	83 e0       	ldi	r24, 0x03	; 3
    2404:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    2406:	8a 81       	ldd	r24, Y+2	; 0x02
    2408:	9b 81       	ldd	r25, Y+3	; 0x03
    240a:	2e 81       	ldd	r18, Y+6	; 0x06
    240c:	fc 01       	movw	r30, r24
    240e:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2410:	8a 81       	ldd	r24, Y+2	; 0x02
    2412:	9b 81       	ldd	r25, Y+3	; 0x03
    2414:	02 96       	adiw	r24, 0x02	; 2
    2416:	0e 94 e7 00 	call	0x1ce	; 0x1ce <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    241a:	8a 81       	ldd	r24, Y+2	; 0x02
    241c:	9b 81       	ldd	r25, Y+3	; 0x03
    241e:	0c 96       	adiw	r24, 0x0c	; 12
    2420:	0e 94 e7 00 	call	0x1ce	; 0x1ce <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	9b 81       	ldd	r25, Y+3	; 0x03
    2428:	2a 81       	ldd	r18, Y+2	; 0x02
    242a:	3b 81       	ldd	r19, Y+3	; 0x03
    242c:	fc 01       	movw	r30, r24
    242e:	31 87       	std	Z+9, r19	; 0x09
    2430:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2432:	8e 81       	ldd	r24, Y+6	; 0x06
    2434:	88 2f       	mov	r24, r24
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	24 e0       	ldi	r18, 0x04	; 4
    243a:	30 e0       	ldi	r19, 0x00	; 0
    243c:	28 1b       	sub	r18, r24
    243e:	39 0b       	sbc	r19, r25
    2440:	8a 81       	ldd	r24, Y+2	; 0x02
    2442:	9b 81       	ldd	r25, Y+3	; 0x03
    2444:	fc 01       	movw	r30, r24
    2446:	35 87       	std	Z+13, r19	; 0x0d
    2448:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    244a:	8a 81       	ldd	r24, Y+2	; 0x02
    244c:	9b 81       	ldd	r25, Y+3	; 0x03
    244e:	2a 81       	ldd	r18, Y+2	; 0x02
    2450:	3b 81       	ldd	r19, Y+3	; 0x03
    2452:	fc 01       	movw	r30, r24
    2454:	33 8b       	std	Z+19, r19	; 0x13
    2456:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    2458:	8a 81       	ldd	r24, Y+2	; 0x02
    245a:	9b 81       	ldd	r25, Y+3	; 0x03
    245c:	fc 01       	movw	r30, r24
    245e:	11 a2       	std	Z+33, r1	; 0x21
    2460:	12 a2       	std	Z+34, r1	; 0x22
    2462:	13 a2       	std	Z+35, r1	; 0x23
    2464:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	fc 01       	movw	r30, r24
    246c:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    246e:	2a 96       	adiw	r28, 0x0a	; 10
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	de bf       	out	0x3e, r29	; 62
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	cd bf       	out	0x3d, r28	; 61
    247a:	df 91       	pop	r29
    247c:	cf 91       	pop	r28
    247e:	1f 91       	pop	r17
    2480:	0f 91       	pop	r16
    2482:	08 95       	ret

00002484 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2484:	cf 93       	push	r28
    2486:	df 93       	push	r29
    2488:	1f 92       	push	r1
    248a:	cd b7       	in	r28, 0x3d	; 61
    248c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    248e:	19 82       	std	Y+1, r1	; 0x01
    2490:	13 c0       	rjmp	.+38     	; 0x24b8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2492:	89 81       	ldd	r24, Y+1	; 0x01
    2494:	28 2f       	mov	r18, r24
    2496:	30 e0       	ldi	r19, 0x00	; 0
    2498:	c9 01       	movw	r24, r18
    249a:	88 0f       	add	r24, r24
    249c:	99 1f       	adc	r25, r25
    249e:	88 0f       	add	r24, r24
    24a0:	99 1f       	adc	r25, r25
    24a2:	88 0f       	add	r24, r24
    24a4:	99 1f       	adc	r25, r25
    24a6:	82 0f       	add	r24, r18
    24a8:	93 1f       	adc	r25, r19
    24aa:	86 5c       	subi	r24, 0xC6	; 198
    24ac:	93 4f       	sbci	r25, 0xF3	; 243
    24ae:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    24b2:	89 81       	ldd	r24, Y+1	; 0x01
    24b4:	8f 5f       	subi	r24, 0xFF	; 255
    24b6:	89 83       	std	Y+1, r24	; 0x01
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	84 30       	cpi	r24, 0x04	; 4
    24bc:	50 f3       	brcs	.-44     	; 0x2492 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    24be:	8e e5       	ldi	r24, 0x5E	; 94
    24c0:	9c e0       	ldi	r25, 0x0C	; 12
    24c2:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    24c6:	87 e6       	ldi	r24, 0x67	; 103
    24c8:	9c e0       	ldi	r25, 0x0C	; 12
    24ca:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    24ce:	84 e7       	ldi	r24, 0x74	; 116
    24d0:	9c e0       	ldi	r25, 0x0C	; 12
    24d2:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    24d6:	8d e7       	ldi	r24, 0x7D	; 125
    24d8:	9c e0       	ldi	r25, 0x0C	; 12
    24da:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    24de:	8e e5       	ldi	r24, 0x5E	; 94
    24e0:	9c e0       	ldi	r25, 0x0C	; 12
    24e2:	90 93 71 0c 	sts	0x0C71, r25
    24e6:	80 93 70 0c 	sts	0x0C70, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    24ea:	87 e6       	ldi	r24, 0x67	; 103
    24ec:	9c e0       	ldi	r25, 0x0C	; 12
    24ee:	90 93 73 0c 	sts	0x0C73, r25
    24f2:	80 93 72 0c 	sts	0x0C72, r24
}
    24f6:	0f 90       	pop	r0
    24f8:	df 91       	pop	r29
    24fa:	cf 91       	pop	r28
    24fc:	08 95       	ret

000024fe <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    24fe:	cf 93       	push	r28
    2500:	df 93       	push	r29
    2502:	00 d0       	rcall	.+0      	; 0x2504 <prvCheckTasksWaitingTermination+0x6>
    2504:	cd b7       	in	r28, 0x3d	; 61
    2506:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2508:	2c c0       	rjmp	.+88     	; 0x2562 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
    250a:	ac db       	rcall	.-2216   	; 0x1c64 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    250c:	90 91 7d 0c 	lds	r25, 0x0C7D
    2510:	81 e0       	ldi	r24, 0x01	; 1
    2512:	99 23       	and	r25, r25
    2514:	09 f0       	breq	.+2      	; 0x2518 <prvCheckTasksWaitingTermination+0x1a>
    2516:	80 e0       	ldi	r24, 0x00	; 0
    2518:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    251a:	b0 db       	rcall	.-2208   	; 0x1c7c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    251c:	89 81       	ldd	r24, Y+1	; 0x01
    251e:	88 23       	and	r24, r24
    2520:	01 f5       	brne	.+64     	; 0x2562 <prvCheckTasksWaitingTermination+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2528:	80 91 82 0c 	lds	r24, 0x0C82
    252c:	90 91 83 0c 	lds	r25, 0x0C83
    2530:	fc 01       	movw	r30, r24
    2532:	86 81       	ldd	r24, Z+6	; 0x06
    2534:	97 81       	ldd	r25, Z+7	; 0x07
    2536:	9b 83       	std	Y+3, r25	; 0x03
    2538:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    253a:	8a 81       	ldd	r24, Y+2	; 0x02
    253c:	9b 81       	ldd	r25, Y+3	; 0x03
    253e:	02 96       	adiw	r24, 0x02	; 2
    2540:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
					--uxCurrentNumberOfTasks;
    2544:	80 91 87 0c 	lds	r24, 0x0C87
    2548:	81 50       	subi	r24, 0x01	; 1
    254a:	80 93 87 0c 	sts	0x0C87, r24
					--uxTasksDeleted;
    254e:	80 91 86 0c 	lds	r24, 0x0C86
    2552:	81 50       	subi	r24, 0x01	; 1
    2554:	80 93 86 0c 	sts	0x0C86, r24
				}
				taskEXIT_CRITICAL();
    2558:	0f 90       	pop	r0
    255a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    255c:	8a 81       	ldd	r24, Y+2	; 0x02
    255e:	9b 81       	ldd	r25, Y+3	; 0x03
    2560:	98 d0       	rcall	.+304    	; 0x2692 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2562:	80 91 86 0c 	lds	r24, 0x0C86
    2566:	88 23       	and	r24, r24
    2568:	81 f6       	brne	.-96     	; 0x250a <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    256a:	0f 90       	pop	r0
    256c:	0f 90       	pop	r0
    256e:	0f 90       	pop	r0
    2570:	df 91       	pop	r29
    2572:	cf 91       	pop	r28
    2574:	08 95       	ret

00002576 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2576:	cf 93       	push	r28
    2578:	df 93       	push	r29
    257a:	1f 92       	push	r1
    257c:	1f 92       	push	r1
    257e:	cd b7       	in	r28, 0x3d	; 61
    2580:	de b7       	in	r29, 0x3e	; 62
    2582:	9a 83       	std	Y+2, r25	; 0x02
    2584:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2586:	80 91 38 0c 	lds	r24, 0x0C38
    258a:	90 91 39 0c 	lds	r25, 0x0C39
    258e:	29 81       	ldd	r18, Y+1	; 0x01
    2590:	3a 81       	ldd	r19, Y+2	; 0x02
    2592:	fc 01       	movw	r30, r24
    2594:	33 83       	std	Z+3, r19	; 0x03
    2596:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    2598:	80 91 88 0c 	lds	r24, 0x0C88
    259c:	90 91 89 0c 	lds	r25, 0x0C89
    25a0:	29 81       	ldd	r18, Y+1	; 0x01
    25a2:	3a 81       	ldd	r19, Y+2	; 0x02
    25a4:	28 17       	cp	r18, r24
    25a6:	39 07       	cpc	r19, r25
    25a8:	78 f4       	brcc	.+30     	; 0x25c8 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    25aa:	80 91 38 0c 	lds	r24, 0x0C38
    25ae:	90 91 39 0c 	lds	r25, 0x0C39
    25b2:	9c 01       	movw	r18, r24
    25b4:	2e 5f       	subi	r18, 0xFE	; 254
    25b6:	3f 4f       	sbci	r19, 0xFF	; 255
    25b8:	80 91 72 0c 	lds	r24, 0x0C72
    25bc:	90 91 73 0c 	lds	r25, 0x0C73
    25c0:	b9 01       	movw	r22, r18
    25c2:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>
    25c6:	1d c0       	rjmp	.+58     	; 0x2602 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    25c8:	80 91 38 0c 	lds	r24, 0x0C38
    25cc:	90 91 39 0c 	lds	r25, 0x0C39
    25d0:	9c 01       	movw	r18, r24
    25d2:	2e 5f       	subi	r18, 0xFE	; 254
    25d4:	3f 4f       	sbci	r19, 0xFF	; 255
    25d6:	80 91 70 0c 	lds	r24, 0x0C70
    25da:	90 91 71 0c 	lds	r25, 0x0C71
    25de:	b9 01       	movw	r22, r18
    25e0:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    25e4:	80 91 00 02 	lds	r24, 0x0200
    25e8:	90 91 01 02 	lds	r25, 0x0201
    25ec:	29 81       	ldd	r18, Y+1	; 0x01
    25ee:	3a 81       	ldd	r19, Y+2	; 0x02
    25f0:	28 17       	cp	r18, r24
    25f2:	39 07       	cpc	r19, r25
    25f4:	30 f4       	brcc	.+12     	; 0x2602 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	90 93 01 02 	sts	0x0201, r25
    25fe:	80 93 00 02 	sts	0x0200, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2602:	0f 90       	pop	r0
    2604:	0f 90       	pop	r0
    2606:	df 91       	pop	r29
    2608:	cf 91       	pop	r28
    260a:	08 95       	ret

0000260c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    260c:	cf 93       	push	r28
    260e:	df 93       	push	r29
    2610:	cd b7       	in	r28, 0x3d	; 61
    2612:	de b7       	in	r29, 0x3e	; 62
    2614:	28 97       	sbiw	r28, 0x08	; 8
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	de bf       	out	0x3e, r29	; 62
    261c:	0f be       	out	0x3f, r0	; 63
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	9e 83       	std	Y+6, r25	; 0x06
    2622:	8d 83       	std	Y+5, r24	; 0x05
    2624:	78 87       	std	Y+8, r23	; 0x08
    2626:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2628:	8f 81       	ldd	r24, Y+7	; 0x07
    262a:	98 85       	ldd	r25, Y+8	; 0x08
    262c:	89 2b       	or	r24, r25
    262e:	29 f4       	brne	.+10     	; 0x263a <prvAllocateTCBAndStack+0x2e>
    2630:	8d 81       	ldd	r24, Y+5	; 0x05
    2632:	9e 81       	ldd	r25, Y+6	; 0x06
    2634:	0e 94 05 07 	call	0xe0a	; 0xe0a <pvPortMalloc>
    2638:	02 c0       	rjmp	.+4      	; 0x263e <prvAllocateTCBAndStack+0x32>
    263a:	8f 81       	ldd	r24, Y+7	; 0x07
    263c:	98 85       	ldd	r25, Y+8	; 0x08
    263e:	9c 83       	std	Y+4, r25	; 0x04
    2640:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    2642:	8b 81       	ldd	r24, Y+3	; 0x03
    2644:	9c 81       	ldd	r25, Y+4	; 0x04
    2646:	89 2b       	or	r24, r25
    2648:	b9 f0       	breq	.+46     	; 0x2678 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    264a:	86 e2       	ldi	r24, 0x26	; 38
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	0e 94 05 07 	call	0xe0a	; 0xe0a <pvPortMalloc>
    2652:	9a 83       	std	Y+2, r25	; 0x02
    2654:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    2656:	89 81       	ldd	r24, Y+1	; 0x01
    2658:	9a 81       	ldd	r25, Y+2	; 0x02
    265a:	89 2b       	or	r24, r25
    265c:	41 f0       	breq	.+16     	; 0x266e <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	9a 81       	ldd	r25, Y+2	; 0x02
    2662:	2b 81       	ldd	r18, Y+3	; 0x03
    2664:	3c 81       	ldd	r19, Y+4	; 0x04
    2666:	fc 01       	movw	r30, r24
    2668:	30 8f       	std	Z+24, r19	; 0x18
    266a:	27 8b       	std	Z+23, r18	; 0x17
    266c:	07 c0       	rjmp	.+14     	; 0x267c <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    266e:	8b 81       	ldd	r24, Y+3	; 0x03
    2670:	9c 81       	ldd	r25, Y+4	; 0x04
    2672:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortFree>
    2676:	02 c0       	rjmp	.+4      	; 0x267c <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    2678:	1a 82       	std	Y+2, r1	; 0x02
    267a:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2680:	28 96       	adiw	r28, 0x08	; 8
    2682:	0f b6       	in	r0, 0x3f	; 63
    2684:	f8 94       	cli
    2686:	de bf       	out	0x3e, r29	; 62
    2688:	0f be       	out	0x3f, r0	; 63
    268a:	cd bf       	out	0x3d, r28	; 61
    268c:	df 91       	pop	r29
    268e:	cf 91       	pop	r28
    2690:	08 95       	ret

00002692 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2692:	cf 93       	push	r28
    2694:	df 93       	push	r29
    2696:	1f 92       	push	r1
    2698:	1f 92       	push	r1
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	9a 83       	std	Y+2, r25	; 0x02
    26a0:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    26a2:	89 81       	ldd	r24, Y+1	; 0x01
    26a4:	9a 81       	ldd	r25, Y+2	; 0x02
    26a6:	fc 01       	movw	r30, r24
    26a8:	87 89       	ldd	r24, Z+23	; 0x17
    26aa:	90 8d       	ldd	r25, Z+24	; 0x18
    26ac:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    26b0:	89 81       	ldd	r24, Y+1	; 0x01
    26b2:	9a 81       	ldd	r25, Y+2	; 0x02
    26b4:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortFree>
	}
    26b8:	0f 90       	pop	r0
    26ba:	0f 90       	pop	r0
    26bc:	df 91       	pop	r29
    26be:	cf 91       	pop	r28
    26c0:	08 95       	ret

000026c2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    26c2:	cf 93       	push	r28
    26c4:	df 93       	push	r29
    26c6:	1f 92       	push	r1
    26c8:	1f 92       	push	r1
    26ca:	cd b7       	in	r28, 0x3d	; 61
    26cc:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    26ce:	80 91 70 0c 	lds	r24, 0x0C70
    26d2:	90 91 71 0c 	lds	r25, 0x0C71
    26d6:	fc 01       	movw	r30, r24
    26d8:	80 81       	ld	r24, Z
    26da:	88 23       	and	r24, r24
    26dc:	39 f4       	brne	.+14     	; 0x26ec <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    26de:	8f ef       	ldi	r24, 0xFF	; 255
    26e0:	9f ef       	ldi	r25, 0xFF	; 255
    26e2:	90 93 01 02 	sts	0x0201, r25
    26e6:	80 93 00 02 	sts	0x0200, r24
    26ea:	15 c0       	rjmp	.+42     	; 0x2716 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    26ec:	80 91 70 0c 	lds	r24, 0x0C70
    26f0:	90 91 71 0c 	lds	r25, 0x0C71
    26f4:	fc 01       	movw	r30, r24
    26f6:	85 81       	ldd	r24, Z+5	; 0x05
    26f8:	96 81       	ldd	r25, Z+6	; 0x06
    26fa:	fc 01       	movw	r30, r24
    26fc:	86 81       	ldd	r24, Z+6	; 0x06
    26fe:	97 81       	ldd	r25, Z+7	; 0x07
    2700:	9a 83       	std	Y+2, r25	; 0x02
    2702:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2704:	89 81       	ldd	r24, Y+1	; 0x01
    2706:	9a 81       	ldd	r25, Y+2	; 0x02
    2708:	fc 01       	movw	r30, r24
    270a:	82 81       	ldd	r24, Z+2	; 0x02
    270c:	93 81       	ldd	r25, Z+3	; 0x03
    270e:	90 93 01 02 	sts	0x0201, r25
    2712:	80 93 00 02 	sts	0x0200, r24
	}
}
    2716:	0f 90       	pop	r0
    2718:	0f 90       	pop	r0
    271a:	df 91       	pop	r29
    271c:	cf 91       	pop	r28
    271e:	08 95       	ret

00002720 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29
    2724:	1f 92       	push	r1
    2726:	cd b7       	in	r28, 0x3d	; 61
    2728:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    272a:	80 91 8b 0c 	lds	r24, 0x0C8B
    272e:	88 23       	and	r24, r24
    2730:	19 f4       	brne	.+6      	; 0x2738 <xTaskGetSchedulerState+0x18>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2732:	81 e0       	ldi	r24, 0x01	; 1
    2734:	89 83       	std	Y+1, r24	; 0x01
    2736:	08 c0       	rjmp	.+16     	; 0x2748 <xTaskGetSchedulerState+0x28>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2738:	80 91 90 0c 	lds	r24, 0x0C90
    273c:	88 23       	and	r24, r24
    273e:	19 f4       	brne	.+6      	; 0x2746 <xTaskGetSchedulerState+0x26>
			{
				xReturn = taskSCHEDULER_RUNNING;
    2740:	82 e0       	ldi	r24, 0x02	; 2
    2742:	89 83       	std	Y+1, r24	; 0x01
    2744:	01 c0       	rjmp	.+2      	; 0x2748 <xTaskGetSchedulerState+0x28>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2746:	19 82       	std	Y+1, r1	; 0x01
			}
		}

		return xReturn;
    2748:	89 81       	ldd	r24, Y+1	; 0x01
	}
    274a:	0f 90       	pop	r0
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	08 95       	ret

00002752 <xTimerCreateTimerTask>:
const char * pcTimerGetTimerName( TimerHandle_t xTimer )
{
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	return pxTimer->pcTimerName;
}
    2752:	af 92       	push	r10
    2754:	bf 92       	push	r11
    2756:	cf 92       	push	r12
    2758:	df 92       	push	r13
    275a:	ef 92       	push	r14
    275c:	ff 92       	push	r15
    275e:	0f 93       	push	r16
    2760:	cf 93       	push	r28
    2762:	df 93       	push	r29
    2764:	1f 92       	push	r1
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
    276a:	19 82       	std	Y+1, r1	; 0x01
    276c:	ab d3       	rcall	.+1878   	; 0x2ec4 <prvCheckForValidListAndQueue>
    276e:	80 91 a7 0c 	lds	r24, 0x0CA7
    2772:	90 91 a8 0c 	lds	r25, 0x0CA8
    2776:	89 2b       	or	r24, r25
    2778:	89 f0       	breq	.+34     	; 0x279c <xTimerCreateTimerTask+0x4a>
    277a:	a1 2c       	mov	r10, r1
    277c:	b1 2c       	mov	r11, r1
    277e:	c1 2c       	mov	r12, r1
    2780:	d1 2c       	mov	r13, r1
    2782:	e1 2c       	mov	r14, r1
    2784:	f1 2c       	mov	r15, r1
    2786:	04 e0       	ldi	r16, 0x04	; 4
    2788:	20 e0       	ldi	r18, 0x00	; 0
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	49 eb       	ldi	r20, 0xB9	; 185
    278e:	50 e0       	ldi	r21, 0x00	; 0
    2790:	67 e0       	ldi	r22, 0x07	; 7
    2792:	72 e0       	ldi	r23, 0x02	; 2
    2794:	8e ee       	ldi	r24, 0xEE	; 238
    2796:	94 e1       	ldi	r25, 0x14	; 20
    2798:	bd d8       	rcall	.-3718   	; 0x1914 <xTaskGenericCreate>
    279a:	89 83       	std	Y+1, r24	; 0x01
    279c:	89 81       	ldd	r24, Y+1	; 0x01
    279e:	0f 90       	pop	r0
    27a0:	df 91       	pop	r29
    27a2:	cf 91       	pop	r28
    27a4:	0f 91       	pop	r16
    27a6:	ff 90       	pop	r15
    27a8:	ef 90       	pop	r14
    27aa:	df 90       	pop	r13
    27ac:	cf 90       	pop	r12
    27ae:	bf 90       	pop	r11
    27b0:	af 90       	pop	r10
    27b2:	08 95       	ret

000027b4 <xTimerCreate>:
    27b4:	0f 93       	push	r16
    27b6:	1f 93       	push	r17
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	2b 97       	sbiw	r28, 0x0b	; 11
    27c2:	0f b6       	in	r0, 0x3f	; 63
    27c4:	f8 94       	cli
    27c6:	de bf       	out	0x3e, r29	; 62
    27c8:	0f be       	out	0x3f, r0	; 63
    27ca:	cd bf       	out	0x3d, r28	; 61
    27cc:	9c 83       	std	Y+4, r25	; 0x04
    27ce:	8b 83       	std	Y+3, r24	; 0x03
    27d0:	7e 83       	std	Y+6, r23	; 0x06
    27d2:	6d 83       	std	Y+5, r22	; 0x05
    27d4:	4f 83       	std	Y+7, r20	; 0x07
    27d6:	39 87       	std	Y+9, r19	; 0x09
    27d8:	28 87       	std	Y+8, r18	; 0x08
    27da:	1b 87       	std	Y+11, r17	; 0x0b
    27dc:	0a 87       	std	Y+10, r16	; 0x0a
    27de:	8d 81       	ldd	r24, Y+5	; 0x05
    27e0:	9e 81       	ldd	r25, Y+6	; 0x06
    27e2:	89 2b       	or	r24, r25
    27e4:	19 f4       	brne	.+6      	; 0x27ec <xTimerCreate+0x38>
    27e6:	1a 82       	std	Y+2, r1	; 0x02
    27e8:	19 82       	std	Y+1, r1	; 0x01
    27ea:	31 c0       	rjmp	.+98     	; 0x284e <xTimerCreate+0x9a>
    27ec:	83 e1       	ldi	r24, 0x13	; 19
    27ee:	90 e0       	ldi	r25, 0x00	; 0
    27f0:	0e 94 05 07 	call	0xe0a	; 0xe0a <pvPortMalloc>
    27f4:	9a 83       	std	Y+2, r25	; 0x02
    27f6:	89 83       	std	Y+1, r24	; 0x01
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	9a 81       	ldd	r25, Y+2	; 0x02
    27fc:	89 2b       	or	r24, r25
    27fe:	39 f1       	breq	.+78     	; 0x284e <xTimerCreate+0x9a>
    2800:	61 d3       	rcall	.+1730   	; 0x2ec4 <prvCheckForValidListAndQueue>
    2802:	89 81       	ldd	r24, Y+1	; 0x01
    2804:	9a 81       	ldd	r25, Y+2	; 0x02
    2806:	2b 81       	ldd	r18, Y+3	; 0x03
    2808:	3c 81       	ldd	r19, Y+4	; 0x04
    280a:	fc 01       	movw	r30, r24
    280c:	31 83       	std	Z+1, r19	; 0x01
    280e:	20 83       	st	Z, r18
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
    2814:	2d 81       	ldd	r18, Y+5	; 0x05
    2816:	3e 81       	ldd	r19, Y+6	; 0x06
    2818:	fc 01       	movw	r30, r24
    281a:	35 87       	std	Z+13, r19	; 0x0d
    281c:	24 87       	std	Z+12, r18	; 0x0c
    281e:	89 81       	ldd	r24, Y+1	; 0x01
    2820:	9a 81       	ldd	r25, Y+2	; 0x02
    2822:	2f 81       	ldd	r18, Y+7	; 0x07
    2824:	fc 01       	movw	r30, r24
    2826:	26 87       	std	Z+14, r18	; 0x0e
    2828:	89 81       	ldd	r24, Y+1	; 0x01
    282a:	9a 81       	ldd	r25, Y+2	; 0x02
    282c:	28 85       	ldd	r18, Y+8	; 0x08
    282e:	39 85       	ldd	r19, Y+9	; 0x09
    2830:	fc 01       	movw	r30, r24
    2832:	30 8b       	std	Z+16, r19	; 0x10
    2834:	27 87       	std	Z+15, r18	; 0x0f
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	9a 81       	ldd	r25, Y+2	; 0x02
    283a:	2a 85       	ldd	r18, Y+10	; 0x0a
    283c:	3b 85       	ldd	r19, Y+11	; 0x0b
    283e:	fc 01       	movw	r30, r24
    2840:	32 8b       	std	Z+18, r19	; 0x12
    2842:	21 8b       	std	Z+17, r18	; 0x11
    2844:	89 81       	ldd	r24, Y+1	; 0x01
    2846:	9a 81       	ldd	r25, Y+2	; 0x02
    2848:	02 96       	adiw	r24, 0x02	; 2
    284a:	0e 94 e7 00 	call	0x1ce	; 0x1ce <vListInitialiseItem>
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	9a 81       	ldd	r25, Y+2	; 0x02
    2852:	2b 96       	adiw	r28, 0x0b	; 11
    2854:	0f b6       	in	r0, 0x3f	; 63
    2856:	f8 94       	cli
    2858:	de bf       	out	0x3e, r29	; 62
    285a:	0f be       	out	0x3f, r0	; 63
    285c:	cd bf       	out	0x3d, r28	; 61
    285e:	df 91       	pop	r29
    2860:	cf 91       	pop	r28
    2862:	1f 91       	pop	r17
    2864:	0f 91       	pop	r16
    2866:	08 95       	ret

00002868 <xTimerGenericCommand>:
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	cd b7       	in	r28, 0x3d	; 61
    2872:	de b7       	in	r29, 0x3e	; 62
    2874:	2f 97       	sbiw	r28, 0x0f	; 15
    2876:	0f b6       	in	r0, 0x3f	; 63
    2878:	f8 94       	cli
    287a:	de bf       	out	0x3e, r29	; 62
    287c:	0f be       	out	0x3f, r0	; 63
    287e:	cd bf       	out	0x3d, r28	; 61
    2880:	98 87       	std	Y+8, r25	; 0x08
    2882:	8f 83       	std	Y+7, r24	; 0x07
    2884:	69 87       	std	Y+9, r22	; 0x09
    2886:	5b 87       	std	Y+11, r21	; 0x0b
    2888:	4a 87       	std	Y+10, r20	; 0x0a
    288a:	3d 87       	std	Y+13, r19	; 0x0d
    288c:	2c 87       	std	Y+12, r18	; 0x0c
    288e:	1f 87       	std	Y+15, r17	; 0x0f
    2890:	0e 87       	std	Y+14, r16	; 0x0e
    2892:	19 82       	std	Y+1, r1	; 0x01
    2894:	80 91 a7 0c 	lds	r24, 0x0CA7
    2898:	90 91 a8 0c 	lds	r25, 0x0CA8
    289c:	89 2b       	or	r24, r25
    289e:	c9 f1       	breq	.+114    	; 0x2912 <xTimerGenericCommand+0xaa>
    28a0:	89 85       	ldd	r24, Y+9	; 0x09
    28a2:	8a 83       	std	Y+2, r24	; 0x02
    28a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    28a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    28a8:	9c 83       	std	Y+4, r25	; 0x04
    28aa:	8b 83       	std	Y+3, r24	; 0x03
    28ac:	8f 81       	ldd	r24, Y+7	; 0x07
    28ae:	98 85       	ldd	r25, Y+8	; 0x08
    28b0:	9e 83       	std	Y+6, r25	; 0x06
    28b2:	8d 83       	std	Y+5, r24	; 0x05
    28b4:	89 85       	ldd	r24, Y+9	; 0x09
    28b6:	86 30       	cpi	r24, 0x06	; 6
    28b8:	fc f4       	brge	.+62     	; 0x28f8 <xTimerGenericCommand+0x90>
    28ba:	32 df       	rcall	.-412    	; 0x2720 <xTaskGetSchedulerState>
    28bc:	82 30       	cpi	r24, 0x02	; 2
    28be:	71 f4       	brne	.+28     	; 0x28dc <xTimerGenericCommand+0x74>
    28c0:	80 91 a7 0c 	lds	r24, 0x0CA7
    28c4:	90 91 a8 0c 	lds	r25, 0x0CA8
    28c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    28ca:	5f 85       	ldd	r21, Y+15	; 0x0f
    28cc:	be 01       	movw	r22, r28
    28ce:	6e 5f       	subi	r22, 0xFE	; 254
    28d0:	7f 4f       	sbci	r23, 0xFF	; 255
    28d2:	20 e0       	ldi	r18, 0x00	; 0
    28d4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
    28d8:	89 83       	std	Y+1, r24	; 0x01
    28da:	1b c0       	rjmp	.+54     	; 0x2912 <xTimerGenericCommand+0xaa>
    28dc:	80 91 a7 0c 	lds	r24, 0x0CA7
    28e0:	90 91 a8 0c 	lds	r25, 0x0CA8
    28e4:	be 01       	movw	r22, r28
    28e6:	6e 5f       	subi	r22, 0xFE	; 254
    28e8:	7f 4f       	sbci	r23, 0xFF	; 255
    28ea:	20 e0       	ldi	r18, 0x00	; 0
    28ec:	40 e0       	ldi	r20, 0x00	; 0
    28ee:	50 e0       	ldi	r21, 0x00	; 0
    28f0:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
    28f4:	89 83       	std	Y+1, r24	; 0x01
    28f6:	0d c0       	rjmp	.+26     	; 0x2912 <xTimerGenericCommand+0xaa>
    28f8:	80 91 a7 0c 	lds	r24, 0x0CA7
    28fc:	90 91 a8 0c 	lds	r25, 0x0CA8
    2900:	4c 85       	ldd	r20, Y+12	; 0x0c
    2902:	5d 85       	ldd	r21, Y+13	; 0x0d
    2904:	be 01       	movw	r22, r28
    2906:	6e 5f       	subi	r22, 0xFE	; 254
    2908:	7f 4f       	sbci	r23, 0xFF	; 255
    290a:	20 e0       	ldi	r18, 0x00	; 0
    290c:	0e 94 21 09 	call	0x1242	; 0x1242 <xQueueGenericSendFromISR>
    2910:	89 83       	std	Y+1, r24	; 0x01
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	2f 96       	adiw	r28, 0x0f	; 15
    2916:	0f b6       	in	r0, 0x3f	; 63
    2918:	f8 94       	cli
    291a:	de bf       	out	0x3e, r29	; 62
    291c:	0f be       	out	0x3f, r0	; 63
    291e:	cd bf       	out	0x3d, r28	; 61
    2920:	df 91       	pop	r29
    2922:	cf 91       	pop	r28
    2924:	1f 91       	pop	r17
    2926:	0f 91       	pop	r16
    2928:	08 95       	ret

0000292a <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
    292a:	0f 93       	push	r16
    292c:	1f 93       	push	r17
    292e:	cf 93       	push	r28
    2930:	df 93       	push	r29
    2932:	cd b7       	in	r28, 0x3d	; 61
    2934:	de b7       	in	r29, 0x3e	; 62
    2936:	27 97       	sbiw	r28, 0x07	; 7
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	de bf       	out	0x3e, r29	; 62
    293e:	0f be       	out	0x3f, r0	; 63
    2940:	cd bf       	out	0x3d, r28	; 61
    2942:	9d 83       	std	Y+5, r25	; 0x05
    2944:	8c 83       	std	Y+4, r24	; 0x04
    2946:	7f 83       	std	Y+7, r23	; 0x07
    2948:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    294a:	80 91 a3 0c 	lds	r24, 0x0CA3
    294e:	90 91 a4 0c 	lds	r25, 0x0CA4
    2952:	fc 01       	movw	r30, r24
    2954:	85 81       	ldd	r24, Z+5	; 0x05
    2956:	96 81       	ldd	r25, Z+6	; 0x06
    2958:	fc 01       	movw	r30, r24
    295a:	86 81       	ldd	r24, Z+6	; 0x06
    295c:	97 81       	ldd	r25, Z+7	; 0x07
    295e:	9a 83       	std	Y+2, r25	; 0x02
    2960:	89 83       	std	Y+1, r24	; 0x01

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2962:	89 81       	ldd	r24, Y+1	; 0x01
    2964:	9a 81       	ldd	r25, Y+2	; 0x02
    2966:	02 96       	adiw	r24, 0x02	; 2
    2968:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    296c:	89 81       	ldd	r24, Y+1	; 0x01
    296e:	9a 81       	ldd	r25, Y+2	; 0x02
    2970:	fc 01       	movw	r30, r24
    2972:	86 85       	ldd	r24, Z+14	; 0x0e
    2974:	81 30       	cpi	r24, 0x01	; 1
    2976:	f1 f4       	brne	.+60     	; 0x29b4 <prvProcessExpiredTimer+0x8a>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2978:	89 81       	ldd	r24, Y+1	; 0x01
    297a:	9a 81       	ldd	r25, Y+2	; 0x02
    297c:	fc 01       	movw	r30, r24
    297e:	24 85       	ldd	r18, Z+12	; 0x0c
    2980:	35 85       	ldd	r19, Z+13	; 0x0d
    2982:	8c 81       	ldd	r24, Y+4	; 0x04
    2984:	9d 81       	ldd	r25, Y+5	; 0x05
    2986:	b9 01       	movw	r22, r18
    2988:	68 0f       	add	r22, r24
    298a:	79 1f       	adc	r23, r25
    298c:	2c 81       	ldd	r18, Y+4	; 0x04
    298e:	3d 81       	ldd	r19, Y+5	; 0x05
    2990:	4e 81       	ldd	r20, Y+6	; 0x06
    2992:	5f 81       	ldd	r21, Y+7	; 0x07
    2994:	89 81       	ldd	r24, Y+1	; 0x01
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
    2998:	da d0       	rcall	.+436    	; 0x2b4e <prvInsertTimerInActiveList>
    299a:	81 30       	cpi	r24, 0x01	; 1
    299c:	59 f4       	brne	.+22     	; 0x29b4 <prvProcessExpiredTimer+0x8a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    299e:	4c 81       	ldd	r20, Y+4	; 0x04
    29a0:	5d 81       	ldd	r21, Y+5	; 0x05
    29a2:	89 81       	ldd	r24, Y+1	; 0x01
    29a4:	9a 81       	ldd	r25, Y+2	; 0x02
    29a6:	00 e0       	ldi	r16, 0x00	; 0
    29a8:	10 e0       	ldi	r17, 0x00	; 0
    29aa:	20 e0       	ldi	r18, 0x00	; 0
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	60 e0       	ldi	r22, 0x00	; 0
    29b0:	5b df       	rcall	.-330    	; 0x2868 <xTimerGenericCommand>
    29b2:	8b 83       	std	Y+3, r24	; 0x03
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29b4:	89 81       	ldd	r24, Y+1	; 0x01
    29b6:	9a 81       	ldd	r25, Y+2	; 0x02
    29b8:	fc 01       	movw	r30, r24
    29ba:	21 89       	ldd	r18, Z+17	; 0x11
    29bc:	32 89       	ldd	r19, Z+18	; 0x12
    29be:	89 81       	ldd	r24, Y+1	; 0x01
    29c0:	9a 81       	ldd	r25, Y+2	; 0x02
    29c2:	f9 01       	movw	r30, r18
    29c4:	19 95       	eicall
}
    29c6:	27 96       	adiw	r28, 0x07	; 7
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	de bf       	out	0x3e, r29	; 62
    29ce:	0f be       	out	0x3f, r0	; 63
    29d0:	cd bf       	out	0x3d, r28	; 61
    29d2:	df 91       	pop	r29
    29d4:	cf 91       	pop	r28
    29d6:	1f 91       	pop	r17
    29d8:	0f 91       	pop	r16
    29da:	08 95       	ret

000029dc <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    29dc:	cf 93       	push	r28
    29de:	df 93       	push	r29
    29e0:	00 d0       	rcall	.+0      	; 0x29e2 <prvTimerTask+0x6>
    29e2:	1f 92       	push	r1
    29e4:	1f 92       	push	r1
    29e6:	cd b7       	in	r28, 0x3d	; 61
    29e8:	de b7       	in	r29, 0x3e	; 62
    29ea:	9d 83       	std	Y+5, r25	; 0x05
    29ec:	8c 83       	std	Y+4, r24	; 0x04

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    29ee:	ce 01       	movw	r24, r28
    29f0:	03 96       	adiw	r24, 0x03	; 3
    29f2:	4a d0       	rcall	.+148    	; 0x2a88 <prvGetNextExpireTime>
    29f4:	9a 83       	std	Y+2, r25	; 0x02
    29f6:	89 83       	std	Y+1, r24	; 0x01

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    29f8:	2b 81       	ldd	r18, Y+3	; 0x03
    29fa:	89 81       	ldd	r24, Y+1	; 0x01
    29fc:	9a 81       	ldd	r25, Y+2	; 0x02
    29fe:	62 2f       	mov	r22, r18
    2a00:	02 d0       	rcall	.+4      	; 0x2a06 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
    2a02:	12 d1       	rcall	.+548    	; 0x2c28 <prvProcessReceivedCommands>
	}
    2a04:	f4 cf       	rjmp	.-24     	; 0x29ee <prvTimerTask+0x12>

00002a06 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
    2a06:	cf 93       	push	r28
    2a08:	df 93       	push	r29
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <prvProcessTimerOrBlockTask+0x6>
    2a0c:	00 d0       	rcall	.+0      	; 0x2a0e <prvProcessTimerOrBlockTask+0x8>
    2a0e:	cd b7       	in	r28, 0x3d	; 61
    2a10:	de b7       	in	r29, 0x3e	; 62
    2a12:	9d 83       	std	Y+5, r25	; 0x05
    2a14:	8c 83       	std	Y+4, r24	; 0x04
    2a16:	6e 83       	std	Y+6, r22	; 0x06
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2a18:	25 d9       	rcall	.-3510   	; 0x1c64 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2a1a:	ce 01       	movw	r24, r28
    2a1c:	03 96       	adiw	r24, 0x03	; 3
    2a1e:	69 d0       	rcall	.+210    	; 0x2af2 <prvSampleTimeNow>
    2a20:	9a 83       	std	Y+2, r25	; 0x02
    2a22:	89 83       	std	Y+1, r24	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    2a24:	8b 81       	ldd	r24, Y+3	; 0x03
    2a26:	88 23       	and	r24, r24
    2a28:	29 f5       	brne	.+74     	; 0x2a74 <prvProcessTimerOrBlockTask+0x6e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2a2a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a2c:	88 23       	and	r24, r24
    2a2e:	79 f4       	brne	.+30     	; 0x2a4e <prvProcessTimerOrBlockTask+0x48>
    2a30:	2c 81       	ldd	r18, Y+4	; 0x04
    2a32:	3d 81       	ldd	r19, Y+5	; 0x05
    2a34:	89 81       	ldd	r24, Y+1	; 0x01
    2a36:	9a 81       	ldd	r25, Y+2	; 0x02
    2a38:	82 17       	cp	r24, r18
    2a3a:	93 07       	cpc	r25, r19
    2a3c:	40 f0       	brcs	.+16     	; 0x2a4e <prvProcessTimerOrBlockTask+0x48>
			{
				( void ) xTaskResumeAll();
    2a3e:	1e d9       	rcall	.-3524   	; 0x1c7c <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    2a40:	29 81       	ldd	r18, Y+1	; 0x01
    2a42:	3a 81       	ldd	r19, Y+2	; 0x02
    2a44:	8c 81       	ldd	r24, Y+4	; 0x04
    2a46:	9d 81       	ldd	r25, Y+5	; 0x05
    2a48:	b9 01       	movw	r22, r18
    2a4a:	6f df       	rcall	.-290    	; 0x292a <prvProcessExpiredTimer>
    2a4c:	14 c0       	rjmp	.+40     	; 0x2a76 <prvProcessTimerOrBlockTask+0x70>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    2a4e:	2c 81       	ldd	r18, Y+4	; 0x04
    2a50:	3d 81       	ldd	r19, Y+5	; 0x05
    2a52:	89 81       	ldd	r24, Y+1	; 0x01
    2a54:	9a 81       	ldd	r25, Y+2	; 0x02
    2a56:	28 1b       	sub	r18, r24
    2a58:	39 0b       	sbc	r19, r25
    2a5a:	80 91 a7 0c 	lds	r24, 0x0CA7
    2a5e:	90 91 a8 0c 	lds	r25, 0x0CA8
    2a62:	b9 01       	movw	r22, r18
    2a64:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    2a68:	09 d9       	rcall	.-3566   	; 0x1c7c <xTaskResumeAll>
    2a6a:	88 23       	and	r24, r24
    2a6c:	21 f4       	brne	.+8      	; 0x2a76 <prvProcessTimerOrBlockTask+0x70>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2a6e:	0e 94 8e 05 	call	0xb1c	; 0xb1c <vPortYield>
    2a72:	01 c0       	rjmp	.+2      	; 0x2a76 <prvProcessTimerOrBlockTask+0x70>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2a74:	03 d9       	rcall	.-3578   	; 0x1c7c <xTaskResumeAll>
		}
	}
}
    2a76:	26 96       	adiw	r28, 0x06	; 6
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	f8 94       	cli
    2a7c:	de bf       	out	0x3e, r29	; 62
    2a7e:	0f be       	out	0x3f, r0	; 63
    2a80:	cd bf       	out	0x3d, r28	; 61
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	08 95       	ret

00002a88 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
    2a88:	cf 93       	push	r28
    2a8a:	df 93       	push	r29
    2a8c:	00 d0       	rcall	.+0      	; 0x2a8e <prvGetNextExpireTime+0x6>
    2a8e:	1f 92       	push	r1
    2a90:	cd b7       	in	r28, 0x3d	; 61
    2a92:	de b7       	in	r29, 0x3e	; 62
    2a94:	9c 83       	std	Y+4, r25	; 0x04
    2a96:	8b 83       	std	Y+3, r24	; 0x03
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2a98:	80 91 a3 0c 	lds	r24, 0x0CA3
    2a9c:	90 91 a4 0c 	lds	r25, 0x0CA4
    2aa0:	fc 01       	movw	r30, r24
    2aa2:	90 81       	ld	r25, Z
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	99 23       	and	r25, r25
    2aa8:	09 f0       	breq	.+2      	; 0x2aac <prvGetNextExpireTime+0x24>
    2aaa:	80 e0       	ldi	r24, 0x00	; 0
    2aac:	28 2f       	mov	r18, r24
    2aae:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	20 83       	st	Z, r18
	if( *pxListWasEmpty == pdFALSE )
    2ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aba:	fc 01       	movw	r30, r24
    2abc:	80 81       	ld	r24, Z
    2abe:	88 23       	and	r24, r24
    2ac0:	69 f4       	brne	.+26     	; 0x2adc <prvGetNextExpireTime+0x54>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2ac2:	80 91 a3 0c 	lds	r24, 0x0CA3
    2ac6:	90 91 a4 0c 	lds	r25, 0x0CA4
    2aca:	fc 01       	movw	r30, r24
    2acc:	85 81       	ldd	r24, Z+5	; 0x05
    2ace:	96 81       	ldd	r25, Z+6	; 0x06
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	80 81       	ld	r24, Z
    2ad4:	91 81       	ldd	r25, Z+1	; 0x01
    2ad6:	9a 83       	std	Y+2, r25	; 0x02
    2ad8:	89 83       	std	Y+1, r24	; 0x01
    2ada:	02 c0       	rjmp	.+4      	; 0x2ae0 <prvGetNextExpireTime+0x58>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2adc:	1a 82       	std	Y+2, r1	; 0x02
    2ade:	19 82       	std	Y+1, r1	; 0x01
	}

	return xNextExpireTime;
    2ae0:	89 81       	ldd	r24, Y+1	; 0x01
    2ae2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2ae4:	0f 90       	pop	r0
    2ae6:	0f 90       	pop	r0
    2ae8:	0f 90       	pop	r0
    2aea:	0f 90       	pop	r0
    2aec:	df 91       	pop	r29
    2aee:	cf 91       	pop	r28
    2af0:	08 95       	ret

00002af2 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2af2:	cf 93       	push	r28
    2af4:	df 93       	push	r29
    2af6:	00 d0       	rcall	.+0      	; 0x2af8 <prvSampleTimeNow+0x6>
    2af8:	1f 92       	push	r1
    2afa:	cd b7       	in	r28, 0x3d	; 61
    2afc:	de b7       	in	r29, 0x3e	; 62
    2afe:	9c 83       	std	Y+4, r25	; 0x04
    2b00:	8b 83       	std	Y+3, r24	; 0x03
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2b02:	48 d9       	rcall	.-3440   	; 0x1d94 <xTaskGetTickCount>
    2b04:	9a 83       	std	Y+2, r25	; 0x02
    2b06:	89 83       	std	Y+1, r24	; 0x01

	if( xTimeNow < xLastTime )
    2b08:	80 91 a9 0c 	lds	r24, 0x0CA9
    2b0c:	90 91 aa 0c 	lds	r25, 0x0CAA
    2b10:	29 81       	ldd	r18, Y+1	; 0x01
    2b12:	3a 81       	ldd	r19, Y+2	; 0x02
    2b14:	28 17       	cp	r18, r24
    2b16:	39 07       	cpc	r19, r25
    2b18:	38 f4       	brcc	.+14     	; 0x2b28 <prvSampleTimeNow+0x36>
	{
		prvSwitchTimerLists();
    2b1a:	3b d1       	rcall	.+630    	; 0x2d92 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
    2b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b20:	21 e0       	ldi	r18, 0x01	; 1
    2b22:	fc 01       	movw	r30, r24
    2b24:	20 83       	st	Z, r18
    2b26:	04 c0       	rjmp	.+8      	; 0x2b30 <prvSampleTimeNow+0x3e>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2b30:	89 81       	ldd	r24, Y+1	; 0x01
    2b32:	9a 81       	ldd	r25, Y+2	; 0x02
    2b34:	90 93 aa 0c 	sts	0x0CAA, r25
    2b38:	80 93 a9 0c 	sts	0x0CA9, r24

	return xTimeNow;
    2b3c:	89 81       	ldd	r24, Y+1	; 0x01
    2b3e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b40:	0f 90       	pop	r0
    2b42:	0f 90       	pop	r0
    2b44:	0f 90       	pop	r0
    2b46:	0f 90       	pop	r0
    2b48:	df 91       	pop	r29
    2b4a:	cf 91       	pop	r28
    2b4c:	08 95       	ret

00002b4e <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2b4e:	cf 93       	push	r28
    2b50:	df 93       	push	r29
    2b52:	cd b7       	in	r28, 0x3d	; 61
    2b54:	de b7       	in	r29, 0x3e	; 62
    2b56:	29 97       	sbiw	r28, 0x09	; 9
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	9b 83       	std	Y+3, r25	; 0x03
    2b64:	8a 83       	std	Y+2, r24	; 0x02
    2b66:	7d 83       	std	Y+5, r23	; 0x05
    2b68:	6c 83       	std	Y+4, r22	; 0x04
    2b6a:	5f 83       	std	Y+7, r21	; 0x07
    2b6c:	4e 83       	std	Y+6, r20	; 0x06
    2b6e:	39 87       	std	Y+9, r19	; 0x09
    2b70:	28 87       	std	Y+8, r18	; 0x08
BaseType_t xProcessTimerNow = pdFALSE;
    2b72:	19 82       	std	Y+1, r1	; 0x01

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2b74:	8a 81       	ldd	r24, Y+2	; 0x02
    2b76:	9b 81       	ldd	r25, Y+3	; 0x03
    2b78:	2c 81       	ldd	r18, Y+4	; 0x04
    2b7a:	3d 81       	ldd	r19, Y+5	; 0x05
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	33 83       	std	Z+3, r19	; 0x03
    2b80:	22 83       	std	Z+2, r18	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2b82:	8a 81       	ldd	r24, Y+2	; 0x02
    2b84:	9b 81       	ldd	r25, Y+3	; 0x03
    2b86:	2a 81       	ldd	r18, Y+2	; 0x02
    2b88:	3b 81       	ldd	r19, Y+3	; 0x03
    2b8a:	fc 01       	movw	r30, r24
    2b8c:	31 87       	std	Z+9, r19	; 0x09
    2b8e:	20 87       	std	Z+8, r18	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    2b90:	2c 81       	ldd	r18, Y+4	; 0x04
    2b92:	3d 81       	ldd	r19, Y+5	; 0x05
    2b94:	8e 81       	ldd	r24, Y+6	; 0x06
    2b96:	9f 81       	ldd	r25, Y+7	; 0x07
    2b98:	82 17       	cp	r24, r18
    2b9a:	93 07       	cpc	r25, r19
    2b9c:	f0 f0       	brcs	.+60     	; 0x2bda <prvInsertTimerInActiveList+0x8c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2b9e:	2e 81       	ldd	r18, Y+6	; 0x06
    2ba0:	3f 81       	ldd	r19, Y+7	; 0x07
    2ba2:	88 85       	ldd	r24, Y+8	; 0x08
    2ba4:	99 85       	ldd	r25, Y+9	; 0x09
    2ba6:	28 1b       	sub	r18, r24
    2ba8:	39 0b       	sbc	r19, r25
    2baa:	8a 81       	ldd	r24, Y+2	; 0x02
    2bac:	9b 81       	ldd	r25, Y+3	; 0x03
    2bae:	fc 01       	movw	r30, r24
    2bb0:	84 85       	ldd	r24, Z+12	; 0x0c
    2bb2:	95 85       	ldd	r25, Z+13	; 0x0d
    2bb4:	28 17       	cp	r18, r24
    2bb6:	39 07       	cpc	r19, r25
    2bb8:	18 f0       	brcs	.+6      	; 0x2bc0 <prvInsertTimerInActiveList+0x72>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2bba:	81 e0       	ldi	r24, 0x01	; 1
    2bbc:	89 83       	std	Y+1, r24	; 0x01
    2bbe:	2a c0       	rjmp	.+84     	; 0x2c14 <prvInsertTimerInActiveList+0xc6>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2bc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc4:	9c 01       	movw	r18, r24
    2bc6:	2e 5f       	subi	r18, 0xFE	; 254
    2bc8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bca:	80 91 a5 0c 	lds	r24, 0x0CA5
    2bce:	90 91 a6 0c 	lds	r25, 0x0CA6
    2bd2:	b9 01       	movw	r22, r18
    2bd4:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>
    2bd8:	1d c0       	rjmp	.+58     	; 0x2c14 <prvInsertTimerInActiveList+0xc6>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2bda:	2e 81       	ldd	r18, Y+6	; 0x06
    2bdc:	3f 81       	ldd	r19, Y+7	; 0x07
    2bde:	88 85       	ldd	r24, Y+8	; 0x08
    2be0:	99 85       	ldd	r25, Y+9	; 0x09
    2be2:	28 17       	cp	r18, r24
    2be4:	39 07       	cpc	r19, r25
    2be6:	50 f4       	brcc	.+20     	; 0x2bfc <prvInsertTimerInActiveList+0xae>
    2be8:	2c 81       	ldd	r18, Y+4	; 0x04
    2bea:	3d 81       	ldd	r19, Y+5	; 0x05
    2bec:	88 85       	ldd	r24, Y+8	; 0x08
    2bee:	99 85       	ldd	r25, Y+9	; 0x09
    2bf0:	28 17       	cp	r18, r24
    2bf2:	39 07       	cpc	r19, r25
    2bf4:	18 f0       	brcs	.+6      	; 0x2bfc <prvInsertTimerInActiveList+0xae>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	89 83       	std	Y+1, r24	; 0x01
    2bfa:	0c c0       	rjmp	.+24     	; 0x2c14 <prvInsertTimerInActiveList+0xc6>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	9c 01       	movw	r18, r24
    2c02:	2e 5f       	subi	r18, 0xFE	; 254
    2c04:	3f 4f       	sbci	r19, 0xFF	; 255
    2c06:	80 91 a3 0c 	lds	r24, 0x0CA3
    2c0a:	90 91 a4 0c 	lds	r25, 0x0CA4
    2c0e:	b9 01       	movw	r22, r18
    2c10:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>
		}
	}

	return xProcessTimerNow;
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c16:	29 96       	adiw	r28, 0x09	; 9
    2c18:	0f b6       	in	r0, 0x3f	; 63
    2c1a:	f8 94       	cli
    2c1c:	de bf       	out	0x3e, r29	; 62
    2c1e:	0f be       	out	0x3f, r0	; 63
    2c20:	cd bf       	out	0x3d, r28	; 61
    2c22:	df 91       	pop	r29
    2c24:	cf 91       	pop	r28
    2c26:	08 95       	ret

00002c28 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
    2c28:	0f 93       	push	r16
    2c2a:	1f 93       	push	r17
    2c2c:	cf 93       	push	r28
    2c2e:	df 93       	push	r29
    2c30:	cd b7       	in	r28, 0x3d	; 61
    2c32:	de b7       	in	r29, 0x3e	; 62
    2c34:	2b 97       	sbiw	r28, 0x0b	; 11
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	de bf       	out	0x3e, r29	; 62
    2c3c:	0f be       	out	0x3f, r0	; 63
    2c3e:	cd bf       	out	0x3d, r28	; 61
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2c40:	8e c0       	rjmp	.+284    	; 0x2d5e <prvProcessReceivedCommands+0x136>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2c42:	8e 81       	ldd	r24, Y+6	; 0x06
    2c44:	88 23       	and	r24, r24
    2c46:	0c f4       	brge	.+2      	; 0x2c4a <prvProcessReceivedCommands+0x22>
    2c48:	8a c0       	rjmp	.+276    	; 0x2d5e <prvProcessReceivedCommands+0x136>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2c4a:	89 85       	ldd	r24, Y+9	; 0x09
    2c4c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c4e:	9a 83       	std	Y+2, r25	; 0x02
    2c50:	89 83       	std	Y+1, r24	; 0x01

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2c52:	89 81       	ldd	r24, Y+1	; 0x01
    2c54:	9a 81       	ldd	r25, Y+2	; 0x02
    2c56:	dc 01       	movw	r26, r24
    2c58:	1a 96       	adiw	r26, 0x0a	; 10
    2c5a:	8d 91       	ld	r24, X+
    2c5c:	9c 91       	ld	r25, X
    2c5e:	1b 97       	sbiw	r26, 0x0b	; 11
    2c60:	89 2b       	or	r24, r25
    2c62:	29 f0       	breq	.+10     	; 0x2c6e <prvProcessReceivedCommands+0x46>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c64:	89 81       	ldd	r24, Y+1	; 0x01
    2c66:	9a 81       	ldd	r25, Y+2	; 0x02
    2c68:	02 96       	adiw	r24, 0x02	; 2
    2c6a:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c6e:	ce 01       	movw	r24, r28
    2c70:	0b 96       	adiw	r24, 0x0b	; 11
    2c72:	3f df       	rcall	.-386    	; 0x2af2 <prvSampleTimeNow>
    2c74:	9c 83       	std	Y+4, r25	; 0x04
    2c76:	8b 83       	std	Y+3, r24	; 0x03

			switch( xMessage.xMessageID )
    2c78:	8e 81       	ldd	r24, Y+6	; 0x06
    2c7a:	08 2e       	mov	r0, r24
    2c7c:	00 0c       	add	r0, r0
    2c7e:	99 0b       	sbc	r25, r25
    2c80:	09 2e       	mov	r0, r25
    2c82:	00 0c       	add	r0, r0
    2c84:	aa 0b       	sbc	r26, r26
    2c86:	bb 0b       	sbc	r27, r27
    2c88:	40 e0       	ldi	r20, 0x00	; 0
    2c8a:	50 e0       	ldi	r21, 0x00	; 0
    2c8c:	29 e0       	ldi	r18, 0x09	; 9
    2c8e:	30 e0       	ldi	r19, 0x00	; 0
    2c90:	84 1b       	sub	r24, r20
    2c92:	95 0b       	sbc	r25, r21
    2c94:	28 17       	cp	r18, r24
    2c96:	39 07       	cpc	r19, r25
    2c98:	08 f4       	brcc	.+2      	; 0x2c9c <prvProcessReceivedCommands+0x74>
    2c9a:	60 c0       	rjmp	.+192    	; 0x2d5c <prvProcessReceivedCommands+0x134>
    2c9c:	fc 01       	movw	r30, r24
    2c9e:	88 27       	eor	r24, r24
    2ca0:	ee 58       	subi	r30, 0x8E	; 142
    2ca2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ca4:	8f 4f       	sbci	r24, 0xFF	; 255
    2ca6:	52 c4       	rjmp	.+2212   	; 0x354c <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    2ca8:	ef 81       	ldd	r30, Y+7	; 0x07
    2caa:	f8 85       	ldd	r31, Y+8	; 0x08
    2cac:	2f 81       	ldd	r18, Y+7	; 0x07
    2cae:	38 85       	ldd	r19, Y+8	; 0x08
    2cb0:	89 81       	ldd	r24, Y+1	; 0x01
    2cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb4:	dc 01       	movw	r26, r24
    2cb6:	1c 96       	adiw	r26, 0x0c	; 12
    2cb8:	8d 91       	ld	r24, X+
    2cba:	9c 91       	ld	r25, X
    2cbc:	1d 97       	sbiw	r26, 0x0d	; 13
    2cbe:	b9 01       	movw	r22, r18
    2cc0:	68 0f       	add	r22, r24
    2cc2:	79 1f       	adc	r23, r25
    2cc4:	4b 81       	ldd	r20, Y+3	; 0x03
    2cc6:	5c 81       	ldd	r21, Y+4	; 0x04
    2cc8:	89 81       	ldd	r24, Y+1	; 0x01
    2cca:	9a 81       	ldd	r25, Y+2	; 0x02
    2ccc:	9f 01       	movw	r18, r30
    2cce:	3f df       	rcall	.-386    	; 0x2b4e <prvInsertTimerInActiveList>
    2cd0:	81 30       	cpi	r24, 0x01	; 1
    2cd2:	19 f5       	brne	.+70     	; 0x2d1a <prvProcessReceivedCommands+0xf2>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2cd4:	89 81       	ldd	r24, Y+1	; 0x01
    2cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd8:	fc 01       	movw	r30, r24
    2cda:	21 89       	ldd	r18, Z+17	; 0x11
    2cdc:	32 89       	ldd	r19, Z+18	; 0x12
    2cde:	89 81       	ldd	r24, Y+1	; 0x01
    2ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce2:	f9 01       	movw	r30, r18
    2ce4:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2ce6:	89 81       	ldd	r24, Y+1	; 0x01
    2ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    2cea:	dc 01       	movw	r26, r24
    2cec:	1e 96       	adiw	r26, 0x0e	; 14
    2cee:	8c 91       	ld	r24, X
    2cf0:	81 30       	cpi	r24, 0x01	; 1
    2cf2:	99 f4       	brne	.+38     	; 0x2d1a <prvProcessReceivedCommands+0xf2>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2cf4:	2f 81       	ldd	r18, Y+7	; 0x07
    2cf6:	38 85       	ldd	r19, Y+8	; 0x08
    2cf8:	89 81       	ldd	r24, Y+1	; 0x01
    2cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	84 85       	ldd	r24, Z+12	; 0x0c
    2d00:	95 85       	ldd	r25, Z+13	; 0x0d
    2d02:	a9 01       	movw	r20, r18
    2d04:	48 0f       	add	r20, r24
    2d06:	59 1f       	adc	r21, r25
    2d08:	89 81       	ldd	r24, Y+1	; 0x01
    2d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d0c:	00 e0       	ldi	r16, 0x00	; 0
    2d0e:	10 e0       	ldi	r17, 0x00	; 0
    2d10:	20 e0       	ldi	r18, 0x00	; 0
    2d12:	30 e0       	ldi	r19, 0x00	; 0
    2d14:	60 e0       	ldi	r22, 0x00	; 0
    2d16:	a8 dd       	rcall	.-1200   	; 0x2868 <xTimerGenericCommand>
    2d18:	8d 83       	std	Y+5, r24	; 0x05
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
    2d1a:	21 c0       	rjmp	.+66     	; 0x2d5e <prvProcessReceivedCommands+0x136>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d1c:	2f 81       	ldd	r18, Y+7	; 0x07
    2d1e:	38 85       	ldd	r19, Y+8	; 0x08
    2d20:	89 81       	ldd	r24, Y+1	; 0x01
    2d22:	9a 81       	ldd	r25, Y+2	; 0x02
    2d24:	dc 01       	movw	r26, r24
    2d26:	1d 96       	adiw	r26, 0x0d	; 13
    2d28:	3c 93       	st	X, r19
    2d2a:	2e 93       	st	-X, r18
    2d2c:	1c 97       	sbiw	r26, 0x0c	; 12
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d2e:	89 81       	ldd	r24, Y+1	; 0x01
    2d30:	9a 81       	ldd	r25, Y+2	; 0x02
    2d32:	fc 01       	movw	r30, r24
    2d34:	24 85       	ldd	r18, Z+12	; 0x0c
    2d36:	35 85       	ldd	r19, Z+13	; 0x0d
    2d38:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d3c:	b9 01       	movw	r22, r18
    2d3e:	68 0f       	add	r22, r24
    2d40:	79 1f       	adc	r23, r25
    2d42:	2b 81       	ldd	r18, Y+3	; 0x03
    2d44:	3c 81       	ldd	r19, Y+4	; 0x04
    2d46:	4b 81       	ldd	r20, Y+3	; 0x03
    2d48:	5c 81       	ldd	r21, Y+4	; 0x04
    2d4a:	89 81       	ldd	r24, Y+1	; 0x01
    2d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4e:	ff de       	rcall	.-514    	; 0x2b4e <prvInsertTimerInActiveList>
					break;
    2d50:	06 c0       	rjmp	.+12     	; 0x2d5e <prvProcessReceivedCommands+0x136>

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2d52:	89 81       	ldd	r24, Y+1	; 0x01
    2d54:	9a 81       	ldd	r25, Y+2	; 0x02
    2d56:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortFree>
					break;
    2d5a:	01 c0       	rjmp	.+2      	; 0x2d5e <prvProcessReceivedCommands+0x136>

				default	:
					/* Don't expect to get here. */
					break;
    2d5c:	00 00       	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d5e:	80 91 a7 0c 	lds	r24, 0x0CA7
    2d62:	90 91 a8 0c 	lds	r25, 0x0CA8
    2d66:	be 01       	movw	r22, r28
    2d68:	6a 5f       	subi	r22, 0xFA	; 250
    2d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d6c:	20 e0       	ldi	r18, 0x00	; 0
    2d6e:	40 e0       	ldi	r20, 0x00	; 0
    2d70:	50 e0       	ldi	r21, 0x00	; 0
    2d72:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xQueueGenericReceive>
    2d76:	88 23       	and	r24, r24
    2d78:	09 f0       	breq	.+2      	; 0x2d7c <prvProcessReceivedCommands+0x154>
    2d7a:	63 cf       	rjmp	.-314    	; 0x2c42 <prvProcessReceivedCommands+0x1a>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
    2d7c:	2b 96       	adiw	r28, 0x0b	; 11
    2d7e:	0f b6       	in	r0, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	de bf       	out	0x3e, r29	; 62
    2d84:	0f be       	out	0x3f, r0	; 63
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	df 91       	pop	r29
    2d8a:	cf 91       	pop	r28
    2d8c:	1f 91       	pop	r17
    2d8e:	0f 91       	pop	r16
    2d90:	08 95       	ret

00002d92 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2d92:	0f 93       	push	r16
    2d94:	1f 93       	push	r17
    2d96:	cf 93       	push	r28
    2d98:	df 93       	push	r29
    2d9a:	cd b7       	in	r28, 0x3d	; 61
    2d9c:	de b7       	in	r29, 0x3e	; 62
    2d9e:	29 97       	sbiw	r28, 0x09	; 9
    2da0:	0f b6       	in	r0, 0x3f	; 63
    2da2:	f8 94       	cli
    2da4:	de bf       	out	0x3e, r29	; 62
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	cd bf       	out	0x3d, r28	; 61

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2daa:	64 c0       	rjmp	.+200    	; 0x2e74 <prvSwitchTimerLists+0xe2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2dac:	80 91 a3 0c 	lds	r24, 0x0CA3
    2db0:	90 91 a4 0c 	lds	r25, 0x0CA4
    2db4:	fc 01       	movw	r30, r24
    2db6:	85 81       	ldd	r24, Z+5	; 0x05
    2db8:	96 81       	ldd	r25, Z+6	; 0x06
    2dba:	fc 01       	movw	r30, r24
    2dbc:	80 81       	ld	r24, Z
    2dbe:	91 81       	ldd	r25, Z+1	; 0x01
    2dc0:	9a 83       	std	Y+2, r25	; 0x02
    2dc2:	89 83       	std	Y+1, r24	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2dc4:	80 91 a3 0c 	lds	r24, 0x0CA3
    2dc8:	90 91 a4 0c 	lds	r25, 0x0CA4
    2dcc:	fc 01       	movw	r30, r24
    2dce:	85 81       	ldd	r24, Z+5	; 0x05
    2dd0:	96 81       	ldd	r25, Z+6	; 0x06
    2dd2:	fc 01       	movw	r30, r24
    2dd4:	86 81       	ldd	r24, Z+6	; 0x06
    2dd6:	97 81       	ldd	r25, Z+7	; 0x07
    2dd8:	9c 83       	std	Y+4, r25	; 0x04
    2dda:	8b 83       	std	Y+3, r24	; 0x03
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dde:	9c 81       	ldd	r25, Y+4	; 0x04
    2de0:	02 96       	adiw	r24, 0x02	; 2
    2de2:	0e 94 bd 01 	call	0x37a	; 0x37a <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2de6:	8b 81       	ldd	r24, Y+3	; 0x03
    2de8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dea:	fc 01       	movw	r30, r24
    2dec:	21 89       	ldd	r18, Z+17	; 0x11
    2dee:	32 89       	ldd	r19, Z+18	; 0x12
    2df0:	8b 81       	ldd	r24, Y+3	; 0x03
    2df2:	9c 81       	ldd	r25, Y+4	; 0x04
    2df4:	f9 01       	movw	r30, r18
    2df6:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2df8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfc:	fc 01       	movw	r30, r24
    2dfe:	86 85       	ldd	r24, Z+14	; 0x0e
    2e00:	81 30       	cpi	r24, 0x01	; 1
    2e02:	c1 f5       	brne	.+112    	; 0x2e74 <prvSwitchTimerLists+0xe2>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2e04:	8b 81       	ldd	r24, Y+3	; 0x03
    2e06:	9c 81       	ldd	r25, Y+4	; 0x04
    2e08:	fc 01       	movw	r30, r24
    2e0a:	24 85       	ldd	r18, Z+12	; 0x0c
    2e0c:	35 85       	ldd	r19, Z+13	; 0x0d
    2e0e:	89 81       	ldd	r24, Y+1	; 0x01
    2e10:	9a 81       	ldd	r25, Y+2	; 0x02
    2e12:	82 0f       	add	r24, r18
    2e14:	93 1f       	adc	r25, r19
    2e16:	9e 83       	std	Y+6, r25	; 0x06
    2e18:	8d 83       	std	Y+5, r24	; 0x05
			if( xReloadTime > xNextExpireTime )
    2e1a:	2d 81       	ldd	r18, Y+5	; 0x05
    2e1c:	3e 81       	ldd	r19, Y+6	; 0x06
    2e1e:	89 81       	ldd	r24, Y+1	; 0x01
    2e20:	9a 81       	ldd	r25, Y+2	; 0x02
    2e22:	82 17       	cp	r24, r18
    2e24:	93 07       	cpc	r25, r19
    2e26:	d8 f4       	brcc	.+54     	; 0x2e5e <prvSwitchTimerLists+0xcc>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2e28:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2c:	2d 81       	ldd	r18, Y+5	; 0x05
    2e2e:	3e 81       	ldd	r19, Y+6	; 0x06
    2e30:	fc 01       	movw	r30, r24
    2e32:	33 83       	std	Z+3, r19	; 0x03
    2e34:	22 83       	std	Z+2, r18	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2e36:	8b 81       	ldd	r24, Y+3	; 0x03
    2e38:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3a:	2b 81       	ldd	r18, Y+3	; 0x03
    2e3c:	3c 81       	ldd	r19, Y+4	; 0x04
    2e3e:	fc 01       	movw	r30, r24
    2e40:	31 87       	std	Z+9, r19	; 0x09
    2e42:	20 87       	std	Z+8, r18	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2e44:	8b 81       	ldd	r24, Y+3	; 0x03
    2e46:	9c 81       	ldd	r25, Y+4	; 0x04
    2e48:	9c 01       	movw	r18, r24
    2e4a:	2e 5f       	subi	r18, 0xFE	; 254
    2e4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4e:	80 91 a3 0c 	lds	r24, 0x0CA3
    2e52:	90 91 a4 0c 	lds	r25, 0x0CA4
    2e56:	b9 01       	movw	r22, r18
    2e58:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsert>
    2e5c:	0b c0       	rjmp	.+22     	; 0x2e74 <prvSwitchTimerLists+0xe2>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2e5e:	49 81       	ldd	r20, Y+1	; 0x01
    2e60:	5a 81       	ldd	r21, Y+2	; 0x02
    2e62:	8b 81       	ldd	r24, Y+3	; 0x03
    2e64:	9c 81       	ldd	r25, Y+4	; 0x04
    2e66:	00 e0       	ldi	r16, 0x00	; 0
    2e68:	10 e0       	ldi	r17, 0x00	; 0
    2e6a:	20 e0       	ldi	r18, 0x00	; 0
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	fb dc       	rcall	.-1546   	; 0x2868 <xTimerGenericCommand>
    2e72:	8f 83       	std	Y+7, r24	; 0x07

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2e74:	80 91 a3 0c 	lds	r24, 0x0CA3
    2e78:	90 91 a4 0c 	lds	r25, 0x0CA4
    2e7c:	fc 01       	movw	r30, r24
    2e7e:	80 81       	ld	r24, Z
    2e80:	88 23       	and	r24, r24
    2e82:	09 f0       	breq	.+2      	; 0x2e86 <prvSwitchTimerLists+0xf4>
    2e84:	93 cf       	rjmp	.-218    	; 0x2dac <prvSwitchTimerLists+0x1a>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
    2e86:	80 91 a3 0c 	lds	r24, 0x0CA3
    2e8a:	90 91 a4 0c 	lds	r25, 0x0CA4
    2e8e:	99 87       	std	Y+9, r25	; 0x09
    2e90:	88 87       	std	Y+8, r24	; 0x08
	pxCurrentTimerList = pxOverflowTimerList;
    2e92:	80 91 a5 0c 	lds	r24, 0x0CA5
    2e96:	90 91 a6 0c 	lds	r25, 0x0CA6
    2e9a:	90 93 a4 0c 	sts	0x0CA4, r25
    2e9e:	80 93 a3 0c 	sts	0x0CA3, r24
	pxOverflowTimerList = pxTemp;
    2ea2:	88 85       	ldd	r24, Y+8	; 0x08
    2ea4:	99 85       	ldd	r25, Y+9	; 0x09
    2ea6:	90 93 a6 0c 	sts	0x0CA6, r25
    2eaa:	80 93 a5 0c 	sts	0x0CA5, r24
}
    2eae:	29 96       	adiw	r28, 0x09	; 9
    2eb0:	0f b6       	in	r0, 0x3f	; 63
    2eb2:	f8 94       	cli
    2eb4:	de bf       	out	0x3e, r29	; 62
    2eb6:	0f be       	out	0x3f, r0	; 63
    2eb8:	cd bf       	out	0x3d, r28	; 61
    2eba:	df 91       	pop	r29
    2ebc:	cf 91       	pop	r28
    2ebe:	1f 91       	pop	r17
    2ec0:	0f 91       	pop	r16
    2ec2:	08 95       	ret

00002ec4 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	cd b7       	in	r28, 0x3d	; 61
    2eca:	de b7       	in	r29, 0x3e	; 62
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2ecc:	0f b6       	in	r0, 0x3f	; 63
    2ece:	f8 94       	cli
    2ed0:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2ed2:	80 91 a7 0c 	lds	r24, 0x0CA7
    2ed6:	90 91 a8 0c 	lds	r25, 0x0CA8
    2eda:	89 2b       	or	r24, r25
    2edc:	e9 f4       	brne	.+58     	; 0x2f18 <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
    2ede:	81 e9       	ldi	r24, 0x91	; 145
    2ee0:	9c e0       	ldi	r25, 0x0C	; 12
    2ee2:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2ee6:	8a e9       	ldi	r24, 0x9A	; 154
    2ee8:	9c e0       	ldi	r25, 0x0C	; 12
    2eea:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    2eee:	81 e9       	ldi	r24, 0x91	; 145
    2ef0:	9c e0       	ldi	r25, 0x0C	; 12
    2ef2:	90 93 a4 0c 	sts	0x0CA4, r25
    2ef6:	80 93 a3 0c 	sts	0x0CA3, r24
			pxOverflowTimerList = &xActiveTimerList2;
    2efa:	8a e9       	ldi	r24, 0x9A	; 154
    2efc:	9c e0       	ldi	r25, 0x0C	; 12
    2efe:	90 93 a6 0c 	sts	0x0CA6, r25
    2f02:	80 93 a5 0c 	sts	0x0CA5, r24
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2f06:	40 e0       	ldi	r20, 0x00	; 0
    2f08:	65 e0       	ldi	r22, 0x05	; 5
    2f0a:	81 e0       	ldi	r24, 0x01	; 1
    2f0c:	0e 94 f6 07 	call	0xfec	; 0xfec <xQueueGenericCreate>
    2f10:	90 93 a8 0c 	sts	0x0CA8, r25
    2f14:	80 93 a7 0c 	sts	0x0CA7, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2f18:	0f 90       	pop	r0
    2f1a:	0f be       	out	0x3f, r0	; 63
}
    2f1c:	df 91       	pop	r29
    2f1e:	cf 91       	pop	r28
    2f20:	08 95       	ret

00002f22 <vTimerCallback1>:
SemaphoreHandle_t xSemaphore3;
TimerHandle_t xTimer1;
TimerHandle_t xTimer2;
TimerHandle_t xTimer3;

void vTimerCallback1(TimerHandle_t pxTimer) {
    2f22:	cf 93       	push	r28
    2f24:	df 93       	push	r29
    2f26:	1f 92       	push	r1
    2f28:	1f 92       	push	r1
    2f2a:	cd b7       	in	r28, 0x3d	; 61
    2f2c:	de b7       	in	r29, 0x3e	; 62
    2f2e:	9a 83       	std	Y+2, r25	; 0x02
    2f30:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore1);
    2f32:	80 91 b1 0c 	lds	r24, 0x0CB1
    2f36:	90 91 b2 0c 	lds	r25, 0x0CB2
    2f3a:	20 e0       	ldi	r18, 0x00	; 0
    2f3c:	40 e0       	ldi	r20, 0x00	; 0
    2f3e:	50 e0       	ldi	r21, 0x00	; 0
    2f40:	60 e0       	ldi	r22, 0x00	; 0
    2f42:	70 e0       	ldi	r23, 0x00	; 0
    2f44:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
}
    2f48:	0f 90       	pop	r0
    2f4a:	0f 90       	pop	r0
    2f4c:	df 91       	pop	r29
    2f4e:	cf 91       	pop	r28
    2f50:	08 95       	ret

00002f52 <vTimerCallback2>:

void vTimerCallback2(TimerHandle_t pxTimer) {
    2f52:	cf 93       	push	r28
    2f54:	df 93       	push	r29
    2f56:	1f 92       	push	r1
    2f58:	1f 92       	push	r1
    2f5a:	cd b7       	in	r28, 0x3d	; 61
    2f5c:	de b7       	in	r29, 0x3e	; 62
    2f5e:	9a 83       	std	Y+2, r25	; 0x02
    2f60:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore2);
    2f62:	80 91 b5 0c 	lds	r24, 0x0CB5
    2f66:	90 91 b6 0c 	lds	r25, 0x0CB6
    2f6a:	20 e0       	ldi	r18, 0x00	; 0
    2f6c:	40 e0       	ldi	r20, 0x00	; 0
    2f6e:	50 e0       	ldi	r21, 0x00	; 0
    2f70:	60 e0       	ldi	r22, 0x00	; 0
    2f72:	70 e0       	ldi	r23, 0x00	; 0
    2f74:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
}
    2f78:	0f 90       	pop	r0
    2f7a:	0f 90       	pop	r0
    2f7c:	df 91       	pop	r29
    2f7e:	cf 91       	pop	r28
    2f80:	08 95       	ret

00002f82 <vTimerCallback3>:

void vTimerCallback3(TimerHandle_t pxTimer) {
    2f82:	cf 93       	push	r28
    2f84:	df 93       	push	r29
    2f86:	1f 92       	push	r1
    2f88:	1f 92       	push	r1
    2f8a:	cd b7       	in	r28, 0x3d	; 61
    2f8c:	de b7       	in	r29, 0x3e	; 62
    2f8e:	9a 83       	std	Y+2, r25	; 0x02
    2f90:	89 83       	std	Y+1, r24	; 0x01
	xSemaphoreGive(xSemaphore3);
    2f92:	80 91 af 0c 	lds	r24, 0x0CAF
    2f96:	90 91 b0 0c 	lds	r25, 0x0CB0
    2f9a:	20 e0       	ldi	r18, 0x00	; 0
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	50 e0       	ldi	r21, 0x00	; 0
    2fa0:	60 e0       	ldi	r22, 0x00	; 0
    2fa2:	70 e0       	ldi	r23, 0x00	; 0
    2fa4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
}
    2fa8:	0f 90       	pop	r0
    2faa:	0f 90       	pop	r0
    2fac:	df 91       	pop	r29
    2fae:	cf 91       	pop	r28
    2fb0:	08 95       	ret

00002fb2 <vTask1>:

void vTask1(void *pvParameters) {
    2fb2:	cf 93       	push	r28
    2fb4:	df 93       	push	r29
    2fb6:	00 d0       	rcall	.+0      	; 0x2fb8 <vTask1+0x6>
    2fb8:	1f 92       	push	r1
    2fba:	cd b7       	in	r28, 0x3d	; 61
    2fbc:	de b7       	in	r29, 0x3e	; 62
    2fbe:	9c 83       	std	Y+4, r25	; 0x04
    2fc0:	8b 83       	std	Y+3, r24	; 0x03
	while (1) {
		xSemaphoreTake(xSemaphore1, portMAX_DELAY);
    2fc2:	80 91 b1 0c 	lds	r24, 0x0CB1
    2fc6:	90 91 b2 0c 	lds	r25, 0x0CB2
    2fca:	20 e0       	ldi	r18, 0x00	; 0
    2fcc:	4f ef       	ldi	r20, 0xFF	; 255
    2fce:	5f ef       	ldi	r21, 0xFF	; 255
    2fd0:	60 e0       	ldi	r22, 0x00	; 0
    2fd2:	70 e0       	ldi	r23, 0x00	; 0
    2fd4:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xQueueGenericReceive>

		PORTA ^= 0b00000001;
    2fd8:	82 e2       	ldi	r24, 0x22	; 34
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	22 e2       	ldi	r18, 0x22	; 34
    2fde:	30 e0       	ldi	r19, 0x00	; 0
    2fe0:	f9 01       	movw	r30, r18
    2fe2:	30 81       	ld	r19, Z
    2fe4:	21 e0       	ldi	r18, 0x01	; 1
    2fe6:	23 27       	eor	r18, r19
    2fe8:	fc 01       	movw	r30, r24
    2fea:	20 83       	st	Z, r18
		int tmp = xTaskGetTickCount();
    2fec:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    2ff0:	9a 83       	std	Y+2, r25	; 0x02
    2ff2:	89 83       	std	Y+1, r24	; 0x01
		while(xTaskGetTickCount() < tmp + 1000){}
    2ff4:	00 00       	nop
    2ff6:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    2ffa:	9c 01       	movw	r18, r24
    2ffc:	89 81       	ldd	r24, Y+1	; 0x01
    2ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    3000:	88 51       	subi	r24, 0x18	; 24
    3002:	9c 4f       	sbci	r25, 0xFC	; 252
    3004:	28 17       	cp	r18, r24
    3006:	39 07       	cpc	r19, r25
    3008:	b0 f3       	brcs	.-20     	; 0x2ff6 <vTask1+0x44>
		PORTA ^= 0b00000001;
    300a:	82 e2       	ldi	r24, 0x22	; 34
    300c:	90 e0       	ldi	r25, 0x00	; 0
    300e:	22 e2       	ldi	r18, 0x22	; 34
    3010:	30 e0       	ldi	r19, 0x00	; 0
    3012:	f9 01       	movw	r30, r18
    3014:	30 81       	ld	r19, Z
    3016:	21 e0       	ldi	r18, 0x01	; 1
    3018:	23 27       	eor	r18, r19
    301a:	fc 01       	movw	r30, r24
    301c:	20 83       	st	Z, r18
	}
    301e:	d1 cf       	rjmp	.-94     	; 0x2fc2 <vTask1+0x10>

00003020 <vTask2>:
	vTaskDelete(NULL);
}

void vTask2(void *pvParameters) {
    3020:	cf 93       	push	r28
    3022:	df 93       	push	r29
    3024:	00 d0       	rcall	.+0      	; 0x3026 <vTask2+0x6>
    3026:	1f 92       	push	r1
    3028:	cd b7       	in	r28, 0x3d	; 61
    302a:	de b7       	in	r29, 0x3e	; 62
    302c:	9c 83       	std	Y+4, r25	; 0x04
    302e:	8b 83       	std	Y+3, r24	; 0x03
	while (1) {
		xSemaphoreTake(xSemaphore2, portMAX_DELAY);
    3030:	80 91 b5 0c 	lds	r24, 0x0CB5
    3034:	90 91 b6 0c 	lds	r25, 0x0CB6
    3038:	20 e0       	ldi	r18, 0x00	; 0
    303a:	4f ef       	ldi	r20, 0xFF	; 255
    303c:	5f ef       	ldi	r21, 0xFF	; 255
    303e:	60 e0       	ldi	r22, 0x00	; 0
    3040:	70 e0       	ldi	r23, 0x00	; 0
    3042:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xQueueGenericReceive>

		PORTA ^= 0b00000010;
    3046:	82 e2       	ldi	r24, 0x22	; 34
    3048:	90 e0       	ldi	r25, 0x00	; 0
    304a:	22 e2       	ldi	r18, 0x22	; 34
    304c:	30 e0       	ldi	r19, 0x00	; 0
    304e:	f9 01       	movw	r30, r18
    3050:	30 81       	ld	r19, Z
    3052:	22 e0       	ldi	r18, 0x02	; 2
    3054:	23 27       	eor	r18, r19
    3056:	fc 01       	movw	r30, r24
    3058:	20 83       	st	Z, r18
		int tmp = xTaskGetTickCount();
    305a:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    305e:	9a 83       	std	Y+2, r25	; 0x02
    3060:	89 83       	std	Y+1, r24	; 0x01
		while(xTaskGetTickCount() < tmp + 2000){}
    3062:	00 00       	nop
    3064:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    3068:	9c 01       	movw	r18, r24
    306a:	89 81       	ldd	r24, Y+1	; 0x01
    306c:	9a 81       	ldd	r25, Y+2	; 0x02
    306e:	80 53       	subi	r24, 0x30	; 48
    3070:	98 4f       	sbci	r25, 0xF8	; 248
    3072:	28 17       	cp	r18, r24
    3074:	39 07       	cpc	r19, r25
    3076:	b0 f3       	brcs	.-20     	; 0x3064 <vTask2+0x44>
		PORTA ^= 0b00000010;
    3078:	82 e2       	ldi	r24, 0x22	; 34
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	22 e2       	ldi	r18, 0x22	; 34
    307e:	30 e0       	ldi	r19, 0x00	; 0
    3080:	f9 01       	movw	r30, r18
    3082:	30 81       	ld	r19, Z
    3084:	22 e0       	ldi	r18, 0x02	; 2
    3086:	23 27       	eor	r18, r19
    3088:	fc 01       	movw	r30, r24
    308a:	20 83       	st	Z, r18
	}
    308c:	d1 cf       	rjmp	.-94     	; 0x3030 <vTask2+0x10>

0000308e <vTask3>:
	vTaskDelete(NULL);
}

void vTask3(void *pvParameters) {
    308e:	cf 93       	push	r28
    3090:	df 93       	push	r29
    3092:	00 d0       	rcall	.+0      	; 0x3094 <vTask3+0x6>
    3094:	1f 92       	push	r1
    3096:	cd b7       	in	r28, 0x3d	; 61
    3098:	de b7       	in	r29, 0x3e	; 62
    309a:	9c 83       	std	Y+4, r25	; 0x04
    309c:	8b 83       	std	Y+3, r24	; 0x03
	while (1) {
		xSemaphoreTake(xSemaphore3, portMAX_DELAY);
    309e:	80 91 af 0c 	lds	r24, 0x0CAF
    30a2:	90 91 b0 0c 	lds	r25, 0x0CB0
    30a6:	20 e0       	ldi	r18, 0x00	; 0
    30a8:	4f ef       	ldi	r20, 0xFF	; 255
    30aa:	5f ef       	ldi	r21, 0xFF	; 255
    30ac:	60 e0       	ldi	r22, 0x00	; 0
    30ae:	70 e0       	ldi	r23, 0x00	; 0
    30b0:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xQueueGenericReceive>

		PORTA ^= 0b00000100;
    30b4:	82 e2       	ldi	r24, 0x22	; 34
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	22 e2       	ldi	r18, 0x22	; 34
    30ba:	30 e0       	ldi	r19, 0x00	; 0
    30bc:	f9 01       	movw	r30, r18
    30be:	30 81       	ld	r19, Z
    30c0:	24 e0       	ldi	r18, 0x04	; 4
    30c2:	23 27       	eor	r18, r19
    30c4:	fc 01       	movw	r30, r24
    30c6:	20 83       	st	Z, r18
		int tmp = xTaskGetTickCount();
    30c8:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    30cc:	9a 83       	std	Y+2, r25	; 0x02
    30ce:	89 83       	std	Y+1, r24	; 0x01
		while(xTaskGetTickCount() < tmp + 2000){}
    30d0:	00 00       	nop
    30d2:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    30d6:	9c 01       	movw	r18, r24
    30d8:	89 81       	ldd	r24, Y+1	; 0x01
    30da:	9a 81       	ldd	r25, Y+2	; 0x02
    30dc:	80 53       	subi	r24, 0x30	; 48
    30de:	98 4f       	sbci	r25, 0xF8	; 248
    30e0:	28 17       	cp	r18, r24
    30e2:	39 07       	cpc	r19, r25
    30e4:	b0 f3       	brcs	.-20     	; 0x30d2 <vTask3+0x44>
		PORTA ^= 0b00000100;
    30e6:	82 e2       	ldi	r24, 0x22	; 34
    30e8:	90 e0       	ldi	r25, 0x00	; 0
    30ea:	22 e2       	ldi	r18, 0x22	; 34
    30ec:	30 e0       	ldi	r19, 0x00	; 0
    30ee:	f9 01       	movw	r30, r18
    30f0:	30 81       	ld	r19, Z
    30f2:	24 e0       	ldi	r18, 0x04	; 4
    30f4:	23 27       	eor	r18, r19
    30f6:	fc 01       	movw	r30, r24
    30f8:	20 83       	st	Z, r18
	}
    30fa:	d1 cf       	rjmp	.-94     	; 0x309e <vTask3+0x10>

000030fc <vControlTask>:
	vTaskDelete(NULL);
}

void vControlTask(void *pvParameters) {
    30fc:	0f 93       	push	r16
    30fe:	1f 93       	push	r17
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	1f 92       	push	r1
    3106:	1f 92       	push	r1
    3108:	cd b7       	in	r28, 0x3d	; 61
    310a:	de b7       	in	r29, 0x3e	; 62
    310c:	9a 83       	std	Y+2, r25	; 0x02
    310e:	89 83       	std	Y+1, r24	; 0x01
	vTaskDelay(1000);
    3110:	88 ee       	ldi	r24, 0xE8	; 232
    3112:	93 e0       	ldi	r25, 0x03	; 3
    3114:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vTaskDelay>
	xSemaphoreGive(xSemaphore3);
    3118:	80 91 af 0c 	lds	r24, 0x0CAF
    311c:	90 91 b0 0c 	lds	r25, 0x0CB0
    3120:	20 e0       	ldi	r18, 0x00	; 0
    3122:	40 e0       	ldi	r20, 0x00	; 0
    3124:	50 e0       	ldi	r21, 0x00	; 0
    3126:	60 e0       	ldi	r22, 0x00	; 0
    3128:	70 e0       	ldi	r23, 0x00	; 0
    312a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
	xTimerStart(xTimer3, 0);
    312e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    3132:	ac 01       	movw	r20, r24
    3134:	80 91 b9 0c 	lds	r24, 0x0CB9
    3138:	90 91 ba 0c 	lds	r25, 0x0CBA
    313c:	00 e0       	ldi	r16, 0x00	; 0
    313e:	10 e0       	ldi	r17, 0x00	; 0
    3140:	20 e0       	ldi	r18, 0x00	; 0
    3142:	30 e0       	ldi	r19, 0x00	; 0
    3144:	61 e0       	ldi	r22, 0x01	; 1
    3146:	90 db       	rcall	.-2272   	; 0x2868 <xTimerGenericCommand>
	vTaskDelay(2000);
    3148:	80 ed       	ldi	r24, 0xD0	; 208
    314a:	97 e0       	ldi	r25, 0x07	; 7
    314c:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vTaskDelay>
	xSemaphoreGive(xSemaphore2);
    3150:	80 91 b5 0c 	lds	r24, 0x0CB5
    3154:	90 91 b6 0c 	lds	r25, 0x0CB6
    3158:	20 e0       	ldi	r18, 0x00	; 0
    315a:	40 e0       	ldi	r20, 0x00	; 0
    315c:	50 e0       	ldi	r21, 0x00	; 0
    315e:	60 e0       	ldi	r22, 0x00	; 0
    3160:	70 e0       	ldi	r23, 0x00	; 0
    3162:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
	xTimerStart(xTimer2, 0);
    3166:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    316a:	ac 01       	movw	r20, r24
    316c:	80 91 b3 0c 	lds	r24, 0x0CB3
    3170:	90 91 b4 0c 	lds	r25, 0x0CB4
    3174:	00 e0       	ldi	r16, 0x00	; 0
    3176:	10 e0       	ldi	r17, 0x00	; 0
    3178:	20 e0       	ldi	r18, 0x00	; 0
    317a:	30 e0       	ldi	r19, 0x00	; 0
    317c:	61 e0       	ldi	r22, 0x01	; 1
    317e:	74 db       	rcall	.-2328   	; 0x2868 <xTimerGenericCommand>
	vTaskDelay(2000);
    3180:	80 ed       	ldi	r24, 0xD0	; 208
    3182:	97 e0       	ldi	r25, 0x07	; 7
    3184:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vTaskDelay>
	xSemaphoreGive(xSemaphore1);
    3188:	80 91 b1 0c 	lds	r24, 0x0CB1
    318c:	90 91 b2 0c 	lds	r25, 0x0CB2
    3190:	20 e0       	ldi	r18, 0x00	; 0
    3192:	40 e0       	ldi	r20, 0x00	; 0
    3194:	50 e0       	ldi	r21, 0x00	; 0
    3196:	60 e0       	ldi	r22, 0x00	; 0
    3198:	70 e0       	ldi	r23, 0x00	; 0
    319a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <xQueueGenericSend>
	xTimerStart(xTimer1, 0);
    319e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGetTickCount>
    31a2:	ac 01       	movw	r20, r24
    31a4:	80 91 b7 0c 	lds	r24, 0x0CB7
    31a8:	90 91 b8 0c 	lds	r25, 0x0CB8
    31ac:	00 e0       	ldi	r16, 0x00	; 0
    31ae:	10 e0       	ldi	r17, 0x00	; 0
    31b0:	20 e0       	ldi	r18, 0x00	; 0
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	61 e0       	ldi	r22, 0x01	; 1
    31b6:	58 db       	rcall	.-2384   	; 0x2868 <xTimerGenericCommand>
		
	vTaskDelete(NULL);
    31b8:	80 e0       	ldi	r24, 0x00	; 0
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <vTaskDelete>
}
    31c0:	0f 90       	pop	r0
    31c2:	0f 90       	pop	r0
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	1f 91       	pop	r17
    31ca:	0f 91       	pop	r16
    31cc:	08 95       	ret

000031ce <main>:

int main( void )
{
    31ce:	af 92       	push	r10
    31d0:	bf 92       	push	r11
    31d2:	cf 92       	push	r12
    31d4:	df 92       	push	r13
    31d6:	ef 92       	push	r14
    31d8:	ff 92       	push	r15
    31da:	0f 93       	push	r16
    31dc:	1f 93       	push	r17
    31de:	cf 93       	push	r28
    31e0:	df 93       	push	r29
    31e2:	cd b7       	in	r28, 0x3d	; 61
    31e4:	de b7       	in	r29, 0x3e	; 62
	DDRA = 0xff;
    31e6:	81 e2       	ldi	r24, 0x21	; 33
    31e8:	90 e0       	ldi	r25, 0x00	; 0
    31ea:	2f ef       	ldi	r18, 0xFF	; 255
    31ec:	fc 01       	movw	r30, r24
    31ee:	20 83       	st	Z, r18
	PORTA = 0xff;
    31f0:	82 e2       	ldi	r24, 0x22	; 34
    31f2:	90 e0       	ldi	r25, 0x00	; 0
    31f4:	2f ef       	ldi	r18, 0xFF	; 255
    31f6:	fc 01       	movw	r30, r24
    31f8:	20 83       	st	Z, r18
	
	xSemaphore1 = xSemaphoreCreateCounting(20, 0);
    31fa:	60 e0       	ldi	r22, 0x00	; 0
    31fc:	84 e1       	ldi	r24, 0x14	; 20
    31fe:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xQueueCreateCountingSemaphore>
    3202:	90 93 b2 0c 	sts	0x0CB2, r25
    3206:	80 93 b1 0c 	sts	0x0CB1, r24
	xSemaphore2 = xSemaphoreCreateCounting(20, 0);
    320a:	60 e0       	ldi	r22, 0x00	; 0
    320c:	84 e1       	ldi	r24, 0x14	; 20
    320e:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xQueueCreateCountingSemaphore>
    3212:	90 93 b6 0c 	sts	0x0CB6, r25
    3216:	80 93 b5 0c 	sts	0x0CB5, r24
	xSemaphore3 = xSemaphoreCreateCounting(20, 0);
    321a:	60 e0       	ldi	r22, 0x00	; 0
    321c:	84 e1       	ldi	r24, 0x14	; 20
    321e:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xQueueCreateCountingSemaphore>
    3222:	90 93 b0 0c 	sts	0x0CB0, r25
    3226:	80 93 af 0c 	sts	0x0CAF, r24

	xTimer1 = xTimerCreate("Timer 1", ( 5000 ), pdTRUE, 1, vTimerCallback1);
    322a:	01 e9       	ldi	r16, 0x91	; 145
    322c:	17 e1       	ldi	r17, 0x17	; 23
    322e:	21 e0       	ldi	r18, 0x01	; 1
    3230:	30 e0       	ldi	r19, 0x00	; 0
    3232:	41 e0       	ldi	r20, 0x01	; 1
    3234:	68 e8       	ldi	r22, 0x88	; 136
    3236:	73 e1       	ldi	r23, 0x13	; 19
    3238:	8f e0       	ldi	r24, 0x0F	; 15
    323a:	92 e0       	ldi	r25, 0x02	; 2
    323c:	bb da       	rcall	.-2698   	; 0x27b4 <xTimerCreate>
    323e:	90 93 b8 0c 	sts	0x0CB8, r25
    3242:	80 93 b7 0c 	sts	0x0CB7, r24
	xTimer2 = xTimerCreate("Timer 2", ( 10000 ), pdTRUE, 1, vTimerCallback2);
    3246:	09 ea       	ldi	r16, 0xA9	; 169
    3248:	17 e1       	ldi	r17, 0x17	; 23
    324a:	21 e0       	ldi	r18, 0x01	; 1
    324c:	30 e0       	ldi	r19, 0x00	; 0
    324e:	41 e0       	ldi	r20, 0x01	; 1
    3250:	60 e1       	ldi	r22, 0x10	; 16
    3252:	77 e2       	ldi	r23, 0x27	; 39
    3254:	87 e1       	ldi	r24, 0x17	; 23
    3256:	92 e0       	ldi	r25, 0x02	; 2
    3258:	ad da       	rcall	.-2726   	; 0x27b4 <xTimerCreate>
    325a:	90 93 b4 0c 	sts	0x0CB4, r25
    325e:	80 93 b3 0c 	sts	0x0CB3, r24
	xTimer3 = xTimerCreate("Timer 3", ( 8000 ), pdTRUE, 1, vTimerCallback3);
    3262:	01 ec       	ldi	r16, 0xC1	; 193
    3264:	17 e1       	ldi	r17, 0x17	; 23
    3266:	21 e0       	ldi	r18, 0x01	; 1
    3268:	30 e0       	ldi	r19, 0x00	; 0
    326a:	41 e0       	ldi	r20, 0x01	; 1
    326c:	60 e4       	ldi	r22, 0x40	; 64
    326e:	7f e1       	ldi	r23, 0x1F	; 31
    3270:	8f e1       	ldi	r24, 0x1F	; 31
    3272:	92 e0       	ldi	r25, 0x02	; 2
    3274:	9f da       	rcall	.-2754   	; 0x27b4 <xTimerCreate>
    3276:	90 93 ba 0c 	sts	0x0CBA, r25
    327a:	80 93 b9 0c 	sts	0x0CB9, r24
	
	xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    327e:	a1 2c       	mov	r10, r1
    3280:	b1 2c       	mov	r11, r1
    3282:	c1 2c       	mov	r12, r1
    3284:	d1 2c       	mov	r13, r1
    3286:	e1 2c       	mov	r14, r1
    3288:	f1 2c       	mov	r15, r1
    328a:	01 e0       	ldi	r16, 0x01	; 1
    328c:	20 e0       	ldi	r18, 0x00	; 0
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	49 eb       	ldi	r20, 0xB9	; 185
    3292:	50 e0       	ldi	r21, 0x00	; 0
    3294:	67 e2       	ldi	r22, 0x27	; 39
    3296:	72 e0       	ldi	r23, 0x02	; 2
    3298:	89 ed       	ldi	r24, 0xD9	; 217
    329a:	97 e1       	ldi	r25, 0x17	; 23
    329c:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGenericCreate>
	xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    32a0:	a1 2c       	mov	r10, r1
    32a2:	b1 2c       	mov	r11, r1
    32a4:	c1 2c       	mov	r12, r1
    32a6:	d1 2c       	mov	r13, r1
    32a8:	e1 2c       	mov	r14, r1
    32aa:	f1 2c       	mov	r15, r1
    32ac:	01 e0       	ldi	r16, 0x01	; 1
    32ae:	20 e0       	ldi	r18, 0x00	; 0
    32b0:	30 e0       	ldi	r19, 0x00	; 0
    32b2:	49 eb       	ldi	r20, 0xB9	; 185
    32b4:	50 e0       	ldi	r21, 0x00	; 0
    32b6:	6e e2       	ldi	r22, 0x2E	; 46
    32b8:	72 e0       	ldi	r23, 0x02	; 2
    32ba:	80 e1       	ldi	r24, 0x10	; 16
    32bc:	98 e1       	ldi	r25, 0x18	; 24
    32be:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGenericCreate>
	xTaskCreate(vTask3, "Task 3", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    32c2:	a1 2c       	mov	r10, r1
    32c4:	b1 2c       	mov	r11, r1
    32c6:	c1 2c       	mov	r12, r1
    32c8:	d1 2c       	mov	r13, r1
    32ca:	e1 2c       	mov	r14, r1
    32cc:	f1 2c       	mov	r15, r1
    32ce:	01 e0       	ldi	r16, 0x01	; 1
    32d0:	20 e0       	ldi	r18, 0x00	; 0
    32d2:	30 e0       	ldi	r19, 0x00	; 0
    32d4:	49 eb       	ldi	r20, 0xB9	; 185
    32d6:	50 e0       	ldi	r21, 0x00	; 0
    32d8:	65 e3       	ldi	r22, 0x35	; 53
    32da:	72 e0       	ldi	r23, 0x02	; 2
    32dc:	87 e4       	ldi	r24, 0x47	; 71
    32de:	98 e1       	ldi	r25, 0x18	; 24
    32e0:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGenericCreate>
	xTaskCreate(vControlTask, "Control", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    32e4:	a1 2c       	mov	r10, r1
    32e6:	b1 2c       	mov	r11, r1
    32e8:	c1 2c       	mov	r12, r1
    32ea:	d1 2c       	mov	r13, r1
    32ec:	e1 2c       	mov	r14, r1
    32ee:	f1 2c       	mov	r15, r1
    32f0:	02 e0       	ldi	r16, 0x02	; 2
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	49 eb       	ldi	r20, 0xB9	; 185
    32f8:	50 e0       	ldi	r21, 0x00	; 0
    32fa:	6c e3       	ldi	r22, 0x3C	; 60
    32fc:	72 e0       	ldi	r23, 0x02	; 2
    32fe:	8e e7       	ldi	r24, 0x7E	; 126
    3300:	98 e1       	ldi	r25, 0x18	; 24
    3302:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGenericCreate>

	vTaskStartScheduler();
    3306:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <vTaskStartScheduler>

	return 0;
    330a:	80 e0       	ldi	r24, 0x00	; 0
    330c:	90 e0       	ldi	r25, 0x00	; 0
}
    330e:	df 91       	pop	r29
    3310:	cf 91       	pop	r28
    3312:	1f 91       	pop	r17
    3314:	0f 91       	pop	r16
    3316:	ff 90       	pop	r15
    3318:	ef 90       	pop	r14
    331a:	df 90       	pop	r13
    331c:	cf 90       	pop	r12
    331e:	bf 90       	pop	r11
    3320:	af 90       	pop	r10
    3322:	08 95       	ret

00003324 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
    3324:	cf 93       	push	r28
    3326:	df 93       	push	r29
    3328:	cd b7       	in	r28, 0x3d	; 61
    332a:	de b7       	in	r29, 0x3e	; 62
	vCoRoutineSchedule();
    332c:	0e 94 10 03 	call	0x620	; 0x620 <vCoRoutineSchedule>
}
    3330:	df 91       	pop	r29
    3332:	cf 91       	pop	r28
    3334:	08 95       	ret

00003336 <__vector_default>:

ISR(BADISR_vect)
{
    3336:	1f 92       	push	r1
    3338:	0f 92       	push	r0
    333a:	00 90 5f 00 	lds	r0, 0x005F
    333e:	0f 92       	push	r0
    3340:	11 24       	eor	r1, r1
    3342:	00 90 5b 00 	lds	r0, 0x005B
    3346:	0f 92       	push	r0
    3348:	2f 93       	push	r18
    334a:	3f 93       	push	r19
    334c:	8f 93       	push	r24
    334e:	9f 93       	push	r25
    3350:	ef 93       	push	r30
    3352:	ff 93       	push	r31
    3354:	cf 93       	push	r28
    3356:	df 93       	push	r29
    3358:	cd b7       	in	r28, 0x3d	; 61
    335a:	de b7       	in	r29, 0x3e	; 62
	PORTA &= ~_BV(PA1);
    335c:	82 e2       	ldi	r24, 0x22	; 34
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	22 e2       	ldi	r18, 0x22	; 34
    3362:	30 e0       	ldi	r19, 0x00	; 0
    3364:	f9 01       	movw	r30, r18
    3366:	20 81       	ld	r18, Z
    3368:	2d 7f       	andi	r18, 0xFD	; 253
    336a:	fc 01       	movw	r30, r24
    336c:	20 83       	st	Z, r18
}
    336e:	df 91       	pop	r29
    3370:	cf 91       	pop	r28
    3372:	ff 91       	pop	r31
    3374:	ef 91       	pop	r30
    3376:	9f 91       	pop	r25
    3378:	8f 91       	pop	r24
    337a:	3f 91       	pop	r19
    337c:	2f 91       	pop	r18
    337e:	0f 90       	pop	r0
    3380:	00 92 5b 00 	sts	0x005B, r0
    3384:	0f 90       	pop	r0
    3386:	00 92 5f 00 	sts	0x005F, r0
    338a:	0f 90       	pop	r0
    338c:	1f 90       	pop	r1
    338e:	18 95       	reti

00003390 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    3390:	cf 93       	push	r28
    3392:	df 93       	push	r29
    3394:	00 d0       	rcall	.+0      	; 0x3396 <vApplicationStackOverflowHook+0x6>
    3396:	1f 92       	push	r1
    3398:	cd b7       	in	r28, 0x3d	; 61
    339a:	de b7       	in	r29, 0x3e	; 62
    339c:	9a 83       	std	Y+2, r25	; 0x02
    339e:	89 83       	std	Y+1, r24	; 0x01
    33a0:	7c 83       	std	Y+4, r23	; 0x04
    33a2:	6b 83       	std	Y+3, r22	; 0x03
	PORTA |= _BV(PA7);
    33a4:	82 e2       	ldi	r24, 0x22	; 34
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	22 e2       	ldi	r18, 0x22	; 34
    33aa:	30 e0       	ldi	r19, 0x00	; 0
    33ac:	f9 01       	movw	r30, r18
    33ae:	20 81       	ld	r18, Z
    33b0:	20 68       	ori	r18, 0x80	; 128
    33b2:	fc 01       	movw	r30, r24
    33b4:	20 83       	st	Z, r18
    33b6:	0f 90       	pop	r0
    33b8:	0f 90       	pop	r0
    33ba:	0f 90       	pop	r0
    33bc:	0f 90       	pop	r0
    33be:	df 91       	pop	r29
    33c0:	cf 91       	pop	r28
    33c2:	08 95       	ret

000033c4 <__vector_25>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
ISR(USART0_RX_vect)
{
    33c4:	1f 92       	push	r1
    33c6:	0f 92       	push	r0
    33c8:	00 90 5f 00 	lds	r0, 0x005F
    33cc:	0f 92       	push	r0
    33ce:	11 24       	eor	r1, r1
    33d0:	00 90 5b 00 	lds	r0, 0x005B
    33d4:	0f 92       	push	r0
    33d6:	2f 93       	push	r18
    33d8:	3f 93       	push	r19
    33da:	4f 93       	push	r20
    33dc:	5f 93       	push	r21
    33de:	6f 93       	push	r22
    33e0:	7f 93       	push	r23
    33e2:	8f 93       	push	r24
    33e4:	9f 93       	push	r25
    33e6:	af 93       	push	r26
    33e8:	bf 93       	push	r27
    33ea:	ef 93       	push	r30
    33ec:	ff 93       	push	r31
    33ee:	cf 93       	push	r28
    33f0:	df 93       	push	r29
    33f2:	1f 92       	push	r1
    33f4:	1f 92       	push	r1
    33f6:	cd b7       	in	r28, 0x3d	; 61
    33f8:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    33fa:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    33fc:	86 ec       	ldi	r24, 0xC6	; 198
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	fc 01       	movw	r30, r24
    3402:	80 81       	ld	r24, Z
    3404:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    3406:	80 91 ab 0c 	lds	r24, 0x0CAB
    340a:	90 91 ac 0c 	lds	r25, 0x0CAC
    340e:	ae 01       	movw	r20, r28
    3410:	4e 5f       	subi	r20, 0xFE	; 254
    3412:	5f 4f       	sbci	r21, 0xFF	; 255
    3414:	20 e0       	ldi	r18, 0x00	; 0
    3416:	be 01       	movw	r22, r28
    3418:	6f 5f       	subi	r22, 0xFF	; 255
    341a:	7f 4f       	sbci	r23, 0xFF	; 255
    341c:	0e 94 21 09 	call	0x1242	; 0x1242 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    3420:	8a 81       	ldd	r24, Y+2	; 0x02
    3422:	88 23       	and	r24, r24
    3424:	11 f0       	breq	.+4      	; 0x342a <__vector_25+0x66>
	{
		taskYIELD();
    3426:	0e 94 8e 05 	call	0xb1c	; 0xb1c <vPortYield>
	}
}
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	df 91       	pop	r29
    3430:	cf 91       	pop	r28
    3432:	ff 91       	pop	r31
    3434:	ef 91       	pop	r30
    3436:	bf 91       	pop	r27
    3438:	af 91       	pop	r26
    343a:	9f 91       	pop	r25
    343c:	8f 91       	pop	r24
    343e:	7f 91       	pop	r23
    3440:	6f 91       	pop	r22
    3442:	5f 91       	pop	r21
    3444:	4f 91       	pop	r20
    3446:	3f 91       	pop	r19
    3448:	2f 91       	pop	r18
    344a:	0f 90       	pop	r0
    344c:	00 92 5b 00 	sts	0x005B, r0
    3450:	0f 90       	pop	r0
    3452:	00 92 5f 00 	sts	0x005F, r0
    3456:	0f 90       	pop	r0
    3458:	1f 90       	pop	r1
    345a:	18 95       	reti

0000345c <__vector_26>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
ISR(USART0_UDRE_vect)
{
    345c:	1f 92       	push	r1
    345e:	0f 92       	push	r0
    3460:	00 90 5f 00 	lds	r0, 0x005F
    3464:	0f 92       	push	r0
    3466:	11 24       	eor	r1, r1
    3468:	00 90 5b 00 	lds	r0, 0x005B
    346c:	0f 92       	push	r0
    346e:	2f 93       	push	r18
    3470:	3f 93       	push	r19
    3472:	4f 93       	push	r20
    3474:	5f 93       	push	r21
    3476:	6f 93       	push	r22
    3478:	7f 93       	push	r23
    347a:	8f 93       	push	r24
    347c:	9f 93       	push	r25
    347e:	af 93       	push	r26
    3480:	bf 93       	push	r27
    3482:	ef 93       	push	r30
    3484:	ff 93       	push	r31
    3486:	cf 93       	push	r28
    3488:	df 93       	push	r29
    348a:	00 d0       	rcall	.+0      	; 0x348c <__vector_26+0x30>
    348c:	cd b7       	in	r28, 0x3d	; 61
    348e:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    3490:	80 91 ad 0c 	lds	r24, 0x0CAD
    3494:	90 91 ae 0c 	lds	r25, 0x0CAE
    3498:	ae 01       	movw	r20, r28
    349a:	4d 5f       	subi	r20, 0xFD	; 253
    349c:	5f 4f       	sbci	r21, 0xFF	; 255
    349e:	9e 01       	movw	r18, r28
    34a0:	2e 5f       	subi	r18, 0xFE	; 254
    34a2:	3f 4f       	sbci	r19, 0xFF	; 255
    34a4:	b9 01       	movw	r22, r18
    34a6:	0e 94 3d 0a 	call	0x147a	; 0x147a <xQueueReceiveFromISR>
    34aa:	81 30       	cpi	r24, 0x01	; 1
    34ac:	31 f4       	brne	.+12     	; 0x34ba <__vector_26+0x5e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    34ae:	86 ec       	ldi	r24, 0xC6	; 198
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	2a 81       	ldd	r18, Y+2	; 0x02
    34b4:	fc 01       	movw	r30, r24
    34b6:	20 83       	st	Z, r18
    34b8:	0d c0       	rjmp	.+26     	; 0x34d4 <__vector_26+0x78>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    34ba:	81 ec       	ldi	r24, 0xC1	; 193
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	fc 01       	movw	r30, r24
    34c0:	80 81       	ld	r24, Z
    34c2:	89 83       	std	Y+1, r24	; 0x01
    34c4:	89 81       	ldd	r24, Y+1	; 0x01
    34c6:	8f 7d       	andi	r24, 0xDF	; 223
    34c8:	89 83       	std	Y+1, r24	; 0x01
    34ca:	81 ec       	ldi	r24, 0xC1	; 193
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	29 81       	ldd	r18, Y+1	; 0x01
    34d0:	fc 01       	movw	r30, r24
    34d2:	20 83       	st	Z, r18
	}
}
    34d4:	0f 90       	pop	r0
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	df 91       	pop	r29
    34dc:	cf 91       	pop	r28
    34de:	ff 91       	pop	r31
    34e0:	ef 91       	pop	r30
    34e2:	bf 91       	pop	r27
    34e4:	af 91       	pop	r26
    34e6:	9f 91       	pop	r25
    34e8:	8f 91       	pop	r24
    34ea:	7f 91       	pop	r23
    34ec:	6f 91       	pop	r22
    34ee:	5f 91       	pop	r21
    34f0:	4f 91       	pop	r20
    34f2:	3f 91       	pop	r19
    34f4:	2f 91       	pop	r18
    34f6:	0f 90       	pop	r0
    34f8:	00 92 5b 00 	sts	0x005B, r0
    34fc:	0f 90       	pop	r0
    34fe:	00 92 5f 00 	sts	0x005F, r0
    3502:	0f 90       	pop	r0
    3504:	1f 90       	pop	r1
    3506:	18 95       	reti

00003508 <__udivmodsi4>:
    3508:	a1 e2       	ldi	r26, 0x21	; 33
    350a:	1a 2e       	mov	r1, r26
    350c:	aa 1b       	sub	r26, r26
    350e:	bb 1b       	sub	r27, r27
    3510:	fd 01       	movw	r30, r26
    3512:	0d c0       	rjmp	.+26     	; 0x352e <__udivmodsi4_ep>

00003514 <__udivmodsi4_loop>:
    3514:	aa 1f       	adc	r26, r26
    3516:	bb 1f       	adc	r27, r27
    3518:	ee 1f       	adc	r30, r30
    351a:	ff 1f       	adc	r31, r31
    351c:	a2 17       	cp	r26, r18
    351e:	b3 07       	cpc	r27, r19
    3520:	e4 07       	cpc	r30, r20
    3522:	f5 07       	cpc	r31, r21
    3524:	20 f0       	brcs	.+8      	; 0x352e <__udivmodsi4_ep>
    3526:	a2 1b       	sub	r26, r18
    3528:	b3 0b       	sbc	r27, r19
    352a:	e4 0b       	sbc	r30, r20
    352c:	f5 0b       	sbc	r31, r21

0000352e <__udivmodsi4_ep>:
    352e:	66 1f       	adc	r22, r22
    3530:	77 1f       	adc	r23, r23
    3532:	88 1f       	adc	r24, r24
    3534:	99 1f       	adc	r25, r25
    3536:	1a 94       	dec	r1
    3538:	69 f7       	brne	.-38     	; 0x3514 <__udivmodsi4_loop>
    353a:	60 95       	com	r22
    353c:	70 95       	com	r23
    353e:	80 95       	com	r24
    3540:	90 95       	com	r25
    3542:	9b 01       	movw	r18, r22
    3544:	ac 01       	movw	r20, r24
    3546:	bd 01       	movw	r22, r26
    3548:	cf 01       	movw	r24, r30
    354a:	08 95       	ret

0000354c <__tablejump2__>:
    354c:	ee 0f       	add	r30, r30
    354e:	ff 1f       	adc	r31, r31
    3550:	88 1f       	adc	r24, r24
    3552:	8b bf       	out	0x3b, r24	; 59
    3554:	07 90       	elpm	r0, Z+
    3556:	f6 91       	elpm	r31, Z
    3558:	e0 2d       	mov	r30, r0
    355a:	19 94       	eijmp

0000355c <memcpy>:
    355c:	fb 01       	movw	r30, r22
    355e:	dc 01       	movw	r26, r24
    3560:	02 c0       	rjmp	.+4      	; 0x3566 <memcpy+0xa>
    3562:	01 90       	ld	r0, Z+
    3564:	0d 92       	st	X+, r0
    3566:	41 50       	subi	r20, 0x01	; 1
    3568:	50 40       	sbci	r21, 0x00	; 0
    356a:	d8 f7       	brcc	.-10     	; 0x3562 <memcpy+0x6>
    356c:	08 95       	ret

0000356e <_exit>:
    356e:	f8 94       	cli

00003570 <__stop_program>:
    3570:	ff cf       	rjmp	.-2      	; 0x3570 <__stop_program>
