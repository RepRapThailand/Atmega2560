
FreeRTOS_VIA2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800200  0000221c  000022b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000221c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c45  00800216  00800216  000022c6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000022c6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000022f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000398  00000000  00000000  00002338  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002ad2  00000000  00000000  000026d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009ec  00000000  00000000  000051a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002b01  00000000  00000000  00005b8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d30  00000000  00000000  00008690  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001432  00000000  00000000  000093c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001b94  00000000  00000000  0000a7f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000330  00000000  00000000  0000c386  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	83 c0       	rjmp	.+262    	; 0x108 <__ctors_end>
       2:	00 00       	nop
       4:	a2 c0       	rjmp	.+324    	; 0x14a <__bad_interrupt>
       6:	00 00       	nop
       8:	a0 c0       	rjmp	.+320    	; 0x14a <__bad_interrupt>
       a:	00 00       	nop
       c:	9e c0       	rjmp	.+316    	; 0x14a <__bad_interrupt>
       e:	00 00       	nop
      10:	9c c0       	rjmp	.+312    	; 0x14a <__bad_interrupt>
      12:	00 00       	nop
      14:	9a c0       	rjmp	.+308    	; 0x14a <__bad_interrupt>
      16:	00 00       	nop
      18:	98 c0       	rjmp	.+304    	; 0x14a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	96 c0       	rjmp	.+300    	; 0x14a <__bad_interrupt>
      1e:	00 00       	nop
      20:	94 c0       	rjmp	.+296    	; 0x14a <__bad_interrupt>
      22:	00 00       	nop
      24:	92 c0       	rjmp	.+292    	; 0x14a <__bad_interrupt>
      26:	00 00       	nop
      28:	90 c0       	rjmp	.+288    	; 0x14a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8e c0       	rjmp	.+284    	; 0x14a <__bad_interrupt>
      2e:	00 00       	nop
      30:	8c c0       	rjmp	.+280    	; 0x14a <__bad_interrupt>
      32:	00 00       	nop
      34:	8a c0       	rjmp	.+276    	; 0x14a <__bad_interrupt>
      36:	00 00       	nop
      38:	88 c0       	rjmp	.+272    	; 0x14a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	86 c0       	rjmp	.+268    	; 0x14a <__bad_interrupt>
      3e:	00 00       	nop
      40:	84 c0       	rjmp	.+264    	; 0x14a <__bad_interrupt>
      42:	00 00       	nop
      44:	82 c0       	rjmp	.+260    	; 0x14a <__bad_interrupt>
      46:	00 00       	nop
      48:	80 c0       	rjmp	.+256    	; 0x14a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7e c0       	rjmp	.+252    	; 0x14a <__bad_interrupt>
      4e:	00 00       	nop
      50:	7c c0       	rjmp	.+248    	; 0x14a <__bad_interrupt>
      52:	00 00       	nop
      54:	7a c0       	rjmp	.+244    	; 0x14a <__bad_interrupt>
      56:	00 00       	nop
      58:	78 c0       	rjmp	.+240    	; 0x14a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	76 c0       	rjmp	.+236    	; 0x14a <__bad_interrupt>
      5e:	00 00       	nop
      60:	74 c0       	rjmp	.+232    	; 0x14a <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 3f 10 	jmp	0x207e	; 0x207e <__vector_25>
      68:	0c 94 8b 10 	jmp	0x2116	; 0x2116 <__vector_26>
      6c:	6e c0       	rjmp	.+220    	; 0x14a <__bad_interrupt>
      6e:	00 00       	nop
      70:	6c c0       	rjmp	.+216    	; 0x14a <__bad_interrupt>
      72:	00 00       	nop
      74:	6a c0       	rjmp	.+212    	; 0x14a <__bad_interrupt>
      76:	00 00       	nop
      78:	68 c0       	rjmp	.+208    	; 0x14a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	66 c0       	rjmp	.+204    	; 0x14a <__bad_interrupt>
      7e:	00 00       	nop
      80:	b5 c6       	rjmp	.+3434   	; 0xdec <__vector_32>
      82:	00 00       	nop
      84:	62 c0       	rjmp	.+196    	; 0x14a <__bad_interrupt>
      86:	00 00       	nop
      88:	60 c0       	rjmp	.+192    	; 0x14a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5e c0       	rjmp	.+188    	; 0x14a <__bad_interrupt>
      8e:	00 00       	nop
      90:	5c c0       	rjmp	.+184    	; 0x14a <__bad_interrupt>
      92:	00 00       	nop
      94:	5a c0       	rjmp	.+180    	; 0x14a <__bad_interrupt>
      96:	00 00       	nop
      98:	58 c0       	rjmp	.+176    	; 0x14a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	56 c0       	rjmp	.+172    	; 0x14a <__bad_interrupt>
      9e:	00 00       	nop
      a0:	54 c0       	rjmp	.+168    	; 0x14a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	52 c0       	rjmp	.+164    	; 0x14a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	50 c0       	rjmp	.+160    	; 0x14a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4e c0       	rjmp	.+156    	; 0x14a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4c c0       	rjmp	.+152    	; 0x14a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	4a c0       	rjmp	.+148    	; 0x14a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	48 c0       	rjmp	.+144    	; 0x14a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	46 c0       	rjmp	.+140    	; 0x14a <__bad_interrupt>
      be:	00 00       	nop
      c0:	44 c0       	rjmp	.+136    	; 0x14a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	42 c0       	rjmp	.+132    	; 0x14a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	40 c0       	rjmp	.+128    	; 0x14a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3e c0       	rjmp	.+124    	; 0x14a <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3c c0       	rjmp	.+120    	; 0x14a <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3a c0       	rjmp	.+116    	; 0x14a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	38 c0       	rjmp	.+112    	; 0x14a <__bad_interrupt>
      da:	00 00       	nop
      dc:	36 c0       	rjmp	.+108    	; 0x14a <__bad_interrupt>
      de:	00 00       	nop
      e0:	34 c0       	rjmp	.+104    	; 0x14a <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	1f 92       	push	r1
      ea:	1f 92       	push	r1
      ec:	cd b7       	in	r28, 0x3d	; 61
      ee:	de b7       	in	r29, 0x3e	; 62
      f0:	9a 83       	std	Y+2, r25	; 0x02
      f2:	89 83       	std	Y+1, r24	; 0x01
      f4:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <prvCheckTasksWaitingTermination>
      f8:	80 91 00 0e 	lds	r24, 0x0E00
      fc:	82 30       	cpi	r24, 0x02	; 2
      fe:	08 f0       	brcs	.+2      	; 0x102 <prvIdleTask+0x1e>
     100:	03 d5       	rcall	.+2566   	; 0xb08 <vPortYield>
     102:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vApplicationIdleHook>
     106:	f6 cf       	rjmp	.-20     	; 0xf4 <prvIdleTask+0x10>

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf ef       	ldi	r28, 0xFF	; 255
     10e:	d1 e2       	ldi	r29, 0x21	; 33
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61
     114:	00 e0       	ldi	r16, 0x00	; 0
     116:	0c bf       	out	0x3c, r16	; 60

00000118 <__do_copy_data>:
     118:	12 e0       	ldi	r17, 0x02	; 2
     11a:	a0 e0       	ldi	r26, 0x00	; 0
     11c:	b2 e0       	ldi	r27, 0x02	; 2
     11e:	ec e1       	ldi	r30, 0x1C	; 28
     120:	f2 e2       	ldi	r31, 0x22	; 34
     122:	00 e0       	ldi	r16, 0x00	; 0
     124:	0b bf       	out	0x3b, r16	; 59
     126:	02 c0       	rjmp	.+4      	; 0x12c <__do_copy_data+0x14>
     128:	07 90       	elpm	r0, Z+
     12a:	0d 92       	st	X+, r0
     12c:	a6 31       	cpi	r26, 0x16	; 22
     12e:	b1 07       	cpc	r27, r17
     130:	d9 f7       	brne	.-10     	; 0x128 <__do_copy_data+0x10>

00000132 <__do_clear_bss>:
     132:	2e e0       	ldi	r18, 0x0E	; 14
     134:	a6 e1       	ldi	r26, 0x16	; 22
     136:	b2 e0       	ldi	r27, 0x02	; 2
     138:	01 c0       	rjmp	.+2      	; 0x13c <.do_clear_bss_start>

0000013a <.do_clear_bss_loop>:
     13a:	1d 92       	st	X+, r1

0000013c <.do_clear_bss_start>:
     13c:	ab 35       	cpi	r26, 0x5B	; 91
     13e:	b2 07       	cpc	r27, r18
     140:	e1 f7       	brne	.-8      	; 0x13a <.do_clear_bss_loop>
     142:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <main>
     146:	0c 94 0c 11 	jmp	0x2218	; 0x2218 <_exit>

0000014a <__bad_interrupt>:
     14a:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <__vector_default>

0000014e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	1f 92       	push	r1
     154:	1f 92       	push	r1
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
     15a:	9a 83       	std	Y+2, r25	; 0x02
     15c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     15e:	89 81       	ldd	r24, Y+1	; 0x01
     160:	9a 81       	ldd	r25, Y+2	; 0x02
     162:	9c 01       	movw	r18, r24
     164:	2d 5f       	subi	r18, 0xFD	; 253
     166:	3f 4f       	sbci	r19, 0xFF	; 255
     168:	89 81       	ldd	r24, Y+1	; 0x01
     16a:	9a 81       	ldd	r25, Y+2	; 0x02
     16c:	fc 01       	movw	r30, r24
     16e:	32 83       	std	Z+2, r19	; 0x02
     170:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     172:	89 81       	ldd	r24, Y+1	; 0x01
     174:	9a 81       	ldd	r25, Y+2	; 0x02
     176:	2f ef       	ldi	r18, 0xFF	; 255
     178:	3f ef       	ldi	r19, 0xFF	; 255
     17a:	fc 01       	movw	r30, r24
     17c:	34 83       	std	Z+4, r19	; 0x04
     17e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     180:	89 81       	ldd	r24, Y+1	; 0x01
     182:	9a 81       	ldd	r25, Y+2	; 0x02
     184:	9c 01       	movw	r18, r24
     186:	2d 5f       	subi	r18, 0xFD	; 253
     188:	3f 4f       	sbci	r19, 0xFF	; 255
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	fc 01       	movw	r30, r24
     190:	36 83       	std	Z+6, r19	; 0x06
     192:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     194:	89 81       	ldd	r24, Y+1	; 0x01
     196:	9a 81       	ldd	r25, Y+2	; 0x02
     198:	9c 01       	movw	r18, r24
     19a:	2d 5f       	subi	r18, 0xFD	; 253
     19c:	3f 4f       	sbci	r19, 0xFF	; 255
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	9a 81       	ldd	r25, Y+2	; 0x02
     1a2:	fc 01       	movw	r30, r24
     1a4:	30 87       	std	Z+8, r19	; 0x08
     1a6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1a8:	89 81       	ldd	r24, Y+1	; 0x01
     1aa:	9a 81       	ldd	r25, Y+2	; 0x02
     1ac:	fc 01       	movw	r30, r24
     1ae:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     1b0:	0f 90       	pop	r0
     1b2:	0f 90       	pop	r0
     1b4:	df 91       	pop	r29
     1b6:	cf 91       	pop	r28
     1b8:	08 95       	ret

000001ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	1f 92       	push	r1
     1c0:	1f 92       	push	r1
     1c2:	cd b7       	in	r28, 0x3d	; 61
     1c4:	de b7       	in	r29, 0x3e	; 62
     1c6:	9a 83       	std	Y+2, r25	; 0x02
     1c8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1ca:	89 81       	ldd	r24, Y+1	; 0x01
     1cc:	9a 81       	ldd	r25, Y+2	; 0x02
     1ce:	fc 01       	movw	r30, r24
     1d0:	11 86       	std	Z+9, r1	; 0x09
     1d2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     1d4:	0f 90       	pop	r0
     1d6:	0f 90       	pop	r0
     1d8:	df 91       	pop	r29
     1da:	cf 91       	pop	r28
     1dc:	08 95       	ret

000001de <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1de:	cf 93       	push	r28
     1e0:	df 93       	push	r29
     1e2:	00 d0       	rcall	.+0      	; 0x1e4 <vListInsertEnd+0x6>
     1e4:	00 d0       	rcall	.+0      	; 0x1e6 <vListInsertEnd+0x8>
     1e6:	cd b7       	in	r28, 0x3d	; 61
     1e8:	de b7       	in	r29, 0x3e	; 62
     1ea:	9c 83       	std	Y+4, r25	; 0x04
     1ec:	8b 83       	std	Y+3, r24	; 0x03
     1ee:	7e 83       	std	Y+6, r23	; 0x06
     1f0:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     1f2:	8b 81       	ldd	r24, Y+3	; 0x03
     1f4:	9c 81       	ldd	r25, Y+4	; 0x04
     1f6:	fc 01       	movw	r30, r24
     1f8:	81 81       	ldd	r24, Z+1	; 0x01
     1fa:	92 81       	ldd	r25, Z+2	; 0x02
     1fc:	9a 83       	std	Y+2, r25	; 0x02
     1fe:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     200:	8d 81       	ldd	r24, Y+5	; 0x05
     202:	9e 81       	ldd	r25, Y+6	; 0x06
     204:	29 81       	ldd	r18, Y+1	; 0x01
     206:	3a 81       	ldd	r19, Y+2	; 0x02
     208:	fc 01       	movw	r30, r24
     20a:	33 83       	std	Z+3, r19	; 0x03
     20c:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	9a 81       	ldd	r25, Y+2	; 0x02
     212:	fc 01       	movw	r30, r24
     214:	24 81       	ldd	r18, Z+4	; 0x04
     216:	35 81       	ldd	r19, Z+5	; 0x05
     218:	8d 81       	ldd	r24, Y+5	; 0x05
     21a:	9e 81       	ldd	r25, Y+6	; 0x06
     21c:	fc 01       	movw	r30, r24
     21e:	35 83       	std	Z+5, r19	; 0x05
     220:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     222:	89 81       	ldd	r24, Y+1	; 0x01
     224:	9a 81       	ldd	r25, Y+2	; 0x02
     226:	fc 01       	movw	r30, r24
     228:	84 81       	ldd	r24, Z+4	; 0x04
     22a:	95 81       	ldd	r25, Z+5	; 0x05
     22c:	2d 81       	ldd	r18, Y+5	; 0x05
     22e:	3e 81       	ldd	r19, Y+6	; 0x06
     230:	fc 01       	movw	r30, r24
     232:	33 83       	std	Z+3, r19	; 0x03
     234:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	9a 81       	ldd	r25, Y+2	; 0x02
     23a:	2d 81       	ldd	r18, Y+5	; 0x05
     23c:	3e 81       	ldd	r19, Y+6	; 0x06
     23e:	fc 01       	movw	r30, r24
     240:	35 83       	std	Z+5, r19	; 0x05
     242:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     244:	8d 81       	ldd	r24, Y+5	; 0x05
     246:	9e 81       	ldd	r25, Y+6	; 0x06
     248:	2b 81       	ldd	r18, Y+3	; 0x03
     24a:	3c 81       	ldd	r19, Y+4	; 0x04
     24c:	fc 01       	movw	r30, r24
     24e:	31 87       	std	Z+9, r19	; 0x09
     250:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	9c 81       	ldd	r25, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	80 81       	ld	r24, Z
     25a:	21 e0       	ldi	r18, 0x01	; 1
     25c:	28 0f       	add	r18, r24
     25e:	8b 81       	ldd	r24, Y+3	; 0x03
     260:	9c 81       	ldd	r25, Y+4	; 0x04
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
}
     266:	26 96       	adiw	r28, 0x06	; 6
     268:	0f b6       	in	r0, 0x3f	; 63
     26a:	f8 94       	cli
     26c:	de bf       	out	0x3e, r29	; 62
     26e:	0f be       	out	0x3f, r0	; 63
     270:	cd bf       	out	0x3d, r28	; 61
     272:	df 91       	pop	r29
     274:	cf 91       	pop	r28
     276:	08 95       	ret

00000278 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	cd b7       	in	r28, 0x3d	; 61
     27e:	de b7       	in	r29, 0x3e	; 62
     280:	28 97       	sbiw	r28, 0x08	; 8
     282:	0f b6       	in	r0, 0x3f	; 63
     284:	f8 94       	cli
     286:	de bf       	out	0x3e, r29	; 62
     288:	0f be       	out	0x3f, r0	; 63
     28a:	cd bf       	out	0x3d, r28	; 61
     28c:	9e 83       	std	Y+6, r25	; 0x06
     28e:	8d 83       	std	Y+5, r24	; 0x05
     290:	78 87       	std	Y+8, r23	; 0x08
     292:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     294:	8f 81       	ldd	r24, Y+7	; 0x07
     296:	98 85       	ldd	r25, Y+8	; 0x08
     298:	fc 01       	movw	r30, r24
     29a:	80 81       	ld	r24, Z
     29c:	91 81       	ldd	r25, Z+1	; 0x01
     29e:	9c 83       	std	Y+4, r25	; 0x04
     2a0:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 96       	adiw	r24, 0x01	; 1
     2a8:	41 f4       	brne	.+16     	; 0x2ba <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2aa:	8d 81       	ldd	r24, Y+5	; 0x05
     2ac:	9e 81       	ldd	r25, Y+6	; 0x06
     2ae:	fc 01       	movw	r30, r24
     2b0:	87 81       	ldd	r24, Z+7	; 0x07
     2b2:	90 85       	ldd	r25, Z+8	; 0x08
     2b4:	9a 83       	std	Y+2, r25	; 0x02
     2b6:	89 83       	std	Y+1, r24	; 0x01
     2b8:	1a c0       	rjmp	.+52     	; 0x2ee <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ba:	8d 81       	ldd	r24, Y+5	; 0x05
     2bc:	9e 81       	ldd	r25, Y+6	; 0x06
     2be:	03 96       	adiw	r24, 0x03	; 3
     2c0:	9a 83       	std	Y+2, r25	; 0x02
     2c2:	89 83       	std	Y+1, r24	; 0x01
     2c4:	07 c0       	rjmp	.+14     	; 0x2d4 <vListInsert+0x5c>
     2c6:	89 81       	ldd	r24, Y+1	; 0x01
     2c8:	9a 81       	ldd	r25, Y+2	; 0x02
     2ca:	fc 01       	movw	r30, r24
     2cc:	82 81       	ldd	r24, Z+2	; 0x02
     2ce:	93 81       	ldd	r25, Z+3	; 0x03
     2d0:	9a 83       	std	Y+2, r25	; 0x02
     2d2:	89 83       	std	Y+1, r24	; 0x01
     2d4:	89 81       	ldd	r24, Y+1	; 0x01
     2d6:	9a 81       	ldd	r25, Y+2	; 0x02
     2d8:	fc 01       	movw	r30, r24
     2da:	82 81       	ldd	r24, Z+2	; 0x02
     2dc:	93 81       	ldd	r25, Z+3	; 0x03
     2de:	fc 01       	movw	r30, r24
     2e0:	20 81       	ld	r18, Z
     2e2:	31 81       	ldd	r19, Z+1	; 0x01
     2e4:	8b 81       	ldd	r24, Y+3	; 0x03
     2e6:	9c 81       	ldd	r25, Y+4	; 0x04
     2e8:	82 17       	cp	r24, r18
     2ea:	93 07       	cpc	r25, r19
     2ec:	60 f7       	brcc	.-40     	; 0x2c6 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2ee:	89 81       	ldd	r24, Y+1	; 0x01
     2f0:	9a 81       	ldd	r25, Y+2	; 0x02
     2f2:	fc 01       	movw	r30, r24
     2f4:	22 81       	ldd	r18, Z+2	; 0x02
     2f6:	33 81       	ldd	r19, Z+3	; 0x03
     2f8:	8f 81       	ldd	r24, Y+7	; 0x07
     2fa:	98 85       	ldd	r25, Y+8	; 0x08
     2fc:	fc 01       	movw	r30, r24
     2fe:	33 83       	std	Z+3, r19	; 0x03
     300:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     302:	8f 81       	ldd	r24, Y+7	; 0x07
     304:	98 85       	ldd	r25, Y+8	; 0x08
     306:	fc 01       	movw	r30, r24
     308:	82 81       	ldd	r24, Z+2	; 0x02
     30a:	93 81       	ldd	r25, Z+3	; 0x03
     30c:	2f 81       	ldd	r18, Y+7	; 0x07
     30e:	38 85       	ldd	r19, Y+8	; 0x08
     310:	fc 01       	movw	r30, r24
     312:	35 83       	std	Z+5, r19	; 0x05
     314:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     316:	8f 81       	ldd	r24, Y+7	; 0x07
     318:	98 85       	ldd	r25, Y+8	; 0x08
     31a:	29 81       	ldd	r18, Y+1	; 0x01
     31c:	3a 81       	ldd	r19, Y+2	; 0x02
     31e:	fc 01       	movw	r30, r24
     320:	35 83       	std	Z+5, r19	; 0x05
     322:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     324:	89 81       	ldd	r24, Y+1	; 0x01
     326:	9a 81       	ldd	r25, Y+2	; 0x02
     328:	2f 81       	ldd	r18, Y+7	; 0x07
     32a:	38 85       	ldd	r19, Y+8	; 0x08
     32c:	fc 01       	movw	r30, r24
     32e:	33 83       	std	Z+3, r19	; 0x03
     330:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     332:	8f 81       	ldd	r24, Y+7	; 0x07
     334:	98 85       	ldd	r25, Y+8	; 0x08
     336:	2d 81       	ldd	r18, Y+5	; 0x05
     338:	3e 81       	ldd	r19, Y+6	; 0x06
     33a:	fc 01       	movw	r30, r24
     33c:	31 87       	std	Z+9, r19	; 0x09
     33e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     340:	8d 81       	ldd	r24, Y+5	; 0x05
     342:	9e 81       	ldd	r25, Y+6	; 0x06
     344:	fc 01       	movw	r30, r24
     346:	80 81       	ld	r24, Z
     348:	21 e0       	ldi	r18, 0x01	; 1
     34a:	28 0f       	add	r18, r24
     34c:	8d 81       	ldd	r24, Y+5	; 0x05
     34e:	9e 81       	ldd	r25, Y+6	; 0x06
     350:	fc 01       	movw	r30, r24
     352:	20 83       	st	Z, r18
}
     354:	28 96       	adiw	r28, 0x08	; 8
     356:	0f b6       	in	r0, 0x3f	; 63
     358:	f8 94       	cli
     35a:	de bf       	out	0x3e, r29	; 62
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	cd bf       	out	0x3d, r28	; 61
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	08 95       	ret

00000366 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	00 d0       	rcall	.+0      	; 0x36c <uxListRemove+0x6>
     36c:	1f 92       	push	r1
     36e:	cd b7       	in	r28, 0x3d	; 61
     370:	de b7       	in	r29, 0x3e	; 62
     372:	9c 83       	std	Y+4, r25	; 0x04
     374:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     376:	8b 81       	ldd	r24, Y+3	; 0x03
     378:	9c 81       	ldd	r25, Y+4	; 0x04
     37a:	fc 01       	movw	r30, r24
     37c:	80 85       	ldd	r24, Z+8	; 0x08
     37e:	91 85       	ldd	r25, Z+9	; 0x09
     380:	9a 83       	std	Y+2, r25	; 0x02
     382:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     384:	8b 81       	ldd	r24, Y+3	; 0x03
     386:	9c 81       	ldd	r25, Y+4	; 0x04
     388:	fc 01       	movw	r30, r24
     38a:	82 81       	ldd	r24, Z+2	; 0x02
     38c:	93 81       	ldd	r25, Z+3	; 0x03
     38e:	2b 81       	ldd	r18, Y+3	; 0x03
     390:	3c 81       	ldd	r19, Y+4	; 0x04
     392:	f9 01       	movw	r30, r18
     394:	24 81       	ldd	r18, Z+4	; 0x04
     396:	35 81       	ldd	r19, Z+5	; 0x05
     398:	fc 01       	movw	r30, r24
     39a:	35 83       	std	Z+5, r19	; 0x05
     39c:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	fc 01       	movw	r30, r24
     3a4:	84 81       	ldd	r24, Z+4	; 0x04
     3a6:	95 81       	ldd	r25, Z+5	; 0x05
     3a8:	2b 81       	ldd	r18, Y+3	; 0x03
     3aa:	3c 81       	ldd	r19, Y+4	; 0x04
     3ac:	f9 01       	movw	r30, r18
     3ae:	22 81       	ldd	r18, Z+2	; 0x02
     3b0:	33 81       	ldd	r19, Z+3	; 0x03
     3b2:	fc 01       	movw	r30, r24
     3b4:	33 83       	std	Z+3, r19	; 0x03
     3b6:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3b8:	89 81       	ldd	r24, Y+1	; 0x01
     3ba:	9a 81       	ldd	r25, Y+2	; 0x02
     3bc:	fc 01       	movw	r30, r24
     3be:	21 81       	ldd	r18, Z+1	; 0x01
     3c0:	32 81       	ldd	r19, Z+2	; 0x02
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	28 17       	cp	r18, r24
     3c8:	39 07       	cpc	r19, r25
     3ca:	51 f4       	brne	.+20     	; 0x3e0 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3cc:	8b 81       	ldd	r24, Y+3	; 0x03
     3ce:	9c 81       	ldd	r25, Y+4	; 0x04
     3d0:	fc 01       	movw	r30, r24
     3d2:	24 81       	ldd	r18, Z+4	; 0x04
     3d4:	35 81       	ldd	r19, Z+5	; 0x05
     3d6:	89 81       	ldd	r24, Y+1	; 0x01
     3d8:	9a 81       	ldd	r25, Y+2	; 0x02
     3da:	fc 01       	movw	r30, r24
     3dc:	32 83       	std	Z+2, r19	; 0x02
     3de:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3e0:	8b 81       	ldd	r24, Y+3	; 0x03
     3e2:	9c 81       	ldd	r25, Y+4	; 0x04
     3e4:	fc 01       	movw	r30, r24
     3e6:	11 86       	std	Z+9, r1	; 0x09
     3e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3ea:	89 81       	ldd	r24, Y+1	; 0x01
     3ec:	9a 81       	ldd	r25, Y+2	; 0x02
     3ee:	fc 01       	movw	r30, r24
     3f0:	80 81       	ld	r24, Z
     3f2:	2f ef       	ldi	r18, 0xFF	; 255
     3f4:	28 0f       	add	r18, r24
     3f6:	89 81       	ldd	r24, Y+1	; 0x01
     3f8:	9a 81       	ldd	r25, Y+2	; 0x02
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     3fe:	89 81       	ldd	r24, Y+1	; 0x01
     400:	9a 81       	ldd	r25, Y+2	; 0x02
     402:	fc 01       	movw	r30, r24
     404:	80 81       	ld	r24, Z
}
     406:	0f 90       	pop	r0
     408:	0f 90       	pop	r0
     40a:	0f 90       	pop	r0
     40c:	0f 90       	pop	r0
     40e:	df 91       	pop	r29
     410:	cf 91       	pop	r28
     412:	08 95       	ret

00000414 <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     414:	cf 93       	push	r28
     416:	df 93       	push	r29
     418:	1f 92       	push	r1
     41a:	1f 92       	push	r1
     41c:	cd b7       	in	r28, 0x3d	; 61
     41e:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     420:	39 c0       	rjmp	.+114    	; 0x494 <prvCheckPendingReadyList+0x80>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     422:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     424:	80 91 31 02 	lds	r24, 0x0231
     428:	90 91 32 02 	lds	r25, 0x0232
     42c:	fc 01       	movw	r30, r24
     42e:	86 81       	ldd	r24, Z+6	; 0x06
     430:	97 81       	ldd	r25, Z+7	; 0x07
     432:	9a 83       	std	Y+2, r25	; 0x02
     434:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     436:	89 81       	ldd	r24, Y+1	; 0x01
     438:	9a 81       	ldd	r25, Y+2	; 0x02
     43a:	0c 96       	adiw	r24, 0x0c	; 12
     43c:	94 df       	rcall	.-216    	; 0x366 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     43e:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     440:	89 81       	ldd	r24, Y+1	; 0x01
     442:	9a 81       	ldd	r25, Y+2	; 0x02
     444:	02 96       	adiw	r24, 0x02	; 2
     446:	8f df       	rcall	.-226    	; 0x366 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     448:	89 81       	ldd	r24, Y+1	; 0x01
     44a:	9a 81       	ldd	r25, Y+2	; 0x02
     44c:	fc 01       	movw	r30, r24
     44e:	96 89       	ldd	r25, Z+22	; 0x16
     450:	80 91 37 02 	lds	r24, 0x0237
     454:	89 17       	cp	r24, r25
     456:	30 f4       	brcc	.+12     	; 0x464 <prvCheckPendingReadyList+0x50>
     458:	89 81       	ldd	r24, Y+1	; 0x01
     45a:	9a 81       	ldd	r25, Y+2	; 0x02
     45c:	fc 01       	movw	r30, r24
     45e:	86 89       	ldd	r24, Z+22	; 0x16
     460:	80 93 37 02 	sts	0x0237, r24
     464:	89 81       	ldd	r24, Y+1	; 0x01
     466:	9a 81       	ldd	r25, Y+2	; 0x02
     468:	ac 01       	movw	r20, r24
     46a:	4e 5f       	subi	r20, 0xFE	; 254
     46c:	5f 4f       	sbci	r21, 0xFF	; 255
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	fc 01       	movw	r30, r24
     474:	86 89       	ldd	r24, Z+22	; 0x16
     476:	28 2f       	mov	r18, r24
     478:	30 e0       	ldi	r19, 0x00	; 0
     47a:	c9 01       	movw	r24, r18
     47c:	88 0f       	add	r24, r24
     47e:	99 1f       	adc	r25, r25
     480:	88 0f       	add	r24, r24
     482:	99 1f       	adc	r25, r25
     484:	88 0f       	add	r24, r24
     486:	99 1f       	adc	r25, r25
     488:	82 0f       	add	r24, r18
     48a:	93 1f       	adc	r25, r19
     48c:	8a 5e       	subi	r24, 0xEA	; 234
     48e:	9d 4f       	sbci	r25, 0xFD	; 253
     490:	ba 01       	movw	r22, r20
     492:	a5 de       	rcall	.-694    	; 0x1de <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     494:	80 91 2c 02 	lds	r24, 0x022C
     498:	88 23       	and	r24, r24
     49a:	09 f0       	breq	.+2      	; 0x49e <prvCheckPendingReadyList+0x8a>
     49c:	c2 cf       	rjmp	.-124    	; 0x422 <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     49e:	0f 90       	pop	r0
     4a0:	0f 90       	pop	r0
     4a2:	df 91       	pop	r29
     4a4:	cf 91       	pop	r28
     4a6:	08 95       	ret

000004a8 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4a8:	cf 93       	push	r28
     4aa:	df 93       	push	r29
     4ac:	00 d0       	rcall	.+0      	; 0x4ae <prvCheckDelayedList+0x6>
     4ae:	1f 92       	push	r1
     4b0:	cd b7       	in	r28, 0x3d	; 61
     4b2:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4b4:	0e 94 75 0b 	call	0x16ea	; 0x16ea <xTaskGetTickCount>
     4b8:	9c 01       	movw	r18, r24
     4ba:	80 91 3a 02 	lds	r24, 0x023A
     4be:	90 91 3b 02 	lds	r25, 0x023B
     4c2:	a9 01       	movw	r20, r18
     4c4:	48 1b       	sub	r20, r24
     4c6:	59 0b       	sbc	r21, r25
     4c8:	ca 01       	movw	r24, r20
     4ca:	90 93 3d 02 	sts	0x023D, r25
     4ce:	80 93 3c 02 	sts	0x023C, r24
	while( xPassedTicks )
     4d2:	86 c0       	rjmp	.+268    	; 0x5e0 <prvCheckDelayedList+0x138>
	{
		xCoRoutineTickCount++;
     4d4:	80 91 38 02 	lds	r24, 0x0238
     4d8:	90 91 39 02 	lds	r25, 0x0239
     4dc:	01 96       	adiw	r24, 0x01	; 1
     4de:	90 93 39 02 	sts	0x0239, r25
     4e2:	80 93 38 02 	sts	0x0238, r24
		xPassedTicks--;
     4e6:	80 91 3c 02 	lds	r24, 0x023C
     4ea:	90 91 3d 02 	lds	r25, 0x023D
     4ee:	01 97       	sbiw	r24, 0x01	; 1
     4f0:	90 93 3d 02 	sts	0x023D, r25
     4f4:	80 93 3c 02 	sts	0x023C, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     4f8:	80 91 38 02 	lds	r24, 0x0238
     4fc:	90 91 39 02 	lds	r25, 0x0239
     500:	89 2b       	or	r24, r25
     502:	a1 f4       	brne	.+40     	; 0x52c <prvCheckDelayedList+0x84>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     504:	80 91 28 02 	lds	r24, 0x0228
     508:	90 91 29 02 	lds	r25, 0x0229
     50c:	9a 83       	std	Y+2, r25	; 0x02
     50e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     510:	80 91 2a 02 	lds	r24, 0x022A
     514:	90 91 2b 02 	lds	r25, 0x022B
     518:	90 93 29 02 	sts	0x0229, r25
     51c:	80 93 28 02 	sts	0x0228, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	9a 81       	ldd	r25, Y+2	; 0x02
     524:	90 93 2b 02 	sts	0x022B, r25
     528:	80 93 2a 02 	sts	0x022A, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     52c:	50 c0       	rjmp	.+160    	; 0x5ce <prvCheckDelayedList+0x126>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     52e:	80 91 28 02 	lds	r24, 0x0228
     532:	90 91 29 02 	lds	r25, 0x0229
     536:	fc 01       	movw	r30, r24
     538:	85 81       	ldd	r24, Z+5	; 0x05
     53a:	96 81       	ldd	r25, Z+6	; 0x06
     53c:	fc 01       	movw	r30, r24
     53e:	86 81       	ldd	r24, Z+6	; 0x06
     540:	97 81       	ldd	r25, Z+7	; 0x07
     542:	9c 83       	std	Y+4, r25	; 0x04
     544:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     546:	8b 81       	ldd	r24, Y+3	; 0x03
     548:	9c 81       	ldd	r25, Y+4	; 0x04
     54a:	fc 01       	movw	r30, r24
     54c:	22 81       	ldd	r18, Z+2	; 0x02
     54e:	33 81       	ldd	r19, Z+3	; 0x03
     550:	80 91 38 02 	lds	r24, 0x0238
     554:	90 91 39 02 	lds	r25, 0x0239
     558:	82 17       	cp	r24, r18
     55a:	93 07       	cpc	r25, r19
     55c:	08 f4       	brcc	.+2      	; 0x560 <prvCheckDelayedList+0xb8>
			{
				/* Timeout not yet expired. */
				break;
     55e:	40 c0       	rjmp	.+128    	; 0x5e0 <prvCheckDelayedList+0x138>
			}

			portDISABLE_INTERRUPTS();
     560:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     562:	8b 81       	ldd	r24, Y+3	; 0x03
     564:	9c 81       	ldd	r25, Y+4	; 0x04
     566:	02 96       	adiw	r24, 0x02	; 2
     568:	fe de       	rcall	.-516    	; 0x366 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     56a:	8b 81       	ldd	r24, Y+3	; 0x03
     56c:	9c 81       	ldd	r25, Y+4	; 0x04
     56e:	fc 01       	movw	r30, r24
     570:	84 89       	ldd	r24, Z+20	; 0x14
     572:	95 89       	ldd	r25, Z+21	; 0x15
     574:	89 2b       	or	r24, r25
     576:	21 f0       	breq	.+8      	; 0x580 <prvCheckDelayedList+0xd8>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     578:	8b 81       	ldd	r24, Y+3	; 0x03
     57a:	9c 81       	ldd	r25, Y+4	; 0x04
     57c:	0c 96       	adiw	r24, 0x0c	; 12
     57e:	f3 de       	rcall	.-538    	; 0x366 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     580:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     582:	8b 81       	ldd	r24, Y+3	; 0x03
     584:	9c 81       	ldd	r25, Y+4	; 0x04
     586:	fc 01       	movw	r30, r24
     588:	96 89       	ldd	r25, Z+22	; 0x16
     58a:	80 91 37 02 	lds	r24, 0x0237
     58e:	89 17       	cp	r24, r25
     590:	30 f4       	brcc	.+12     	; 0x59e <prvCheckDelayedList+0xf6>
     592:	8b 81       	ldd	r24, Y+3	; 0x03
     594:	9c 81       	ldd	r25, Y+4	; 0x04
     596:	fc 01       	movw	r30, r24
     598:	86 89       	ldd	r24, Z+22	; 0x16
     59a:	80 93 37 02 	sts	0x0237, r24
     59e:	8b 81       	ldd	r24, Y+3	; 0x03
     5a0:	9c 81       	ldd	r25, Y+4	; 0x04
     5a2:	ac 01       	movw	r20, r24
     5a4:	4e 5f       	subi	r20, 0xFE	; 254
     5a6:	5f 4f       	sbci	r21, 0xFF	; 255
     5a8:	8b 81       	ldd	r24, Y+3	; 0x03
     5aa:	9c 81       	ldd	r25, Y+4	; 0x04
     5ac:	fc 01       	movw	r30, r24
     5ae:	86 89       	ldd	r24, Z+22	; 0x16
     5b0:	28 2f       	mov	r18, r24
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	c9 01       	movw	r24, r18
     5b6:	88 0f       	add	r24, r24
     5b8:	99 1f       	adc	r25, r25
     5ba:	88 0f       	add	r24, r24
     5bc:	99 1f       	adc	r25, r25
     5be:	88 0f       	add	r24, r24
     5c0:	99 1f       	adc	r25, r25
     5c2:	82 0f       	add	r24, r18
     5c4:	93 1f       	adc	r25, r19
     5c6:	8a 5e       	subi	r24, 0xEA	; 234
     5c8:	9d 4f       	sbci	r25, 0xFD	; 253
     5ca:	ba 01       	movw	r22, r20
     5cc:	08 de       	rcall	.-1008   	; 0x1de <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5ce:	80 91 28 02 	lds	r24, 0x0228
     5d2:	90 91 29 02 	lds	r25, 0x0229
     5d6:	fc 01       	movw	r30, r24
     5d8:	80 81       	ld	r24, Z
     5da:	88 23       	and	r24, r24
     5dc:	09 f0       	breq	.+2      	; 0x5e0 <prvCheckDelayedList+0x138>
     5de:	a7 cf       	rjmp	.-178    	; 0x52e <prvCheckDelayedList+0x86>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5e0:	80 91 3c 02 	lds	r24, 0x023C
     5e4:	90 91 3d 02 	lds	r25, 0x023D
     5e8:	89 2b       	or	r24, r25
     5ea:	09 f0       	breq	.+2      	; 0x5ee <prvCheckDelayedList+0x146>
     5ec:	73 cf       	rjmp	.-282    	; 0x4d4 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     5ee:	80 91 38 02 	lds	r24, 0x0238
     5f2:	90 91 39 02 	lds	r25, 0x0239
     5f6:	90 93 3b 02 	sts	0x023B, r25
     5fa:	80 93 3a 02 	sts	0x023A, r24
}
     5fe:	0f 90       	pop	r0
     600:	0f 90       	pop	r0
     602:	0f 90       	pop	r0
     604:	0f 90       	pop	r0
     606:	df 91       	pop	r29
     608:	cf 91       	pop	r28
     60a:	08 95       	ret

0000060c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	1f 92       	push	r1
     612:	1f 92       	push	r1
     614:	cd b7       	in	r28, 0x3d	; 61
     616:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     618:	fd de       	rcall	.-518    	; 0x414 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     61a:	46 df       	rcall	.-372    	; 0x4a8 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     61c:	0a c0       	rjmp	.+20     	; 0x632 <vCoRoutineSchedule+0x26>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     61e:	80 91 37 02 	lds	r24, 0x0237
     622:	88 23       	and	r24, r24
     624:	09 f4       	brne	.+2      	; 0x628 <vCoRoutineSchedule+0x1c>
		{
			/* No more co-routines to check. */
			return;
     626:	6f c0       	rjmp	.+222    	; 0x706 <vCoRoutineSchedule+0xfa>
		}
		--uxTopCoRoutineReadyPriority;
     628:	80 91 37 02 	lds	r24, 0x0237
     62c:	81 50       	subi	r24, 0x01	; 1
     62e:	80 93 37 02 	sts	0x0237, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     632:	80 91 37 02 	lds	r24, 0x0237
     636:	28 2f       	mov	r18, r24
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	c9 01       	movw	r24, r18
     63c:	88 0f       	add	r24, r24
     63e:	99 1f       	adc	r25, r25
     640:	88 0f       	add	r24, r24
     642:	99 1f       	adc	r25, r25
     644:	88 0f       	add	r24, r24
     646:	99 1f       	adc	r25, r25
     648:	82 0f       	add	r24, r18
     64a:	93 1f       	adc	r25, r19
     64c:	8a 5e       	subi	r24, 0xEA	; 234
     64e:	9d 4f       	sbci	r25, 0xFD	; 253
     650:	fc 01       	movw	r30, r24
     652:	80 81       	ld	r24, Z
     654:	88 23       	and	r24, r24
     656:	19 f3       	breq	.-58     	; 0x61e <vCoRoutineSchedule+0x12>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     658:	80 91 37 02 	lds	r24, 0x0237
     65c:	28 2f       	mov	r18, r24
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	c9 01       	movw	r24, r18
     662:	88 0f       	add	r24, r24
     664:	99 1f       	adc	r25, r25
     666:	88 0f       	add	r24, r24
     668:	99 1f       	adc	r25, r25
     66a:	88 0f       	add	r24, r24
     66c:	99 1f       	adc	r25, r25
     66e:	82 0f       	add	r24, r18
     670:	93 1f       	adc	r25, r19
     672:	8a 5e       	subi	r24, 0xEA	; 234
     674:	9d 4f       	sbci	r25, 0xFD	; 253
     676:	9a 83       	std	Y+2, r25	; 0x02
     678:	89 83       	std	Y+1, r24	; 0x01
     67a:	89 81       	ldd	r24, Y+1	; 0x01
     67c:	9a 81       	ldd	r25, Y+2	; 0x02
     67e:	fc 01       	movw	r30, r24
     680:	81 81       	ldd	r24, Z+1	; 0x01
     682:	92 81       	ldd	r25, Z+2	; 0x02
     684:	fc 01       	movw	r30, r24
     686:	22 81       	ldd	r18, Z+2	; 0x02
     688:	33 81       	ldd	r19, Z+3	; 0x03
     68a:	89 81       	ldd	r24, Y+1	; 0x01
     68c:	9a 81       	ldd	r25, Y+2	; 0x02
     68e:	fc 01       	movw	r30, r24
     690:	32 83       	std	Z+2, r19	; 0x02
     692:	21 83       	std	Z+1, r18	; 0x01
     694:	89 81       	ldd	r24, Y+1	; 0x01
     696:	9a 81       	ldd	r25, Y+2	; 0x02
     698:	fc 01       	movw	r30, r24
     69a:	21 81       	ldd	r18, Z+1	; 0x01
     69c:	32 81       	ldd	r19, Z+2	; 0x02
     69e:	89 81       	ldd	r24, Y+1	; 0x01
     6a0:	9a 81       	ldd	r25, Y+2	; 0x02
     6a2:	03 96       	adiw	r24, 0x03	; 3
     6a4:	28 17       	cp	r18, r24
     6a6:	39 07       	cpc	r19, r25
     6a8:	69 f4       	brne	.+26     	; 0x6c4 <vCoRoutineSchedule+0xb8>
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	9a 81       	ldd	r25, Y+2	; 0x02
     6ae:	fc 01       	movw	r30, r24
     6b0:	81 81       	ldd	r24, Z+1	; 0x01
     6b2:	92 81       	ldd	r25, Z+2	; 0x02
     6b4:	fc 01       	movw	r30, r24
     6b6:	22 81       	ldd	r18, Z+2	; 0x02
     6b8:	33 81       	ldd	r19, Z+3	; 0x03
     6ba:	89 81       	ldd	r24, Y+1	; 0x01
     6bc:	9a 81       	ldd	r25, Y+2	; 0x02
     6be:	fc 01       	movw	r30, r24
     6c0:	32 83       	std	Z+2, r19	; 0x02
     6c2:	21 83       	std	Z+1, r18	; 0x01
     6c4:	89 81       	ldd	r24, Y+1	; 0x01
     6c6:	9a 81       	ldd	r25, Y+2	; 0x02
     6c8:	fc 01       	movw	r30, r24
     6ca:	81 81       	ldd	r24, Z+1	; 0x01
     6cc:	92 81       	ldd	r25, Z+2	; 0x02
     6ce:	fc 01       	movw	r30, r24
     6d0:	86 81       	ldd	r24, Z+6	; 0x06
     6d2:	97 81       	ldd	r25, Z+7	; 0x07
     6d4:	90 93 36 02 	sts	0x0236, r25
     6d8:	80 93 35 02 	sts	0x0235, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     6dc:	80 91 35 02 	lds	r24, 0x0235
     6e0:	90 91 36 02 	lds	r25, 0x0236
     6e4:	fc 01       	movw	r30, r24
     6e6:	20 81       	ld	r18, Z
     6e8:	31 81       	ldd	r19, Z+1	; 0x01
     6ea:	80 91 35 02 	lds	r24, 0x0235
     6ee:	90 91 36 02 	lds	r25, 0x0236
     6f2:	fc 01       	movw	r30, r24
     6f4:	47 89       	ldd	r20, Z+23	; 0x17
     6f6:	80 91 35 02 	lds	r24, 0x0235
     6fa:	90 91 36 02 	lds	r25, 0x0236
     6fe:	64 2f       	mov	r22, r20
     700:	f9 01       	movw	r30, r18
     702:	19 95       	eicall

	return;
     704:	00 00       	nop
}
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
     70a:	df 91       	pop	r29
     70c:	cf 91       	pop	r28
     70e:	08 95       	ret

00000710 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts

#endif
}
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	cd b7       	in	r28, 0x3d	; 61
     716:	de b7       	in	r29, 0x3e	; 62
     718:	28 97       	sbiw	r28, 0x08	; 8
     71a:	0f b6       	in	r0, 0x3f	; 63
     71c:	f8 94       	cli
     71e:	de bf       	out	0x3e, r29	; 62
     720:	0f be       	out	0x3f, r0	; 63
     722:	cd bf       	out	0x3d, r28	; 61
     724:	9c 83       	std	Y+4, r25	; 0x04
     726:	8b 83       	std	Y+3, r24	; 0x03
     728:	7e 83       	std	Y+6, r23	; 0x06
     72a:	6d 83       	std	Y+5, r22	; 0x05
     72c:	58 87       	std	Y+8, r21	; 0x08
     72e:	4f 83       	std	Y+7, r20	; 0x07
     730:	8b 81       	ldd	r24, Y+3	; 0x03
     732:	9c 81       	ldd	r25, Y+4	; 0x04
     734:	21 e1       	ldi	r18, 0x11	; 17
     736:	fc 01       	movw	r30, r24
     738:	20 83       	st	Z, r18
     73a:	8b 81       	ldd	r24, Y+3	; 0x03
     73c:	9c 81       	ldd	r25, Y+4	; 0x04
     73e:	01 97       	sbiw	r24, 0x01	; 1
     740:	9c 83       	std	Y+4, r25	; 0x04
     742:	8b 83       	std	Y+3, r24	; 0x03
     744:	8b 81       	ldd	r24, Y+3	; 0x03
     746:	9c 81       	ldd	r25, Y+4	; 0x04
     748:	22 e2       	ldi	r18, 0x22	; 34
     74a:	fc 01       	movw	r30, r24
     74c:	20 83       	st	Z, r18
     74e:	8b 81       	ldd	r24, Y+3	; 0x03
     750:	9c 81       	ldd	r25, Y+4	; 0x04
     752:	01 97       	sbiw	r24, 0x01	; 1
     754:	9c 83       	std	Y+4, r25	; 0x04
     756:	8b 83       	std	Y+3, r24	; 0x03
     758:	8b 81       	ldd	r24, Y+3	; 0x03
     75a:	9c 81       	ldd	r25, Y+4	; 0x04
     75c:	23 e3       	ldi	r18, 0x33	; 51
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
     762:	8b 81       	ldd	r24, Y+3	; 0x03
     764:	9c 81       	ldd	r25, Y+4	; 0x04
     766:	01 97       	sbiw	r24, 0x01	; 1
     768:	9c 83       	std	Y+4, r25	; 0x04
     76a:	8b 83       	std	Y+3, r24	; 0x03
     76c:	8d 81       	ldd	r24, Y+5	; 0x05
     76e:	9e 81       	ldd	r25, Y+6	; 0x06
     770:	9a 83       	std	Y+2, r25	; 0x02
     772:	89 83       	std	Y+1, r24	; 0x01
     774:	29 81       	ldd	r18, Y+1	; 0x01
     776:	8b 81       	ldd	r24, Y+3	; 0x03
     778:	9c 81       	ldd	r25, Y+4	; 0x04
     77a:	fc 01       	movw	r30, r24
     77c:	20 83       	st	Z, r18
     77e:	8b 81       	ldd	r24, Y+3	; 0x03
     780:	9c 81       	ldd	r25, Y+4	; 0x04
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	9c 83       	std	Y+4, r25	; 0x04
     786:	8b 83       	std	Y+3, r24	; 0x03
     788:	89 81       	ldd	r24, Y+1	; 0x01
     78a:	9a 81       	ldd	r25, Y+2	; 0x02
     78c:	89 2f       	mov	r24, r25
     78e:	99 27       	eor	r25, r25
     790:	9a 83       	std	Y+2, r25	; 0x02
     792:	89 83       	std	Y+1, r24	; 0x01
     794:	29 81       	ldd	r18, Y+1	; 0x01
     796:	8b 81       	ldd	r24, Y+3	; 0x03
     798:	9c 81       	ldd	r25, Y+4	; 0x04
     79a:	fc 01       	movw	r30, r24
     79c:	20 83       	st	Z, r18
     79e:	8b 81       	ldd	r24, Y+3	; 0x03
     7a0:	9c 81       	ldd	r25, Y+4	; 0x04
     7a2:	01 97       	sbiw	r24, 0x01	; 1
     7a4:	9c 83       	std	Y+4, r25	; 0x04
     7a6:	8b 83       	std	Y+3, r24	; 0x03
     7a8:	8b 81       	ldd	r24, Y+3	; 0x03
     7aa:	9c 81       	ldd	r25, Y+4	; 0x04
     7ac:	fc 01       	movw	r30, r24
     7ae:	10 82       	st	Z, r1
     7b0:	8b 81       	ldd	r24, Y+3	; 0x03
     7b2:	9c 81       	ldd	r25, Y+4	; 0x04
     7b4:	01 97       	sbiw	r24, 0x01	; 1
     7b6:	9c 83       	std	Y+4, r25	; 0x04
     7b8:	8b 83       	std	Y+3, r24	; 0x03
     7ba:	8b 81       	ldd	r24, Y+3	; 0x03
     7bc:	9c 81       	ldd	r25, Y+4	; 0x04
     7be:	fc 01       	movw	r30, r24
     7c0:	10 82       	st	Z, r1
     7c2:	8b 81       	ldd	r24, Y+3	; 0x03
     7c4:	9c 81       	ldd	r25, Y+4	; 0x04
     7c6:	01 97       	sbiw	r24, 0x01	; 1
     7c8:	9c 83       	std	Y+4, r25	; 0x04
     7ca:	8b 83       	std	Y+3, r24	; 0x03
     7cc:	8b 81       	ldd	r24, Y+3	; 0x03
     7ce:	9c 81       	ldd	r25, Y+4	; 0x04
     7d0:	20 e8       	ldi	r18, 0x80	; 128
     7d2:	fc 01       	movw	r30, r24
     7d4:	20 83       	st	Z, r18
     7d6:	8b 81       	ldd	r24, Y+3	; 0x03
     7d8:	9c 81       	ldd	r25, Y+4	; 0x04
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	8b 83       	std	Y+3, r24	; 0x03
     7e0:	8b 81       	ldd	r24, Y+3	; 0x03
     7e2:	9c 81       	ldd	r25, Y+4	; 0x04
     7e4:	fc 01       	movw	r30, r24
     7e6:	10 82       	st	Z, r1
     7e8:	8b 81       	ldd	r24, Y+3	; 0x03
     7ea:	9c 81       	ldd	r25, Y+4	; 0x04
     7ec:	01 97       	sbiw	r24, 0x01	; 1
     7ee:	9c 83       	std	Y+4, r25	; 0x04
     7f0:	8b 83       	std	Y+3, r24	; 0x03
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	9c 81       	ldd	r25, Y+4	; 0x04
     7f6:	fc 01       	movw	r30, r24
     7f8:	10 82       	st	Z, r1
     7fa:	8b 81       	ldd	r24, Y+3	; 0x03
     7fc:	9c 81       	ldd	r25, Y+4	; 0x04
     7fe:	01 97       	sbiw	r24, 0x01	; 1
     800:	9c 83       	std	Y+4, r25	; 0x04
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	8b 81       	ldd	r24, Y+3	; 0x03
     806:	9c 81       	ldd	r25, Y+4	; 0x04
     808:	fc 01       	movw	r30, r24
     80a:	10 82       	st	Z, r1
     80c:	8b 81       	ldd	r24, Y+3	; 0x03
     80e:	9c 81       	ldd	r25, Y+4	; 0x04
     810:	01 97       	sbiw	r24, 0x01	; 1
     812:	9c 83       	std	Y+4, r25	; 0x04
     814:	8b 83       	std	Y+3, r24	; 0x03
     816:	8b 81       	ldd	r24, Y+3	; 0x03
     818:	9c 81       	ldd	r25, Y+4	; 0x04
     81a:	22 e0       	ldi	r18, 0x02	; 2
     81c:	fc 01       	movw	r30, r24
     81e:	20 83       	st	Z, r18
     820:	8b 81       	ldd	r24, Y+3	; 0x03
     822:	9c 81       	ldd	r25, Y+4	; 0x04
     824:	01 97       	sbiw	r24, 0x01	; 1
     826:	9c 83       	std	Y+4, r25	; 0x04
     828:	8b 83       	std	Y+3, r24	; 0x03
     82a:	8b 81       	ldd	r24, Y+3	; 0x03
     82c:	9c 81       	ldd	r25, Y+4	; 0x04
     82e:	23 e0       	ldi	r18, 0x03	; 3
     830:	fc 01       	movw	r30, r24
     832:	20 83       	st	Z, r18
     834:	8b 81       	ldd	r24, Y+3	; 0x03
     836:	9c 81       	ldd	r25, Y+4	; 0x04
     838:	01 97       	sbiw	r24, 0x01	; 1
     83a:	9c 83       	std	Y+4, r25	; 0x04
     83c:	8b 83       	std	Y+3, r24	; 0x03
     83e:	8b 81       	ldd	r24, Y+3	; 0x03
     840:	9c 81       	ldd	r25, Y+4	; 0x04
     842:	24 e0       	ldi	r18, 0x04	; 4
     844:	fc 01       	movw	r30, r24
     846:	20 83       	st	Z, r18
     848:	8b 81       	ldd	r24, Y+3	; 0x03
     84a:	9c 81       	ldd	r25, Y+4	; 0x04
     84c:	01 97       	sbiw	r24, 0x01	; 1
     84e:	9c 83       	std	Y+4, r25	; 0x04
     850:	8b 83       	std	Y+3, r24	; 0x03
     852:	8b 81       	ldd	r24, Y+3	; 0x03
     854:	9c 81       	ldd	r25, Y+4	; 0x04
     856:	25 e0       	ldi	r18, 0x05	; 5
     858:	fc 01       	movw	r30, r24
     85a:	20 83       	st	Z, r18
     85c:	8b 81       	ldd	r24, Y+3	; 0x03
     85e:	9c 81       	ldd	r25, Y+4	; 0x04
     860:	01 97       	sbiw	r24, 0x01	; 1
     862:	9c 83       	std	Y+4, r25	; 0x04
     864:	8b 83       	std	Y+3, r24	; 0x03
     866:	8b 81       	ldd	r24, Y+3	; 0x03
     868:	9c 81       	ldd	r25, Y+4	; 0x04
     86a:	26 e0       	ldi	r18, 0x06	; 6
     86c:	fc 01       	movw	r30, r24
     86e:	20 83       	st	Z, r18
     870:	8b 81       	ldd	r24, Y+3	; 0x03
     872:	9c 81       	ldd	r25, Y+4	; 0x04
     874:	01 97       	sbiw	r24, 0x01	; 1
     876:	9c 83       	std	Y+4, r25	; 0x04
     878:	8b 83       	std	Y+3, r24	; 0x03
     87a:	8b 81       	ldd	r24, Y+3	; 0x03
     87c:	9c 81       	ldd	r25, Y+4	; 0x04
     87e:	27 e0       	ldi	r18, 0x07	; 7
     880:	fc 01       	movw	r30, r24
     882:	20 83       	st	Z, r18
     884:	8b 81       	ldd	r24, Y+3	; 0x03
     886:	9c 81       	ldd	r25, Y+4	; 0x04
     888:	01 97       	sbiw	r24, 0x01	; 1
     88a:	9c 83       	std	Y+4, r25	; 0x04
     88c:	8b 83       	std	Y+3, r24	; 0x03
     88e:	8b 81       	ldd	r24, Y+3	; 0x03
     890:	9c 81       	ldd	r25, Y+4	; 0x04
     892:	28 e0       	ldi	r18, 0x08	; 8
     894:	fc 01       	movw	r30, r24
     896:	20 83       	st	Z, r18
     898:	8b 81       	ldd	r24, Y+3	; 0x03
     89a:	9c 81       	ldd	r25, Y+4	; 0x04
     89c:	01 97       	sbiw	r24, 0x01	; 1
     89e:	9c 83       	std	Y+4, r25	; 0x04
     8a0:	8b 83       	std	Y+3, r24	; 0x03
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	9c 81       	ldd	r25, Y+4	; 0x04
     8a6:	29 e0       	ldi	r18, 0x09	; 9
     8a8:	fc 01       	movw	r30, r24
     8aa:	20 83       	st	Z, r18
     8ac:	8b 81       	ldd	r24, Y+3	; 0x03
     8ae:	9c 81       	ldd	r25, Y+4	; 0x04
     8b0:	01 97       	sbiw	r24, 0x01	; 1
     8b2:	9c 83       	std	Y+4, r25	; 0x04
     8b4:	8b 83       	std	Y+3, r24	; 0x03
     8b6:	8b 81       	ldd	r24, Y+3	; 0x03
     8b8:	9c 81       	ldd	r25, Y+4	; 0x04
     8ba:	20 e1       	ldi	r18, 0x10	; 16
     8bc:	fc 01       	movw	r30, r24
     8be:	20 83       	st	Z, r18
     8c0:	8b 81       	ldd	r24, Y+3	; 0x03
     8c2:	9c 81       	ldd	r25, Y+4	; 0x04
     8c4:	01 97       	sbiw	r24, 0x01	; 1
     8c6:	9c 83       	std	Y+4, r25	; 0x04
     8c8:	8b 83       	std	Y+3, r24	; 0x03
     8ca:	8b 81       	ldd	r24, Y+3	; 0x03
     8cc:	9c 81       	ldd	r25, Y+4	; 0x04
     8ce:	21 e1       	ldi	r18, 0x11	; 17
     8d0:	fc 01       	movw	r30, r24
     8d2:	20 83       	st	Z, r18
     8d4:	8b 81       	ldd	r24, Y+3	; 0x03
     8d6:	9c 81       	ldd	r25, Y+4	; 0x04
     8d8:	01 97       	sbiw	r24, 0x01	; 1
     8da:	9c 83       	std	Y+4, r25	; 0x04
     8dc:	8b 83       	std	Y+3, r24	; 0x03
     8de:	8b 81       	ldd	r24, Y+3	; 0x03
     8e0:	9c 81       	ldd	r25, Y+4	; 0x04
     8e2:	22 e1       	ldi	r18, 0x12	; 18
     8e4:	fc 01       	movw	r30, r24
     8e6:	20 83       	st	Z, r18
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	01 97       	sbiw	r24, 0x01	; 1
     8ee:	9c 83       	std	Y+4, r25	; 0x04
     8f0:	8b 83       	std	Y+3, r24	; 0x03
     8f2:	8b 81       	ldd	r24, Y+3	; 0x03
     8f4:	9c 81       	ldd	r25, Y+4	; 0x04
     8f6:	23 e1       	ldi	r18, 0x13	; 19
     8f8:	fc 01       	movw	r30, r24
     8fa:	20 83       	st	Z, r18
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	01 97       	sbiw	r24, 0x01	; 1
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
     906:	8b 81       	ldd	r24, Y+3	; 0x03
     908:	9c 81       	ldd	r25, Y+4	; 0x04
     90a:	24 e1       	ldi	r18, 0x14	; 20
     90c:	fc 01       	movw	r30, r24
     90e:	20 83       	st	Z, r18
     910:	8b 81       	ldd	r24, Y+3	; 0x03
     912:	9c 81       	ldd	r25, Y+4	; 0x04
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	9c 83       	std	Y+4, r25	; 0x04
     918:	8b 83       	std	Y+3, r24	; 0x03
     91a:	8b 81       	ldd	r24, Y+3	; 0x03
     91c:	9c 81       	ldd	r25, Y+4	; 0x04
     91e:	25 e1       	ldi	r18, 0x15	; 21
     920:	fc 01       	movw	r30, r24
     922:	20 83       	st	Z, r18
     924:	8b 81       	ldd	r24, Y+3	; 0x03
     926:	9c 81       	ldd	r25, Y+4	; 0x04
     928:	01 97       	sbiw	r24, 0x01	; 1
     92a:	9c 83       	std	Y+4, r25	; 0x04
     92c:	8b 83       	std	Y+3, r24	; 0x03
     92e:	8b 81       	ldd	r24, Y+3	; 0x03
     930:	9c 81       	ldd	r25, Y+4	; 0x04
     932:	26 e1       	ldi	r18, 0x16	; 22
     934:	fc 01       	movw	r30, r24
     936:	20 83       	st	Z, r18
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	01 97       	sbiw	r24, 0x01	; 1
     93e:	9c 83       	std	Y+4, r25	; 0x04
     940:	8b 83       	std	Y+3, r24	; 0x03
     942:	8b 81       	ldd	r24, Y+3	; 0x03
     944:	9c 81       	ldd	r25, Y+4	; 0x04
     946:	27 e1       	ldi	r18, 0x17	; 23
     948:	fc 01       	movw	r30, r24
     94a:	20 83       	st	Z, r18
     94c:	8b 81       	ldd	r24, Y+3	; 0x03
     94e:	9c 81       	ldd	r25, Y+4	; 0x04
     950:	01 97       	sbiw	r24, 0x01	; 1
     952:	9c 83       	std	Y+4, r25	; 0x04
     954:	8b 83       	std	Y+3, r24	; 0x03
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	9c 81       	ldd	r25, Y+4	; 0x04
     95a:	28 e1       	ldi	r18, 0x18	; 24
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
     960:	8b 81       	ldd	r24, Y+3	; 0x03
     962:	9c 81       	ldd	r25, Y+4	; 0x04
     964:	01 97       	sbiw	r24, 0x01	; 1
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	29 e1       	ldi	r18, 0x19	; 25
     970:	fc 01       	movw	r30, r24
     972:	20 83       	st	Z, r18
     974:	8b 81       	ldd	r24, Y+3	; 0x03
     976:	9c 81       	ldd	r25, Y+4	; 0x04
     978:	01 97       	sbiw	r24, 0x01	; 1
     97a:	9c 83       	std	Y+4, r25	; 0x04
     97c:	8b 83       	std	Y+3, r24	; 0x03
     97e:	8b 81       	ldd	r24, Y+3	; 0x03
     980:	9c 81       	ldd	r25, Y+4	; 0x04
     982:	20 e2       	ldi	r18, 0x20	; 32
     984:	fc 01       	movw	r30, r24
     986:	20 83       	st	Z, r18
     988:	8b 81       	ldd	r24, Y+3	; 0x03
     98a:	9c 81       	ldd	r25, Y+4	; 0x04
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	9c 83       	std	Y+4, r25	; 0x04
     990:	8b 83       	std	Y+3, r24	; 0x03
     992:	8b 81       	ldd	r24, Y+3	; 0x03
     994:	9c 81       	ldd	r25, Y+4	; 0x04
     996:	21 e2       	ldi	r18, 0x21	; 33
     998:	fc 01       	movw	r30, r24
     99a:	20 83       	st	Z, r18
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	9c 81       	ldd	r25, Y+4	; 0x04
     9a0:	01 97       	sbiw	r24, 0x01	; 1
     9a2:	9c 83       	std	Y+4, r25	; 0x04
     9a4:	8b 83       	std	Y+3, r24	; 0x03
     9a6:	8b 81       	ldd	r24, Y+3	; 0x03
     9a8:	9c 81       	ldd	r25, Y+4	; 0x04
     9aa:	22 e2       	ldi	r18, 0x22	; 34
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 83       	st	Z, r18
     9b0:	8b 81       	ldd	r24, Y+3	; 0x03
     9b2:	9c 81       	ldd	r25, Y+4	; 0x04
     9b4:	01 97       	sbiw	r24, 0x01	; 1
     9b6:	9c 83       	std	Y+4, r25	; 0x04
     9b8:	8b 83       	std	Y+3, r24	; 0x03
     9ba:	8b 81       	ldd	r24, Y+3	; 0x03
     9bc:	9c 81       	ldd	r25, Y+4	; 0x04
     9be:	23 e2       	ldi	r18, 0x23	; 35
     9c0:	fc 01       	movw	r30, r24
     9c2:	20 83       	st	Z, r18
     9c4:	8b 81       	ldd	r24, Y+3	; 0x03
     9c6:	9c 81       	ldd	r25, Y+4	; 0x04
     9c8:	01 97       	sbiw	r24, 0x01	; 1
     9ca:	9c 83       	std	Y+4, r25	; 0x04
     9cc:	8b 83       	std	Y+3, r24	; 0x03
     9ce:	8f 81       	ldd	r24, Y+7	; 0x07
     9d0:	98 85       	ldd	r25, Y+8	; 0x08
     9d2:	9a 83       	std	Y+2, r25	; 0x02
     9d4:	89 83       	std	Y+1, r24	; 0x01
     9d6:	29 81       	ldd	r18, Y+1	; 0x01
     9d8:	8b 81       	ldd	r24, Y+3	; 0x03
     9da:	9c 81       	ldd	r25, Y+4	; 0x04
     9dc:	fc 01       	movw	r30, r24
     9de:	20 83       	st	Z, r18
     9e0:	8b 81       	ldd	r24, Y+3	; 0x03
     9e2:	9c 81       	ldd	r25, Y+4	; 0x04
     9e4:	01 97       	sbiw	r24, 0x01	; 1
     9e6:	9c 83       	std	Y+4, r25	; 0x04
     9e8:	8b 83       	std	Y+3, r24	; 0x03
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	89 2f       	mov	r24, r25
     9f0:	99 27       	eor	r25, r25
     9f2:	9a 83       	std	Y+2, r25	; 0x02
     9f4:	89 83       	std	Y+1, r24	; 0x01
     9f6:	29 81       	ldd	r18, Y+1	; 0x01
     9f8:	8b 81       	ldd	r24, Y+3	; 0x03
     9fa:	9c 81       	ldd	r25, Y+4	; 0x04
     9fc:	fc 01       	movw	r30, r24
     9fe:	20 83       	st	Z, r18
     a00:	8b 81       	ldd	r24, Y+3	; 0x03
     a02:	9c 81       	ldd	r25, Y+4	; 0x04
     a04:	01 97       	sbiw	r24, 0x01	; 1
     a06:	9c 83       	std	Y+4, r25	; 0x04
     a08:	8b 83       	std	Y+3, r24	; 0x03
     a0a:	8b 81       	ldd	r24, Y+3	; 0x03
     a0c:	9c 81       	ldd	r25, Y+4	; 0x04
     a0e:	26 e2       	ldi	r18, 0x26	; 38
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
     a14:	8b 81       	ldd	r24, Y+3	; 0x03
     a16:	9c 81       	ldd	r25, Y+4	; 0x04
     a18:	01 97       	sbiw	r24, 0x01	; 1
     a1a:	9c 83       	std	Y+4, r25	; 0x04
     a1c:	8b 83       	std	Y+3, r24	; 0x03
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	9c 81       	ldd	r25, Y+4	; 0x04
     a22:	27 e2       	ldi	r18, 0x27	; 39
     a24:	fc 01       	movw	r30, r24
     a26:	20 83       	st	Z, r18
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	9c 81       	ldd	r25, Y+4	; 0x04
     a2c:	01 97       	sbiw	r24, 0x01	; 1
     a2e:	9c 83       	std	Y+4, r25	; 0x04
     a30:	8b 83       	std	Y+3, r24	; 0x03
     a32:	8b 81       	ldd	r24, Y+3	; 0x03
     a34:	9c 81       	ldd	r25, Y+4	; 0x04
     a36:	28 e2       	ldi	r18, 0x28	; 40
     a38:	fc 01       	movw	r30, r24
     a3a:	20 83       	st	Z, r18
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	01 97       	sbiw	r24, 0x01	; 1
     a42:	9c 83       	std	Y+4, r25	; 0x04
     a44:	8b 83       	std	Y+3, r24	; 0x03
     a46:	8b 81       	ldd	r24, Y+3	; 0x03
     a48:	9c 81       	ldd	r25, Y+4	; 0x04
     a4a:	29 e2       	ldi	r18, 0x29	; 41
     a4c:	fc 01       	movw	r30, r24
     a4e:	20 83       	st	Z, r18
     a50:	8b 81       	ldd	r24, Y+3	; 0x03
     a52:	9c 81       	ldd	r25, Y+4	; 0x04
     a54:	01 97       	sbiw	r24, 0x01	; 1
     a56:	9c 83       	std	Y+4, r25	; 0x04
     a58:	8b 83       	std	Y+3, r24	; 0x03
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	20 e3       	ldi	r18, 0x30	; 48
     a60:	fc 01       	movw	r30, r24
     a62:	20 83       	st	Z, r18
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	9c 83       	std	Y+4, r25	; 0x04
     a6c:	8b 83       	std	Y+3, r24	; 0x03
     a6e:	8b 81       	ldd	r24, Y+3	; 0x03
     a70:	9c 81       	ldd	r25, Y+4	; 0x04
     a72:	21 e3       	ldi	r18, 0x31	; 49
     a74:	fc 01       	movw	r30, r24
     a76:	20 83       	st	Z, r18
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	9c 81       	ldd	r25, Y+4	; 0x04
     a7c:	01 97       	sbiw	r24, 0x01	; 1
     a7e:	9c 83       	std	Y+4, r25	; 0x04
     a80:	8b 83       	std	Y+3, r24	; 0x03
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	9c 81       	ldd	r25, Y+4	; 0x04
     a86:	28 96       	adiw	r28, 0x08	; 8
     a88:	0f b6       	in	r0, 0x3f	; 63
     a8a:	f8 94       	cli
     a8c:	de bf       	out	0x3e, r29	; 62
     a8e:	0f be       	out	0x3f, r0	; 63
     a90:	cd bf       	out	0x3d, r28	; 61
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	08 95       	ret

00000a98 <xPortStartScheduler>:
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	0d d1       	rcall	.+538    	; 0xcbc <prvSetupTimerInterrupt>
     aa2:	a0 91 fe 0d 	lds	r26, 0x0DFE
     aa6:	b0 91 ff 0d 	lds	r27, 0x0DFF
     aaa:	cd 91       	ld	r28, X+
     aac:	cd bf       	out	0x3d, r28	; 61
     aae:	dd 91       	ld	r29, X+
     ab0:	de bf       	out	0x3e, r29	; 62
     ab2:	ff 91       	pop	r31
     ab4:	ef 91       	pop	r30
     ab6:	df 91       	pop	r29
     ab8:	cf 91       	pop	r28
     aba:	bf 91       	pop	r27
     abc:	af 91       	pop	r26
     abe:	9f 91       	pop	r25
     ac0:	8f 91       	pop	r24
     ac2:	7f 91       	pop	r23
     ac4:	6f 91       	pop	r22
     ac6:	5f 91       	pop	r21
     ac8:	4f 91       	pop	r20
     aca:	3f 91       	pop	r19
     acc:	2f 91       	pop	r18
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	ff 90       	pop	r15
     ad4:	ef 90       	pop	r14
     ad6:	df 90       	pop	r13
     ad8:	cf 90       	pop	r12
     ada:	bf 90       	pop	r11
     adc:	af 90       	pop	r10
     ade:	9f 90       	pop	r9
     ae0:	8f 90       	pop	r8
     ae2:	7f 90       	pop	r7
     ae4:	6f 90       	pop	r6
     ae6:	5f 90       	pop	r5
     ae8:	4f 90       	pop	r4
     aea:	3f 90       	pop	r3
     aec:	2f 90       	pop	r2
     aee:	1f 90       	pop	r1
     af0:	0f 90       	pop	r0
     af2:	0c be       	out	0x3c, r0	; 60
     af4:	0f 90       	pop	r0
     af6:	0b be       	out	0x3b, r0	; 59
     af8:	0f 90       	pop	r0
     afa:	0f be       	out	0x3f, r0	; 63
     afc:	0f 90       	pop	r0
     afe:	08 95       	ret
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b08:	0f 92       	push	r0
     b0a:	0f b6       	in	r0, 0x3f	; 63
     b0c:	f8 94       	cli
     b0e:	0f 92       	push	r0
     b10:	0b b6       	in	r0, 0x3b	; 59
     b12:	0f 92       	push	r0
     b14:	0c b6       	in	r0, 0x3c	; 60
     b16:	0f 92       	push	r0
     b18:	1f 92       	push	r1
     b1a:	11 24       	eor	r1, r1
     b1c:	2f 92       	push	r2
     b1e:	3f 92       	push	r3
     b20:	4f 92       	push	r4
     b22:	5f 92       	push	r5
     b24:	6f 92       	push	r6
     b26:	7f 92       	push	r7
     b28:	8f 92       	push	r8
     b2a:	9f 92       	push	r9
     b2c:	af 92       	push	r10
     b2e:	bf 92       	push	r11
     b30:	cf 92       	push	r12
     b32:	df 92       	push	r13
     b34:	ef 92       	push	r14
     b36:	ff 92       	push	r15
     b38:	0f 93       	push	r16
     b3a:	1f 93       	push	r17
     b3c:	2f 93       	push	r18
     b3e:	3f 93       	push	r19
     b40:	4f 93       	push	r20
     b42:	5f 93       	push	r21
     b44:	6f 93       	push	r22
     b46:	7f 93       	push	r23
     b48:	8f 93       	push	r24
     b4a:	9f 93       	push	r25
     b4c:	af 93       	push	r26
     b4e:	bf 93       	push	r27
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	ef 93       	push	r30
     b56:	ff 93       	push	r31
     b58:	a0 91 fe 0d 	lds	r26, 0x0DFE
     b5c:	b0 91 ff 0d 	lds	r27, 0x0DFF
     b60:	0d b6       	in	r0, 0x3d	; 61
     b62:	0d 92       	st	X+, r0
     b64:	0e b6       	in	r0, 0x3e	; 62
     b66:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b68:	c5 d6       	rcall	.+3466   	; 0x18f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b6a:	a0 91 fe 0d 	lds	r26, 0x0DFE
     b6e:	b0 91 ff 0d 	lds	r27, 0x0DFF
     b72:	cd 91       	ld	r28, X+
     b74:	cd bf       	out	0x3d, r28	; 61
     b76:	dd 91       	ld	r29, X+
     b78:	de bf       	out	0x3e, r29	; 62
     b7a:	ff 91       	pop	r31
     b7c:	ef 91       	pop	r30
     b7e:	df 91       	pop	r29
     b80:	cf 91       	pop	r28
     b82:	bf 91       	pop	r27
     b84:	af 91       	pop	r26
     b86:	9f 91       	pop	r25
     b88:	8f 91       	pop	r24
     b8a:	7f 91       	pop	r23
     b8c:	6f 91       	pop	r22
     b8e:	5f 91       	pop	r21
     b90:	4f 91       	pop	r20
     b92:	3f 91       	pop	r19
     b94:	2f 91       	pop	r18
     b96:	1f 91       	pop	r17
     b98:	0f 91       	pop	r16
     b9a:	ff 90       	pop	r15
     b9c:	ef 90       	pop	r14
     b9e:	df 90       	pop	r13
     ba0:	cf 90       	pop	r12
     ba2:	bf 90       	pop	r11
     ba4:	af 90       	pop	r10
     ba6:	9f 90       	pop	r9
     ba8:	8f 90       	pop	r8
     baa:	7f 90       	pop	r7
     bac:	6f 90       	pop	r6
     bae:	5f 90       	pop	r5
     bb0:	4f 90       	pop	r4
     bb2:	3f 90       	pop	r3
     bb4:	2f 90       	pop	r2
     bb6:	1f 90       	pop	r1
     bb8:	0f 90       	pop	r0
     bba:	0c be       	out	0x3c, r0	; 60
     bbc:	0f 90       	pop	r0
     bbe:	0b be       	out	0x3b, r0	; 59
     bc0:	0f 90       	pop	r0
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     bc6:	08 95       	ret

00000bc8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     bc8:	0f 92       	push	r0
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	f8 94       	cli
     bce:	0f 92       	push	r0
     bd0:	0b b6       	in	r0, 0x3b	; 59
     bd2:	0f 92       	push	r0
     bd4:	0c b6       	in	r0, 0x3c	; 60
     bd6:	0f 92       	push	r0
     bd8:	1f 92       	push	r1
     bda:	11 24       	eor	r1, r1
     bdc:	2f 92       	push	r2
     bde:	3f 92       	push	r3
     be0:	4f 92       	push	r4
     be2:	5f 92       	push	r5
     be4:	6f 92       	push	r6
     be6:	7f 92       	push	r7
     be8:	8f 92       	push	r8
     bea:	9f 92       	push	r9
     bec:	af 92       	push	r10
     bee:	bf 92       	push	r11
     bf0:	cf 92       	push	r12
     bf2:	df 92       	push	r13
     bf4:	ef 92       	push	r14
     bf6:	ff 92       	push	r15
     bf8:	0f 93       	push	r16
     bfa:	1f 93       	push	r17
     bfc:	2f 93       	push	r18
     bfe:	3f 93       	push	r19
     c00:	4f 93       	push	r20
     c02:	5f 93       	push	r21
     c04:	6f 93       	push	r22
     c06:	7f 93       	push	r23
     c08:	8f 93       	push	r24
     c0a:	9f 93       	push	r25
     c0c:	af 93       	push	r26
     c0e:	bf 93       	push	r27
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ef 93       	push	r30
     c16:	ff 93       	push	r31
     c18:	a0 91 fe 0d 	lds	r26, 0x0DFE
     c1c:	b0 91 ff 0d 	lds	r27, 0x0DFF
     c20:	0d b6       	in	r0, 0x3d	; 61
     c22:	0d 92       	st	X+, r0
     c24:	0e b6       	in	r0, 0x3e	; 62
     c26:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
     c28:	80 91 40 02 	lds	r24, 0x0240
     c2c:	90 91 41 02 	lds	r25, 0x0241
     c30:	01 97       	sbiw	r24, 0x01	; 1
     c32:	90 93 41 02 	sts	0x0241, r25
     c36:	80 93 40 02 	sts	0x0240, r24
     c3a:	80 91 40 02 	lds	r24, 0x0240
     c3e:	90 91 41 02 	lds	r25, 0x0241
     c42:	89 2b       	or	r24, r25
     c44:	41 f4       	brne	.+16     	; 0xc56 <vPortYieldFromTick+0x8e>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
     c46:	80 91 3e 02 	lds	r24, 0x023E
     c4a:	90 91 3f 02 	lds	r25, 0x023F
     c4e:	90 93 41 02 	sts	0x0241, r25
     c52:	80 93 40 02 	sts	0x0240, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
     c56:	61 d5       	rcall	.+2754   	; 0x171a <xTaskIncrementTick>
     c58:	88 23       	and	r24, r24
     c5a:	09 f0       	breq	.+2      	; 0xc5e <vPortYieldFromTick+0x96>
	{
		vTaskSwitchContext();
     c5c:	4b d6       	rcall	.+3222   	; 0x18f4 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     c5e:	a0 91 fe 0d 	lds	r26, 0x0DFE
     c62:	b0 91 ff 0d 	lds	r27, 0x0DFF
     c66:	cd 91       	ld	r28, X+
     c68:	cd bf       	out	0x3d, r28	; 61
     c6a:	dd 91       	ld	r29, X+
     c6c:	de bf       	out	0x3e, r29	; 62
     c6e:	ff 91       	pop	r31
     c70:	ef 91       	pop	r30
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	bf 91       	pop	r27
     c78:	af 91       	pop	r26
     c7a:	9f 91       	pop	r25
     c7c:	8f 91       	pop	r24
     c7e:	7f 91       	pop	r23
     c80:	6f 91       	pop	r22
     c82:	5f 91       	pop	r21
     c84:	4f 91       	pop	r20
     c86:	3f 91       	pop	r19
     c88:	2f 91       	pop	r18
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	ff 90       	pop	r15
     c90:	ef 90       	pop	r14
     c92:	df 90       	pop	r13
     c94:	cf 90       	pop	r12
     c96:	bf 90       	pop	r11
     c98:	af 90       	pop	r10
     c9a:	9f 90       	pop	r9
     c9c:	8f 90       	pop	r8
     c9e:	7f 90       	pop	r7
     ca0:	6f 90       	pop	r6
     ca2:	5f 90       	pop	r5
     ca4:	4f 90       	pop	r4
     ca6:	3f 90       	pop	r3
     ca8:	2f 90       	pop	r2
     caa:	1f 90       	pop	r1
     cac:	0f 90       	pop	r0
     cae:	0c be       	out	0x3c, r0	; 60
     cb0:	0f 90       	pop	r0
     cb2:	0b be       	out	0x3b, r0	; 59
     cb4:	0f 90       	pop	r0
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     cba:	08 95       	ret

00000cbc <prvSetupTimerInterrupt>:
#ifndef portUSE_TIMER2
/*
 * Setup timer 0 or 1 or 3 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     cbc:	cf 93       	push	r28
     cbe:	df 93       	push	r29
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
     cc4:	2a 97       	sbiw	r28, 0x0a	; 10
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
    /* Using 8bit Timer0 or 16bit Timer1 or Timer3 to generate the tick. Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock.*/

    // ulCompareMatch 40,000 = 20,000,000 / 500; 20MHz
    // ulCompareMatch 110,592 = 22,118,400 / 200; 22.1184 MHz
    ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     cd0:	80 e1       	ldi	r24, 0x10	; 16
     cd2:	97 e2       	ldi	r25, 0x27	; 39
     cd4:	a0 e0       	ldi	r26, 0x00	; 0
     cd6:	b0 e0       	ldi	r27, 0x00	; 0
     cd8:	89 83       	std	Y+1, r24	; 0x01
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	ab 83       	std	Y+3, r26	; 0x03
     cde:	bc 83       	std	Y+4, r27	; 0x04

    /* We only have 8 or 16 bits so have to scale 64 or 256 to get our required tick rate. */
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;
     ce0:	89 81       	ldd	r24, Y+1	; 0x01
     ce2:	9a 81       	ldd	r25, Y+2	; 0x02
     ce4:	ab 81       	ldd	r26, Y+3	; 0x03
     ce6:	bc 81       	ldd	r27, Y+4	; 0x04
     ce8:	68 94       	set
     cea:	15 f8       	bld	r1, 5
     cec:	b6 95       	lsr	r27
     cee:	a7 95       	ror	r26
     cf0:	97 95       	ror	r25
     cf2:	87 95       	ror	r24
     cf4:	16 94       	lsr	r1
     cf6:	d1 f7       	brne	.-12     	; 0xcec <prvSetupTimerInterrupt+0x30>
     cf8:	89 83       	std	Y+1, r24	; 0x01
     cfa:	9a 83       	std	Y+2, r25	; 0x02
     cfc:	ab 83       	std	Y+3, r26	; 0x03
     cfe:	bc 83       	std	Y+4, r27	; 0x04

 	/* actual port tick rate in Hz, calculated */
	portTickRateHz = (TickType_t) ((uint32_t) configCPU_CLOCK_HZ / ( portCLOCK_PRESCALER * ulCompareMatch ));
     d00:	89 81       	ldd	r24, Y+1	; 0x01
     d02:	9a 81       	ldd	r25, Y+2	; 0x02
     d04:	ab 81       	ldd	r26, Y+3	; 0x03
     d06:	bc 81       	ldd	r27, Y+4	; 0x04
     d08:	88 0f       	add	r24, r24
     d0a:	99 1f       	adc	r25, r25
     d0c:	aa 1f       	adc	r26, r26
     d0e:	bb 1f       	adc	r27, r27
     d10:	88 0f       	add	r24, r24
     d12:	99 1f       	adc	r25, r25
     d14:	aa 1f       	adc	r26, r26
     d16:	bb 1f       	adc	r27, r27
     d18:	88 0f       	add	r24, r24
     d1a:	99 1f       	adc	r25, r25
     d1c:	aa 1f       	adc	r26, r26
     d1e:	bb 1f       	adc	r27, r27
     d20:	88 0f       	add	r24, r24
     d22:	99 1f       	adc	r25, r25
     d24:	aa 1f       	adc	r26, r26
     d26:	bb 1f       	adc	r27, r27
     d28:	88 0f       	add	r24, r24
     d2a:	99 1f       	adc	r25, r25
     d2c:	aa 1f       	adc	r26, r26
     d2e:	bb 1f       	adc	r27, r27
     d30:	88 0f       	add	r24, r24
     d32:	99 1f       	adc	r25, r25
     d34:	aa 1f       	adc	r26, r26
     d36:	bb 1f       	adc	r27, r27
     d38:	9c 01       	movw	r18, r24
     d3a:	ad 01       	movw	r20, r26
     d3c:	80 e8       	ldi	r24, 0x80	; 128
     d3e:	96 e9       	ldi	r25, 0x96	; 150
     d40:	a8 e9       	ldi	r26, 0x98	; 152
     d42:	b0 e0       	ldi	r27, 0x00	; 0
     d44:	bc 01       	movw	r22, r24
     d46:	cd 01       	movw	r24, r26
     d48:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <__udivmodsi4>
     d4c:	da 01       	movw	r26, r20
     d4e:	c9 01       	movw	r24, r18
     d50:	90 93 3f 02 	sts	0x023F, r25
     d54:	80 93 3e 02 	sts	0x023E, r24
	/* initialise first second of ticks */
	ticksRemainingInSec = portTickRateHz;
     d58:	80 91 3e 02 	lds	r24, 0x023E
     d5c:	90 91 3f 02 	lds	r25, 0x023F
     d60:	90 93 41 02 	sts	0x0241, r25
     d64:	80 93 40 02 	sts	0x0240, r24

    /* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     d68:	89 81       	ldd	r24, Y+1	; 0x01
     d6a:	9a 81       	ldd	r25, Y+2	; 0x02
     d6c:	ab 81       	ldd	r26, Y+3	; 0x03
     d6e:	bc 81       	ldd	r27, Y+4	; 0x04
     d70:	01 97       	sbiw	r24, 0x01	; 1
     d72:	a1 09       	sbc	r26, r1
     d74:	b1 09       	sbc	r27, r1
     d76:	89 83       	std	Y+1, r24	; 0x01
     d78:	9a 83       	std	Y+2, r25	; 0x02
     d7a:	ab 83       	std	Y+3, r26	; 0x03
     d7c:	bc 83       	std	Y+4, r27	; 0x04

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     d7e:	89 81       	ldd	r24, Y+1	; 0x01
     d80:	8d 83       	std	Y+5, r24	; 0x05
    //  OCR3AH = ucHighByte;
    //  OCR3AL = ucLowByte;

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH
    ulCompareMatch >>= 8;
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
     d86:	ab 81       	ldd	r26, Y+3	; 0x03
     d88:	bc 81       	ldd	r27, Y+4	; 0x04
     d8a:	89 2f       	mov	r24, r25
     d8c:	9a 2f       	mov	r25, r26
     d8e:	ab 2f       	mov	r26, r27
     d90:	bb 27       	eor	r27, r27
     d92:	89 83       	std	Y+1, r24	; 0x01
     d94:	9a 83       	std	Y+2, r25	; 0x02
     d96:	ab 83       	std	Y+3, r26	; 0x03
     d98:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t) 0xff );
     d9a:	89 81       	ldd	r24, Y+1	; 0x01
     d9c:	8e 83       	std	Y+6, r24	; 0x06
    portOCRH = ucHighByte;
     d9e:	89 e9       	ldi	r24, 0x99	; 153
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	2e 81       	ldd	r18, Y+6	; 0x06
     da4:	fc 01       	movw	r30, r24
     da6:	20 83       	st	Z, r18
#endif

    portOCRL = ucLowByte;
     da8:	88 e9       	ldi	r24, 0x98	; 152
     daa:	90 e0       	ldi	r25, 0x00	; 0
     dac:	2d 81       	ldd	r18, Y+5	; 0x05
     dae:	fc 01       	movw	r30, r24
     db0:	20 83       	st	Z, r18
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     db2:	8b e0       	ldi	r24, 0x0B	; 11
     db4:	8d 83       	std	Y+5, r24	; 0x05
	portTCCRb = ucLowByte;
     db6:	81 e9       	ldi	r24, 0x91	; 145
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	2d 81       	ldd	r18, Y+5	; 0x05
     dbc:	fc 01       	movw	r30, r24
     dbe:	20 83       	st	Z, r18
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     dc0:	81 e7       	ldi	r24, 0x71	; 113
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	fc 01       	movw	r30, r24
     dc6:	80 81       	ld	r24, Z
     dc8:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     dca:	8d 81       	ldd	r24, Y+5	; 0x05
     dcc:	82 60       	ori	r24, 0x02	; 2
     dce:	8d 83       	std	Y+5, r24	; 0x05
    portTIMSK = ucLowByte;
     dd0:	81 e7       	ldi	r24, 0x71	; 113
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	2d 81       	ldd	r18, Y+5	; 0x05
     dd6:	fc 01       	movw	r30, r24
     dd8:	20 83       	st	Z, r18

}
     dda:	2a 96       	adiw	r28, 0x0a	; 10
     ddc:	0f b6       	in	r0, 0x3f	; 63
     dde:	f8 94       	cli
     de0:	de bf       	out	0x3e, r29	; 62
     de2:	0f be       	out	0x3f, r0	; 63
     de4:	cd bf       	out	0x3d, r28	; 61
     de6:	df 91       	pop	r29
     de8:	cf 91       	pop	r28
     dea:	08 95       	ret

00000dec <__vector_32>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
     dec:	ed de       	rcall	.-550    	; 0xbc8 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     dee:	18 95       	reti

00000df0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	00 d0       	rcall	.+0      	; 0xdf6 <pvPortMalloc+0x6>
     df6:	1f 92       	push	r1
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	9c 83       	std	Y+4, r25	; 0x04
     dfe:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     e00:	1a 82       	std	Y+2, r1	; 0x02
     e02:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     e04:	db d3       	rcall	.+1974   	; 0x15bc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     e06:	80 91 fc 0d 	lds	r24, 0x0DFC
     e0a:	90 91 fd 0d 	lds	r25, 0x0DFD
     e0e:	89 2b       	or	r24, r25
     e10:	31 f4       	brne	.+12     	; 0xe1e <pvPortMalloc+0x2e>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e12:	83 e4       	ldi	r24, 0x43	; 67
     e14:	92 e0       	ldi	r25, 0x02	; 2
     e16:	90 93 fd 0d 	sts	0x0DFD, r25
     e1a:	80 93 fc 0d 	sts	0x0DFC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e1e:	20 91 fa 0d 	lds	r18, 0x0DFA
     e22:	30 91 fb 0d 	lds	r19, 0x0DFB
     e26:	8b 81       	ldd	r24, Y+3	; 0x03
     e28:	9c 81       	ldd	r25, Y+4	; 0x04
     e2a:	82 0f       	add	r24, r18
     e2c:	93 1f       	adc	r25, r19
     e2e:	87 3b       	cpi	r24, 0xB7	; 183
     e30:	9b 40       	sbci	r25, 0x0B	; 11
     e32:	38 f5       	brcc	.+78     	; 0xe82 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     e34:	20 91 fa 0d 	lds	r18, 0x0DFA
     e38:	30 91 fb 0d 	lds	r19, 0x0DFB
     e3c:	8b 81       	ldd	r24, Y+3	; 0x03
     e3e:	9c 81       	ldd	r25, Y+4	; 0x04
     e40:	28 0f       	add	r18, r24
     e42:	39 1f       	adc	r19, r25
     e44:	80 91 fa 0d 	lds	r24, 0x0DFA
     e48:	90 91 fb 0d 	lds	r25, 0x0DFB
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e4c:	82 17       	cp	r24, r18
     e4e:	93 07       	cpc	r25, r19
     e50:	c0 f4       	brcc	.+48     	; 0xe82 <pvPortMalloc+0x92>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     e52:	20 91 fc 0d 	lds	r18, 0x0DFC
     e56:	30 91 fd 0d 	lds	r19, 0x0DFD
     e5a:	80 91 fa 0d 	lds	r24, 0x0DFA
     e5e:	90 91 fb 0d 	lds	r25, 0x0DFB
     e62:	82 0f       	add	r24, r18
     e64:	93 1f       	adc	r25, r19
     e66:	9a 83       	std	Y+2, r25	; 0x02
     e68:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     e6a:	20 91 fa 0d 	lds	r18, 0x0DFA
     e6e:	30 91 fb 0d 	lds	r19, 0x0DFB
     e72:	8b 81       	ldd	r24, Y+3	; 0x03
     e74:	9c 81       	ldd	r25, Y+4	; 0x04
     e76:	82 0f       	add	r24, r18
     e78:	93 1f       	adc	r25, r19
     e7a:	90 93 fb 0d 	sts	0x0DFB, r25
     e7e:	80 93 fa 0d 	sts	0x0DFA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     e82:	a8 d3       	rcall	.+1872   	; 0x15d4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e88:	0f 90       	pop	r0
     e8a:	0f 90       	pop	r0
     e8c:	0f 90       	pop	r0
     e8e:	0f 90       	pop	r0
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	08 95       	ret

00000e96 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	1f 92       	push	r1
     e9c:	1f 92       	push	r1
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	9a 83       	std	Y+2, r25	; 0x02
     ea4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <xQueueGenericSendFromISR>:
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
}
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	2b 97       	sbiw	r28, 0x0b	; 11
     eba:	0f b6       	in	r0, 0x3f	; 63
     ebc:	f8 94       	cli
     ebe:	de bf       	out	0x3e, r29	; 62
     ec0:	0f be       	out	0x3f, r0	; 63
     ec2:	cd bf       	out	0x3d, r28	; 61
     ec4:	9e 83       	std	Y+6, r25	; 0x06
     ec6:	8d 83       	std	Y+5, r24	; 0x05
     ec8:	78 87       	std	Y+8, r23	; 0x08
     eca:	6f 83       	std	Y+7, r22	; 0x07
     ecc:	5a 87       	std	Y+10, r21	; 0x0a
     ece:	49 87       	std	Y+9, r20	; 0x09
     ed0:	2b 87       	std	Y+11, r18	; 0x0b
     ed2:	8d 81       	ldd	r24, Y+5	; 0x05
     ed4:	9e 81       	ldd	r25, Y+6	; 0x06
     ed6:	9b 83       	std	Y+3, r25	; 0x03
     ed8:	8a 83       	std	Y+2, r24	; 0x02
     eda:	1c 82       	std	Y+4, r1	; 0x04
     edc:	8a 81       	ldd	r24, Y+2	; 0x02
     ede:	9b 81       	ldd	r25, Y+3	; 0x03
     ee0:	fc 01       	movw	r30, r24
     ee2:	22 8d       	ldd	r18, Z+26	; 0x1a
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	9b 81       	ldd	r25, Y+3	; 0x03
     ee8:	fc 01       	movw	r30, r24
     eea:	83 8d       	ldd	r24, Z+27	; 0x1b
     eec:	28 17       	cp	r18, r24
     eee:	18 f0       	brcs	.+6      	; 0xef6 <xQueueGenericSendFromISR+0x46>
     ef0:	8b 85       	ldd	r24, Y+11	; 0x0b
     ef2:	82 30       	cpi	r24, 0x02	; 2
     ef4:	81 f5       	brne	.+96     	; 0xf56 <xQueueGenericSendFromISR+0xa6>
     ef6:	2f 81       	ldd	r18, Y+7	; 0x07
     ef8:	38 85       	ldd	r19, Y+8	; 0x08
     efa:	8a 81       	ldd	r24, Y+2	; 0x02
     efc:	9b 81       	ldd	r25, Y+3	; 0x03
     efe:	4b 85       	ldd	r20, Y+11	; 0x0b
     f00:	b9 01       	movw	r22, r18
     f02:	93 d0       	rcall	.+294    	; 0x102a <prvCopyDataToQueue>
     f04:	8a 81       	ldd	r24, Y+2	; 0x02
     f06:	9b 81       	ldd	r25, Y+3	; 0x03
     f08:	fc 01       	movw	r30, r24
     f0a:	86 8d       	ldd	r24, Z+30	; 0x1e
     f0c:	8f 3f       	cpi	r24, 0xFF	; 255
     f0e:	b1 f4       	brne	.+44     	; 0xf3c <xQueueGenericSendFromISR+0x8c>
     f10:	8a 81       	ldd	r24, Y+2	; 0x02
     f12:	9b 81       	ldd	r25, Y+3	; 0x03
     f14:	fc 01       	movw	r30, r24
     f16:	81 89       	ldd	r24, Z+17	; 0x11
     f18:	88 23       	and	r24, r24
     f1a:	d1 f0       	breq	.+52     	; 0xf50 <xQueueGenericSendFromISR+0xa0>
     f1c:	8a 81       	ldd	r24, Y+2	; 0x02
     f1e:	9b 81       	ldd	r25, Y+3	; 0x03
     f20:	41 96       	adiw	r24, 0x11	; 17
     f22:	76 d5       	rcall	.+2796   	; 0x1a10 <xTaskRemoveFromEventList>
     f24:	88 23       	and	r24, r24
     f26:	a1 f0       	breq	.+40     	; 0xf50 <xQueueGenericSendFromISR+0xa0>
     f28:	89 85       	ldd	r24, Y+9	; 0x09
     f2a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f2c:	89 2b       	or	r24, r25
     f2e:	81 f0       	breq	.+32     	; 0xf50 <xQueueGenericSendFromISR+0xa0>
     f30:	89 85       	ldd	r24, Y+9	; 0x09
     f32:	9a 85       	ldd	r25, Y+10	; 0x0a
     f34:	21 e0       	ldi	r18, 0x01	; 1
     f36:	fc 01       	movw	r30, r24
     f38:	20 83       	st	Z, r18
     f3a:	0a c0       	rjmp	.+20     	; 0xf50 <xQueueGenericSendFromISR+0xa0>
     f3c:	8a 81       	ldd	r24, Y+2	; 0x02
     f3e:	9b 81       	ldd	r25, Y+3	; 0x03
     f40:	fc 01       	movw	r30, r24
     f42:	86 8d       	ldd	r24, Z+30	; 0x1e
     f44:	8f 5f       	subi	r24, 0xFF	; 255
     f46:	28 2f       	mov	r18, r24
     f48:	8a 81       	ldd	r24, Y+2	; 0x02
     f4a:	9b 81       	ldd	r25, Y+3	; 0x03
     f4c:	fc 01       	movw	r30, r24
     f4e:	26 8f       	std	Z+30, r18	; 0x1e
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	89 83       	std	Y+1, r24	; 0x01
     f54:	01 c0       	rjmp	.+2      	; 0xf58 <xQueueGenericSendFromISR+0xa8>
     f56:	19 82       	std	Y+1, r1	; 0x01
     f58:	89 81       	ldd	r24, Y+1	; 0x01
     f5a:	2b 96       	adiw	r28, 0x0b	; 11
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	08 95       	ret

00000f6c <xQueueReceiveFromISR>:
     f6c:	cf 93       	push	r28
     f6e:	df 93       	push	r29
     f70:	cd b7       	in	r28, 0x3d	; 61
     f72:	de b7       	in	r29, 0x3e	; 62
     f74:	2a 97       	sbiw	r28, 0x0a	; 10
     f76:	0f b6       	in	r0, 0x3f	; 63
     f78:	f8 94       	cli
     f7a:	de bf       	out	0x3e, r29	; 62
     f7c:	0f be       	out	0x3f, r0	; 63
     f7e:	cd bf       	out	0x3d, r28	; 61
     f80:	9e 83       	std	Y+6, r25	; 0x06
     f82:	8d 83       	std	Y+5, r24	; 0x05
     f84:	78 87       	std	Y+8, r23	; 0x08
     f86:	6f 83       	std	Y+7, r22	; 0x07
     f88:	5a 87       	std	Y+10, r21	; 0x0a
     f8a:	49 87       	std	Y+9, r20	; 0x09
     f8c:	8d 81       	ldd	r24, Y+5	; 0x05
     f8e:	9e 81       	ldd	r25, Y+6	; 0x06
     f90:	9b 83       	std	Y+3, r25	; 0x03
     f92:	8a 83       	std	Y+2, r24	; 0x02
     f94:	1c 82       	std	Y+4, r1	; 0x04
     f96:	8a 81       	ldd	r24, Y+2	; 0x02
     f98:	9b 81       	ldd	r25, Y+3	; 0x03
     f9a:	fc 01       	movw	r30, r24
     f9c:	82 8d       	ldd	r24, Z+26	; 0x1a
     f9e:	88 23       	and	r24, r24
     fa0:	c9 f1       	breq	.+114    	; 0x1014 <xQueueReceiveFromISR+0xa8>
     fa2:	2f 81       	ldd	r18, Y+7	; 0x07
     fa4:	38 85       	ldd	r19, Y+8	; 0x08
     fa6:	8a 81       	ldd	r24, Y+2	; 0x02
     fa8:	9b 81       	ldd	r25, Y+3	; 0x03
     faa:	b9 01       	movw	r22, r18
     fac:	fd d0       	rcall	.+506    	; 0x11a8 <prvCopyDataFromQueue>
     fae:	8a 81       	ldd	r24, Y+2	; 0x02
     fb0:	9b 81       	ldd	r25, Y+3	; 0x03
     fb2:	fc 01       	movw	r30, r24
     fb4:	82 8d       	ldd	r24, Z+26	; 0x1a
     fb6:	2f ef       	ldi	r18, 0xFF	; 255
     fb8:	28 0f       	add	r18, r24
     fba:	8a 81       	ldd	r24, Y+2	; 0x02
     fbc:	9b 81       	ldd	r25, Y+3	; 0x03
     fbe:	fc 01       	movw	r30, r24
     fc0:	22 8f       	std	Z+26, r18	; 0x1a
     fc2:	8a 81       	ldd	r24, Y+2	; 0x02
     fc4:	9b 81       	ldd	r25, Y+3	; 0x03
     fc6:	fc 01       	movw	r30, r24
     fc8:	85 8d       	ldd	r24, Z+29	; 0x1d
     fca:	8f 3f       	cpi	r24, 0xFF	; 255
     fcc:	b1 f4       	brne	.+44     	; 0xffa <xQueueReceiveFromISR+0x8e>
     fce:	8a 81       	ldd	r24, Y+2	; 0x02
     fd0:	9b 81       	ldd	r25, Y+3	; 0x03
     fd2:	fc 01       	movw	r30, r24
     fd4:	80 85       	ldd	r24, Z+8	; 0x08
     fd6:	88 23       	and	r24, r24
     fd8:	d1 f0       	breq	.+52     	; 0x100e <xQueueReceiveFromISR+0xa2>
     fda:	8a 81       	ldd	r24, Y+2	; 0x02
     fdc:	9b 81       	ldd	r25, Y+3	; 0x03
     fde:	08 96       	adiw	r24, 0x08	; 8
     fe0:	17 d5       	rcall	.+2606   	; 0x1a10 <xTaskRemoveFromEventList>
     fe2:	88 23       	and	r24, r24
     fe4:	a1 f0       	breq	.+40     	; 0x100e <xQueueReceiveFromISR+0xa2>
     fe6:	89 85       	ldd	r24, Y+9	; 0x09
     fe8:	9a 85       	ldd	r25, Y+10	; 0x0a
     fea:	89 2b       	or	r24, r25
     fec:	81 f0       	breq	.+32     	; 0x100e <xQueueReceiveFromISR+0xa2>
     fee:	89 85       	ldd	r24, Y+9	; 0x09
     ff0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ff2:	21 e0       	ldi	r18, 0x01	; 1
     ff4:	fc 01       	movw	r30, r24
     ff6:	20 83       	st	Z, r18
     ff8:	0a c0       	rjmp	.+20     	; 0x100e <xQueueReceiveFromISR+0xa2>
     ffa:	8a 81       	ldd	r24, Y+2	; 0x02
     ffc:	9b 81       	ldd	r25, Y+3	; 0x03
     ffe:	fc 01       	movw	r30, r24
    1000:	85 8d       	ldd	r24, Z+29	; 0x1d
    1002:	8f 5f       	subi	r24, 0xFF	; 255
    1004:	28 2f       	mov	r18, r24
    1006:	8a 81       	ldd	r24, Y+2	; 0x02
    1008:	9b 81       	ldd	r25, Y+3	; 0x03
    100a:	fc 01       	movw	r30, r24
    100c:	25 8f       	std	Z+29, r18	; 0x1d
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	89 83       	std	Y+1, r24	; 0x01
    1012:	01 c0       	rjmp	.+2      	; 0x1016 <xQueueReceiveFromISR+0xaa>
    1014:	19 82       	std	Y+1, r1	; 0x01
    1016:	89 81       	ldd	r24, Y+1	; 0x01
    1018:	2a 96       	adiw	r28, 0x0a	; 10
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	08 95       	ret

0000102a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	00 d0       	rcall	.+0      	; 0x1030 <prvCopyDataToQueue+0x6>
    1030:	00 d0       	rcall	.+0      	; 0x1032 <prvCopyDataToQueue+0x8>
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9b 83       	std	Y+3, r25	; 0x03
    1038:	8a 83       	std	Y+2, r24	; 0x02
    103a:	7d 83       	std	Y+5, r23	; 0x05
    103c:	6c 83       	std	Y+4, r22	; 0x04
    103e:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    1040:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1042:	8a 81       	ldd	r24, Y+2	; 0x02
    1044:	9b 81       	ldd	r25, Y+3	; 0x03
    1046:	fc 01       	movw	r30, r24
    1048:	84 8d       	ldd	r24, Z+28	; 0x1c
    104a:	88 23       	and	r24, r24
    104c:	09 f4       	brne	.+2      	; 0x1050 <prvCopyDataToQueue+0x26>
    104e:	98 c0       	rjmp	.+304    	; 0x1180 <prvCopyDataToQueue+0x156>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1050:	8e 81       	ldd	r24, Y+6	; 0x06
    1052:	88 23       	and	r24, r24
    1054:	d9 f5       	brne	.+118    	; 0x10cc <prvCopyDataToQueue+0xa2>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1056:	8a 81       	ldd	r24, Y+2	; 0x02
    1058:	9b 81       	ldd	r25, Y+3	; 0x03
    105a:	fc 01       	movw	r30, r24
    105c:	84 8d       	ldd	r24, Z+28	; 0x1c
    105e:	48 2f       	mov	r20, r24
    1060:	50 e0       	ldi	r21, 0x00	; 0
    1062:	8a 81       	ldd	r24, Y+2	; 0x02
    1064:	9b 81       	ldd	r25, Y+3	; 0x03
    1066:	fc 01       	movw	r30, r24
    1068:	84 81       	ldd	r24, Z+4	; 0x04
    106a:	95 81       	ldd	r25, Z+5	; 0x05
    106c:	2c 81       	ldd	r18, Y+4	; 0x04
    106e:	3d 81       	ldd	r19, Y+5	; 0x05
    1070:	b9 01       	movw	r22, r18
    1072:	0e 94 03 11 	call	0x2206	; 0x2206 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	9b 81       	ldd	r25, Y+3	; 0x03
    107a:	fc 01       	movw	r30, r24
    107c:	24 81       	ldd	r18, Z+4	; 0x04
    107e:	35 81       	ldd	r19, Z+5	; 0x05
    1080:	8a 81       	ldd	r24, Y+2	; 0x02
    1082:	9b 81       	ldd	r25, Y+3	; 0x03
    1084:	fc 01       	movw	r30, r24
    1086:	84 8d       	ldd	r24, Z+28	; 0x1c
    1088:	88 2f       	mov	r24, r24
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	28 0f       	add	r18, r24
    108e:	39 1f       	adc	r19, r25
    1090:	8a 81       	ldd	r24, Y+2	; 0x02
    1092:	9b 81       	ldd	r25, Y+3	; 0x03
    1094:	fc 01       	movw	r30, r24
    1096:	35 83       	std	Z+5, r19	; 0x05
    1098:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    109a:	8a 81       	ldd	r24, Y+2	; 0x02
    109c:	9b 81       	ldd	r25, Y+3	; 0x03
    109e:	fc 01       	movw	r30, r24
    10a0:	24 81       	ldd	r18, Z+4	; 0x04
    10a2:	35 81       	ldd	r19, Z+5	; 0x05
    10a4:	8a 81       	ldd	r24, Y+2	; 0x02
    10a6:	9b 81       	ldd	r25, Y+3	; 0x03
    10a8:	fc 01       	movw	r30, r24
    10aa:	82 81       	ldd	r24, Z+2	; 0x02
    10ac:	93 81       	ldd	r25, Z+3	; 0x03
    10ae:	28 17       	cp	r18, r24
    10b0:	39 07       	cpc	r19, r25
    10b2:	08 f4       	brcc	.+2      	; 0x10b6 <prvCopyDataToQueue+0x8c>
    10b4:	65 c0       	rjmp	.+202    	; 0x1180 <prvCopyDataToQueue+0x156>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    10b6:	8a 81       	ldd	r24, Y+2	; 0x02
    10b8:	9b 81       	ldd	r25, Y+3	; 0x03
    10ba:	fc 01       	movw	r30, r24
    10bc:	20 81       	ld	r18, Z
    10be:	31 81       	ldd	r19, Z+1	; 0x01
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	9b 81       	ldd	r25, Y+3	; 0x03
    10c4:	fc 01       	movw	r30, r24
    10c6:	35 83       	std	Z+5, r19	; 0x05
    10c8:	24 83       	std	Z+4, r18	; 0x04
    10ca:	5a c0       	rjmp	.+180    	; 0x1180 <prvCopyDataToQueue+0x156>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10cc:	8a 81       	ldd	r24, Y+2	; 0x02
    10ce:	9b 81       	ldd	r25, Y+3	; 0x03
    10d0:	fc 01       	movw	r30, r24
    10d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    10d4:	48 2f       	mov	r20, r24
    10d6:	50 e0       	ldi	r21, 0x00	; 0
    10d8:	8a 81       	ldd	r24, Y+2	; 0x02
    10da:	9b 81       	ldd	r25, Y+3	; 0x03
    10dc:	fc 01       	movw	r30, r24
    10de:	86 81       	ldd	r24, Z+6	; 0x06
    10e0:	97 81       	ldd	r25, Z+7	; 0x07
    10e2:	2c 81       	ldd	r18, Y+4	; 0x04
    10e4:	3d 81       	ldd	r19, Y+5	; 0x05
    10e6:	b9 01       	movw	r22, r18
    10e8:	0e 94 03 11 	call	0x2206	; 0x2206 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    10ec:	8a 81       	ldd	r24, Y+2	; 0x02
    10ee:	9b 81       	ldd	r25, Y+3	; 0x03
    10f0:	fc 01       	movw	r30, r24
    10f2:	26 81       	ldd	r18, Z+6	; 0x06
    10f4:	37 81       	ldd	r19, Z+7	; 0x07
    10f6:	8a 81       	ldd	r24, Y+2	; 0x02
    10f8:	9b 81       	ldd	r25, Y+3	; 0x03
    10fa:	fc 01       	movw	r30, r24
    10fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    10fe:	88 2f       	mov	r24, r24
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	91 95       	neg	r25
    1104:	81 95       	neg	r24
    1106:	91 09       	sbc	r25, r1
    1108:	28 0f       	add	r18, r24
    110a:	39 1f       	adc	r19, r25
    110c:	8a 81       	ldd	r24, Y+2	; 0x02
    110e:	9b 81       	ldd	r25, Y+3	; 0x03
    1110:	fc 01       	movw	r30, r24
    1112:	37 83       	std	Z+7, r19	; 0x07
    1114:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1116:	8a 81       	ldd	r24, Y+2	; 0x02
    1118:	9b 81       	ldd	r25, Y+3	; 0x03
    111a:	fc 01       	movw	r30, r24
    111c:	26 81       	ldd	r18, Z+6	; 0x06
    111e:	37 81       	ldd	r19, Z+7	; 0x07
    1120:	8a 81       	ldd	r24, Y+2	; 0x02
    1122:	9b 81       	ldd	r25, Y+3	; 0x03
    1124:	fc 01       	movw	r30, r24
    1126:	80 81       	ld	r24, Z
    1128:	91 81       	ldd	r25, Z+1	; 0x01
    112a:	28 17       	cp	r18, r24
    112c:	39 07       	cpc	r19, r25
    112e:	a8 f4       	brcc	.+42     	; 0x115a <prvCopyDataToQueue+0x130>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1130:	8a 81       	ldd	r24, Y+2	; 0x02
    1132:	9b 81       	ldd	r25, Y+3	; 0x03
    1134:	fc 01       	movw	r30, r24
    1136:	22 81       	ldd	r18, Z+2	; 0x02
    1138:	33 81       	ldd	r19, Z+3	; 0x03
    113a:	8a 81       	ldd	r24, Y+2	; 0x02
    113c:	9b 81       	ldd	r25, Y+3	; 0x03
    113e:	fc 01       	movw	r30, r24
    1140:	84 8d       	ldd	r24, Z+28	; 0x1c
    1142:	88 2f       	mov	r24, r24
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	91 95       	neg	r25
    1148:	81 95       	neg	r24
    114a:	91 09       	sbc	r25, r1
    114c:	28 0f       	add	r18, r24
    114e:	39 1f       	adc	r19, r25
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	9b 81       	ldd	r25, Y+3	; 0x03
    1154:	fc 01       	movw	r30, r24
    1156:	37 83       	std	Z+7, r19	; 0x07
    1158:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    115a:	8e 81       	ldd	r24, Y+6	; 0x06
    115c:	82 30       	cpi	r24, 0x02	; 2
    115e:	81 f4       	brne	.+32     	; 0x1180 <prvCopyDataToQueue+0x156>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1160:	8a 81       	ldd	r24, Y+2	; 0x02
    1162:	9b 81       	ldd	r25, Y+3	; 0x03
    1164:	fc 01       	movw	r30, r24
    1166:	82 8d       	ldd	r24, Z+26	; 0x1a
    1168:	88 23       	and	r24, r24
    116a:	51 f0       	breq	.+20     	; 0x1180 <prvCopyDataToQueue+0x156>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    116c:	8a 81       	ldd	r24, Y+2	; 0x02
    116e:	9b 81       	ldd	r25, Y+3	; 0x03
    1170:	fc 01       	movw	r30, r24
    1172:	82 8d       	ldd	r24, Z+26	; 0x1a
    1174:	2f ef       	ldi	r18, 0xFF	; 255
    1176:	28 0f       	add	r18, r24
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	fc 01       	movw	r30, r24
    117e:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1180:	8a 81       	ldd	r24, Y+2	; 0x02
    1182:	9b 81       	ldd	r25, Y+3	; 0x03
    1184:	fc 01       	movw	r30, r24
    1186:	82 8d       	ldd	r24, Z+26	; 0x1a
    1188:	21 e0       	ldi	r18, 0x01	; 1
    118a:	28 0f       	add	r18, r24
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	9b 81       	ldd	r25, Y+3	; 0x03
    1190:	fc 01       	movw	r30, r24
    1192:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    1194:	89 81       	ldd	r24, Y+1	; 0x01
}
    1196:	26 96       	adiw	r28, 0x06	; 6
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	de bf       	out	0x3e, r29	; 62
    119e:	0f be       	out	0x3f, r0	; 63
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	08 95       	ret

000011a8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	00 d0       	rcall	.+0      	; 0x11ae <prvCopyDataFromQueue+0x6>
    11ae:	1f 92       	push	r1
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
    11b4:	9a 83       	std	Y+2, r25	; 0x02
    11b6:	89 83       	std	Y+1, r24	; 0x01
    11b8:	7c 83       	std	Y+4, r23	; 0x04
    11ba:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    11bc:	89 81       	ldd	r24, Y+1	; 0x01
    11be:	9a 81       	ldd	r25, Y+2	; 0x02
    11c0:	fc 01       	movw	r30, r24
    11c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    11c4:	88 23       	and	r24, r24
    11c6:	c1 f1       	breq	.+112    	; 0x1238 <prvCopyDataFromQueue+0x90>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    11c8:	89 81       	ldd	r24, Y+1	; 0x01
    11ca:	9a 81       	ldd	r25, Y+2	; 0x02
    11cc:	fc 01       	movw	r30, r24
    11ce:	26 81       	ldd	r18, Z+6	; 0x06
    11d0:	37 81       	ldd	r19, Z+7	; 0x07
    11d2:	89 81       	ldd	r24, Y+1	; 0x01
    11d4:	9a 81       	ldd	r25, Y+2	; 0x02
    11d6:	fc 01       	movw	r30, r24
    11d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    11da:	88 2f       	mov	r24, r24
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	28 0f       	add	r18, r24
    11e0:	39 1f       	adc	r19, r25
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
    11e6:	fc 01       	movw	r30, r24
    11e8:	37 83       	std	Z+7, r19	; 0x07
    11ea:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    11ec:	89 81       	ldd	r24, Y+1	; 0x01
    11ee:	9a 81       	ldd	r25, Y+2	; 0x02
    11f0:	fc 01       	movw	r30, r24
    11f2:	26 81       	ldd	r18, Z+6	; 0x06
    11f4:	37 81       	ldd	r19, Z+7	; 0x07
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	9a 81       	ldd	r25, Y+2	; 0x02
    11fa:	fc 01       	movw	r30, r24
    11fc:	82 81       	ldd	r24, Z+2	; 0x02
    11fe:	93 81       	ldd	r25, Z+3	; 0x03
    1200:	28 17       	cp	r18, r24
    1202:	39 07       	cpc	r19, r25
    1204:	50 f0       	brcs	.+20     	; 0x121a <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1206:	89 81       	ldd	r24, Y+1	; 0x01
    1208:	9a 81       	ldd	r25, Y+2	; 0x02
    120a:	fc 01       	movw	r30, r24
    120c:	20 81       	ld	r18, Z
    120e:	31 81       	ldd	r19, Z+1	; 0x01
    1210:	89 81       	ldd	r24, Y+1	; 0x01
    1212:	9a 81       	ldd	r25, Y+2	; 0x02
    1214:	fc 01       	movw	r30, r24
    1216:	37 83       	std	Z+7, r19	; 0x07
    1218:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    121a:	89 81       	ldd	r24, Y+1	; 0x01
    121c:	9a 81       	ldd	r25, Y+2	; 0x02
    121e:	fc 01       	movw	r30, r24
    1220:	84 8d       	ldd	r24, Z+28	; 0x1c
    1222:	48 2f       	mov	r20, r24
    1224:	50 e0       	ldi	r21, 0x00	; 0
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	9a 81       	ldd	r25, Y+2	; 0x02
    122a:	fc 01       	movw	r30, r24
    122c:	26 81       	ldd	r18, Z+6	; 0x06
    122e:	37 81       	ldd	r19, Z+7	; 0x07
    1230:	8b 81       	ldd	r24, Y+3	; 0x03
    1232:	9c 81       	ldd	r25, Y+4	; 0x04
    1234:	b9 01       	movw	r22, r18
    1236:	e7 d7       	rcall	.+4046   	; 0x2206 <memcpy>
	}
}
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	08 95       	ret

00001246 <xTaskGenericCreate>:
    1246:	af 92       	push	r10
    1248:	bf 92       	push	r11
    124a:	cf 92       	push	r12
    124c:	df 92       	push	r13
    124e:	ef 92       	push	r14
    1250:	ff 92       	push	r15
    1252:	0f 93       	push	r16
    1254:	1f 93       	push	r17
    1256:	cf 93       	push	r28
    1258:	df 93       	push	r29
    125a:	cd b7       	in	r28, 0x3d	; 61
    125c:	de b7       	in	r29, 0x3e	; 62
    125e:	64 97       	sbiw	r28, 0x14	; 20
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	de bf       	out	0x3e, r29	; 62
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	cd bf       	out	0x3d, r28	; 61
    126a:	9f 83       	std	Y+7, r25	; 0x07
    126c:	8e 83       	std	Y+6, r24	; 0x06
    126e:	79 87       	std	Y+9, r23	; 0x09
    1270:	68 87       	std	Y+8, r22	; 0x08
    1272:	5b 87       	std	Y+11, r21	; 0x0b
    1274:	4a 87       	std	Y+10, r20	; 0x0a
    1276:	3d 87       	std	Y+13, r19	; 0x0d
    1278:	2c 87       	std	Y+12, r18	; 0x0c
    127a:	0e 87       	std	Y+14, r16	; 0x0e
    127c:	f8 8a       	std	Y+16, r15	; 0x10
    127e:	ef 86       	std	Y+15, r14	; 0x0f
    1280:	da 8a       	std	Y+18, r13	; 0x12
    1282:	c9 8a       	std	Y+17, r12	; 0x11
    1284:	bc 8a       	std	Y+20, r11	; 0x14
    1286:	ab 8a       	std	Y+19, r10	; 0x13
    1288:	29 89       	ldd	r18, Y+17	; 0x11
    128a:	3a 89       	ldd	r19, Y+18	; 0x12
    128c:	8a 85       	ldd	r24, Y+10	; 0x0a
    128e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1290:	b9 01       	movw	r22, r18
    1292:	73 d5       	rcall	.+2790   	; 0x1d7a <prvAllocateTCBAndStack>
    1294:	9b 83       	std	Y+3, r25	; 0x03
    1296:	8a 83       	std	Y+2, r24	; 0x02
    1298:	8a 81       	ldd	r24, Y+2	; 0x02
    129a:	9b 81       	ldd	r25, Y+3	; 0x03
    129c:	89 2b       	or	r24, r25
    129e:	09 f4       	brne	.+2      	; 0x12a2 <xTaskGenericCreate+0x5c>
    12a0:	8e c0       	rjmp	.+284    	; 0x13be <xTaskGenericCreate+0x178>
    12a2:	8a 81       	ldd	r24, Y+2	; 0x02
    12a4:	9b 81       	ldd	r25, Y+3	; 0x03
    12a6:	fc 01       	movw	r30, r24
    12a8:	27 89       	ldd	r18, Z+23	; 0x17
    12aa:	30 8d       	ldd	r19, Z+24	; 0x18
    12ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    12ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    12b0:	01 97       	sbiw	r24, 0x01	; 1
    12b2:	82 0f       	add	r24, r18
    12b4:	93 1f       	adc	r25, r19
    12b6:	9d 83       	std	Y+5, r25	; 0x05
    12b8:	8c 83       	std	Y+4, r24	; 0x04
    12ba:	4a 85       	ldd	r20, Y+10	; 0x0a
    12bc:	5b 85       	ldd	r21, Y+11	; 0x0b
    12be:	2b 89       	ldd	r18, Y+19	; 0x13
    12c0:	3c 89       	ldd	r19, Y+20	; 0x14
    12c2:	68 85       	ldd	r22, Y+8	; 0x08
    12c4:	79 85       	ldd	r23, Y+9	; 0x09
    12c6:	8a 81       	ldd	r24, Y+2	; 0x02
    12c8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ca:	8a 01       	movw	r16, r20
    12cc:	4e 85       	ldd	r20, Y+14	; 0x0e
    12ce:	0d d4       	rcall	.+2074   	; 0x1aea <prvInitialiseTCBVariables>
    12d0:	4c 85       	ldd	r20, Y+12	; 0x0c
    12d2:	5d 85       	ldd	r21, Y+13	; 0x0d
    12d4:	2e 81       	ldd	r18, Y+6	; 0x06
    12d6:	3f 81       	ldd	r19, Y+7	; 0x07
    12d8:	8c 81       	ldd	r24, Y+4	; 0x04
    12da:	9d 81       	ldd	r25, Y+5	; 0x05
    12dc:	b9 01       	movw	r22, r18
    12de:	18 da       	rcall	.-3024   	; 0x710 <pxPortInitialiseStack>
    12e0:	9c 01       	movw	r18, r24
    12e2:	8a 81       	ldd	r24, Y+2	; 0x02
    12e4:	9b 81       	ldd	r25, Y+3	; 0x03
    12e6:	fc 01       	movw	r30, r24
    12e8:	31 83       	std	Z+1, r19	; 0x01
    12ea:	20 83       	st	Z, r18
    12ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    12ee:	98 89       	ldd	r25, Y+16	; 0x10
    12f0:	89 2b       	or	r24, r25
    12f2:	39 f0       	breq	.+14     	; 0x1302 <xTaskGenericCreate+0xbc>
    12f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    12f6:	98 89       	ldd	r25, Y+16	; 0x10
    12f8:	2a 81       	ldd	r18, Y+2	; 0x02
    12fa:	3b 81       	ldd	r19, Y+3	; 0x03
    12fc:	fc 01       	movw	r30, r24
    12fe:	31 83       	std	Z+1, r19	; 0x01
    1300:	20 83       	st	Z, r18
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	f8 94       	cli
    1306:	0f 92       	push	r0
    1308:	80 91 4d 0e 	lds	r24, 0x0E4D
    130c:	8f 5f       	subi	r24, 0xFF	; 255
    130e:	80 93 4d 0e 	sts	0x0E4D, r24
    1312:	80 91 fe 0d 	lds	r24, 0x0DFE
    1316:	90 91 ff 0d 	lds	r25, 0x0DFF
    131a:	89 2b       	or	r24, r25
    131c:	61 f4       	brne	.+24     	; 0x1336 <xTaskGenericCreate+0xf0>
    131e:	8a 81       	ldd	r24, Y+2	; 0x02
    1320:	9b 81       	ldd	r25, Y+3	; 0x03
    1322:	90 93 ff 0d 	sts	0x0DFF, r25
    1326:	80 93 fe 0d 	sts	0x0DFE, r24
    132a:	80 91 4d 0e 	lds	r24, 0x0E4D
    132e:	81 30       	cpi	r24, 0x01	; 1
    1330:	a9 f4       	brne	.+42     	; 0x135c <xTaskGenericCreate+0x116>
    1332:	5f d4       	rcall	.+2238   	; 0x1bf2 <prvInitialiseTaskLists>
    1334:	13 c0       	rjmp	.+38     	; 0x135c <xTaskGenericCreate+0x116>
    1336:	80 91 51 0e 	lds	r24, 0x0E51
    133a:	88 23       	and	r24, r24
    133c:	79 f4       	brne	.+30     	; 0x135c <xTaskGenericCreate+0x116>
    133e:	80 91 fe 0d 	lds	r24, 0x0DFE
    1342:	90 91 ff 0d 	lds	r25, 0x0DFF
    1346:	fc 01       	movw	r30, r24
    1348:	96 89       	ldd	r25, Z+22	; 0x16
    134a:	8e 85       	ldd	r24, Y+14	; 0x0e
    134c:	89 17       	cp	r24, r25
    134e:	30 f0       	brcs	.+12     	; 0x135c <xTaskGenericCreate+0x116>
    1350:	8a 81       	ldd	r24, Y+2	; 0x02
    1352:	9b 81       	ldd	r25, Y+3	; 0x03
    1354:	90 93 ff 0d 	sts	0x0DFF, r25
    1358:	80 93 fe 0d 	sts	0x0DFE, r24
    135c:	80 91 55 0e 	lds	r24, 0x0E55
    1360:	8f 5f       	subi	r24, 0xFF	; 255
    1362:	80 93 55 0e 	sts	0x0E55, r24
    1366:	8a 81       	ldd	r24, Y+2	; 0x02
    1368:	9b 81       	ldd	r25, Y+3	; 0x03
    136a:	fc 01       	movw	r30, r24
    136c:	96 89       	ldd	r25, Z+22	; 0x16
    136e:	80 91 50 0e 	lds	r24, 0x0E50
    1372:	89 17       	cp	r24, r25
    1374:	30 f4       	brcc	.+12     	; 0x1382 <xTaskGenericCreate+0x13c>
    1376:	8a 81       	ldd	r24, Y+2	; 0x02
    1378:	9b 81       	ldd	r25, Y+3	; 0x03
    137a:	fc 01       	movw	r30, r24
    137c:	86 89       	ldd	r24, Z+22	; 0x16
    137e:	80 93 50 0e 	sts	0x0E50, r24
    1382:	8a 81       	ldd	r24, Y+2	; 0x02
    1384:	9b 81       	ldd	r25, Y+3	; 0x03
    1386:	ac 01       	movw	r20, r24
    1388:	4e 5f       	subi	r20, 0xFE	; 254
    138a:	5f 4f       	sbci	r21, 0xFF	; 255
    138c:	8a 81       	ldd	r24, Y+2	; 0x02
    138e:	9b 81       	ldd	r25, Y+3	; 0x03
    1390:	fc 01       	movw	r30, r24
    1392:	86 89       	ldd	r24, Z+22	; 0x16
    1394:	28 2f       	mov	r18, r24
    1396:	30 e0       	ldi	r19, 0x00	; 0
    1398:	c9 01       	movw	r24, r18
    139a:	88 0f       	add	r24, r24
    139c:	99 1f       	adc	r25, r25
    139e:	88 0f       	add	r24, r24
    13a0:	99 1f       	adc	r25, r25
    13a2:	88 0f       	add	r24, r24
    13a4:	99 1f       	adc	r25, r25
    13a6:	82 0f       	add	r24, r18
    13a8:	93 1f       	adc	r25, r19
    13aa:	80 50       	subi	r24, 0x00	; 0
    13ac:	92 4f       	sbci	r25, 0xF2	; 242
    13ae:	ba 01       	movw	r22, r20
    13b0:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	89 83       	std	Y+1, r24	; 0x01
    13b8:	0f 90       	pop	r0
    13ba:	0f be       	out	0x3f, r0	; 63
    13bc:	02 c0       	rjmp	.+4      	; 0x13c2 <xTaskGenericCreate+0x17c>
    13be:	8f ef       	ldi	r24, 0xFF	; 255
    13c0:	89 83       	std	Y+1, r24	; 0x01
    13c2:	89 81       	ldd	r24, Y+1	; 0x01
    13c4:	81 30       	cpi	r24, 0x01	; 1
    13c6:	71 f4       	brne	.+28     	; 0x13e4 <xTaskGenericCreate+0x19e>
    13c8:	80 91 51 0e 	lds	r24, 0x0E51
    13cc:	88 23       	and	r24, r24
    13ce:	51 f0       	breq	.+20     	; 0x13e4 <xTaskGenericCreate+0x19e>
    13d0:	80 91 fe 0d 	lds	r24, 0x0DFE
    13d4:	90 91 ff 0d 	lds	r25, 0x0DFF
    13d8:	fc 01       	movw	r30, r24
    13da:	96 89       	ldd	r25, Z+22	; 0x16
    13dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    13de:	98 17       	cp	r25, r24
    13e0:	08 f4       	brcc	.+2      	; 0x13e4 <xTaskGenericCreate+0x19e>
    13e2:	92 db       	rcall	.-2268   	; 0xb08 <vPortYield>
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	64 96       	adiw	r28, 0x14	; 20
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	cd bf       	out	0x3d, r28	; 61
    13f2:	df 91       	pop	r29
    13f4:	cf 91       	pop	r28
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	ff 90       	pop	r15
    13fc:	ef 90       	pop	r14
    13fe:	df 90       	pop	r13
    1400:	cf 90       	pop	r12
    1402:	bf 90       	pop	r11
    1404:	af 90       	pop	r10
    1406:	08 95       	ret

00001408 <vTaskDelayUntil>:
    1408:	cf 93       	push	r28
    140a:	df 93       	push	r29
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	2a 97       	sbiw	r28, 0x0a	; 10
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	de bf       	out	0x3e, r29	; 62
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	cd bf       	out	0x3d, r28	; 61
    141c:	98 87       	std	Y+8, r25	; 0x08
    141e:	8f 83       	std	Y+7, r24	; 0x07
    1420:	7a 87       	std	Y+10, r23	; 0x0a
    1422:	69 87       	std	Y+9, r22	; 0x09
    1424:	19 82       	std	Y+1, r1	; 0x01
    1426:	ca d0       	rcall	.+404    	; 0x15bc <vTaskSuspendAll>
    1428:	80 91 4e 0e 	lds	r24, 0x0E4E
    142c:	90 91 4f 0e 	lds	r25, 0x0E4F
    1430:	9b 83       	std	Y+3, r25	; 0x03
    1432:	8a 83       	std	Y+2, r24	; 0x02
    1434:	8f 81       	ldd	r24, Y+7	; 0x07
    1436:	98 85       	ldd	r25, Y+8	; 0x08
    1438:	fc 01       	movw	r30, r24
    143a:	20 81       	ld	r18, Z
    143c:	31 81       	ldd	r19, Z+1	; 0x01
    143e:	89 85       	ldd	r24, Y+9	; 0x09
    1440:	9a 85       	ldd	r25, Y+10	; 0x0a
    1442:	82 0f       	add	r24, r18
    1444:	93 1f       	adc	r25, r19
    1446:	9d 83       	std	Y+5, r25	; 0x05
    1448:	8c 83       	std	Y+4, r24	; 0x04
    144a:	8f 81       	ldd	r24, Y+7	; 0x07
    144c:	98 85       	ldd	r25, Y+8	; 0x08
    144e:	fc 01       	movw	r30, r24
    1450:	20 81       	ld	r18, Z
    1452:	31 81       	ldd	r19, Z+1	; 0x01
    1454:	8a 81       	ldd	r24, Y+2	; 0x02
    1456:	9b 81       	ldd	r25, Y+3	; 0x03
    1458:	82 17       	cp	r24, r18
    145a:	93 07       	cpc	r25, r19
    145c:	a0 f4       	brcc	.+40     	; 0x1486 <vTaskDelayUntil+0x7e>
    145e:	8f 81       	ldd	r24, Y+7	; 0x07
    1460:	98 85       	ldd	r25, Y+8	; 0x08
    1462:	fc 01       	movw	r30, r24
    1464:	20 81       	ld	r18, Z
    1466:	31 81       	ldd	r19, Z+1	; 0x01
    1468:	8c 81       	ldd	r24, Y+4	; 0x04
    146a:	9d 81       	ldd	r25, Y+5	; 0x05
    146c:	82 17       	cp	r24, r18
    146e:	93 07       	cpc	r25, r19
    1470:	e8 f4       	brcc	.+58     	; 0x14ac <vTaskDelayUntil+0xa4>
    1472:	2c 81       	ldd	r18, Y+4	; 0x04
    1474:	3d 81       	ldd	r19, Y+5	; 0x05
    1476:	8a 81       	ldd	r24, Y+2	; 0x02
    1478:	9b 81       	ldd	r25, Y+3	; 0x03
    147a:	82 17       	cp	r24, r18
    147c:	93 07       	cpc	r25, r19
    147e:	b0 f4       	brcc	.+44     	; 0x14ac <vTaskDelayUntil+0xa4>
    1480:	81 e0       	ldi	r24, 0x01	; 1
    1482:	89 83       	std	Y+1, r24	; 0x01
    1484:	13 c0       	rjmp	.+38     	; 0x14ac <vTaskDelayUntil+0xa4>
    1486:	8f 81       	ldd	r24, Y+7	; 0x07
    1488:	98 85       	ldd	r25, Y+8	; 0x08
    148a:	fc 01       	movw	r30, r24
    148c:	20 81       	ld	r18, Z
    148e:	31 81       	ldd	r19, Z+1	; 0x01
    1490:	8c 81       	ldd	r24, Y+4	; 0x04
    1492:	9d 81       	ldd	r25, Y+5	; 0x05
    1494:	82 17       	cp	r24, r18
    1496:	93 07       	cpc	r25, r19
    1498:	38 f0       	brcs	.+14     	; 0x14a8 <vTaskDelayUntil+0xa0>
    149a:	2c 81       	ldd	r18, Y+4	; 0x04
    149c:	3d 81       	ldd	r19, Y+5	; 0x05
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	9b 81       	ldd	r25, Y+3	; 0x03
    14a2:	82 17       	cp	r24, r18
    14a4:	93 07       	cpc	r25, r19
    14a6:	10 f4       	brcc	.+4      	; 0x14ac <vTaskDelayUntil+0xa4>
    14a8:	81 e0       	ldi	r24, 0x01	; 1
    14aa:	89 83       	std	Y+1, r24	; 0x01
    14ac:	8f 81       	ldd	r24, Y+7	; 0x07
    14ae:	98 85       	ldd	r25, Y+8	; 0x08
    14b0:	2c 81       	ldd	r18, Y+4	; 0x04
    14b2:	3d 81       	ldd	r19, Y+5	; 0x05
    14b4:	fc 01       	movw	r30, r24
    14b6:	31 83       	std	Z+1, r19	; 0x01
    14b8:	20 83       	st	Z, r18
    14ba:	89 81       	ldd	r24, Y+1	; 0x01
    14bc:	88 23       	and	r24, r24
    14be:	51 f0       	breq	.+20     	; 0x14d4 <vTaskDelayUntil+0xcc>
    14c0:	80 91 fe 0d 	lds	r24, 0x0DFE
    14c4:	90 91 ff 0d 	lds	r25, 0x0DFF
    14c8:	02 96       	adiw	r24, 0x02	; 2
    14ca:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    14ce:	8c 81       	ldd	r24, Y+4	; 0x04
    14d0:	9d 81       	ldd	r25, Y+5	; 0x05
    14d2:	08 d4       	rcall	.+2064   	; 0x1ce4 <prvAddCurrentTaskToDelayedList>
    14d4:	7f d0       	rcall	.+254    	; 0x15d4 <xTaskResumeAll>
    14d6:	8e 83       	std	Y+6, r24	; 0x06
    14d8:	8e 81       	ldd	r24, Y+6	; 0x06
    14da:	88 23       	and	r24, r24
    14dc:	09 f4       	brne	.+2      	; 0x14e0 <vTaskDelayUntil+0xd8>
    14de:	14 db       	rcall	.-2520   	; 0xb08 <vPortYield>
    14e0:	2a 96       	adiw	r28, 0x0a	; 10
    14e2:	0f b6       	in	r0, 0x3f	; 63
    14e4:	f8 94       	cli
    14e6:	de bf       	out	0x3e, r29	; 62
    14e8:	0f be       	out	0x3f, r0	; 63
    14ea:	cd bf       	out	0x3d, r28	; 61
    14ec:	df 91       	pop	r29
    14ee:	cf 91       	pop	r28
    14f0:	08 95       	ret

000014f2 <vTaskDelay>:
    14f2:	cf 93       	push	r28
    14f4:	df 93       	push	r29
    14f6:	00 d0       	rcall	.+0      	; 0x14f8 <vTaskDelay+0x6>
    14f8:	1f 92       	push	r1
    14fa:	1f 92       	push	r1
    14fc:	cd b7       	in	r28, 0x3d	; 61
    14fe:	de b7       	in	r29, 0x3e	; 62
    1500:	9d 83       	std	Y+5, r25	; 0x05
    1502:	8c 83       	std	Y+4, r24	; 0x04
    1504:	19 82       	std	Y+1, r1	; 0x01
    1506:	8c 81       	ldd	r24, Y+4	; 0x04
    1508:	9d 81       	ldd	r25, Y+5	; 0x05
    150a:	89 2b       	or	r24, r25
    150c:	b9 f0       	breq	.+46     	; 0x153c <vTaskDelay+0x4a>
    150e:	56 d0       	rcall	.+172    	; 0x15bc <vTaskSuspendAll>
    1510:	20 91 4e 0e 	lds	r18, 0x0E4E
    1514:	30 91 4f 0e 	lds	r19, 0x0E4F
    1518:	8c 81       	ldd	r24, Y+4	; 0x04
    151a:	9d 81       	ldd	r25, Y+5	; 0x05
    151c:	82 0f       	add	r24, r18
    151e:	93 1f       	adc	r25, r19
    1520:	9b 83       	std	Y+3, r25	; 0x03
    1522:	8a 83       	std	Y+2, r24	; 0x02
    1524:	80 91 fe 0d 	lds	r24, 0x0DFE
    1528:	90 91 ff 0d 	lds	r25, 0x0DFF
    152c:	02 96       	adiw	r24, 0x02	; 2
    152e:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    1532:	8a 81       	ldd	r24, Y+2	; 0x02
    1534:	9b 81       	ldd	r25, Y+3	; 0x03
    1536:	d6 d3       	rcall	.+1964   	; 0x1ce4 <prvAddCurrentTaskToDelayedList>
    1538:	4d d0       	rcall	.+154    	; 0x15d4 <xTaskResumeAll>
    153a:	89 83       	std	Y+1, r24	; 0x01
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	88 23       	and	r24, r24
    1540:	09 f4       	brne	.+2      	; 0x1544 <vTaskDelay+0x52>
    1542:	e2 da       	rcall	.-2620   	; 0xb08 <vPortYield>
    1544:	0f 90       	pop	r0
    1546:	0f 90       	pop	r0
    1548:	0f 90       	pop	r0
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	df 91       	pop	r29
    1550:	cf 91       	pop	r28
    1552:	08 95       	ret

00001554 <vTaskStartScheduler>:
    1554:	af 92       	push	r10
    1556:	bf 92       	push	r11
    1558:	cf 92       	push	r12
    155a:	df 92       	push	r13
    155c:	ef 92       	push	r14
    155e:	ff 92       	push	r15
    1560:	0f 93       	push	r16
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
    1566:	1f 92       	push	r1
    1568:	cd b7       	in	r28, 0x3d	; 61
    156a:	de b7       	in	r29, 0x3e	; 62
    156c:	a1 2c       	mov	r10, r1
    156e:	b1 2c       	mov	r11, r1
    1570:	c1 2c       	mov	r12, r1
    1572:	d1 2c       	mov	r13, r1
    1574:	e1 2c       	mov	r14, r1
    1576:	f1 2c       	mov	r15, r1
    1578:	00 e0       	ldi	r16, 0x00	; 0
    157a:	20 e0       	ldi	r18, 0x00	; 0
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	49 eb       	ldi	r20, 0xB9	; 185
    1580:	50 e0       	ldi	r21, 0x00	; 0
    1582:	62 e0       	ldi	r22, 0x02	; 2
    1584:	72 e0       	ldi	r23, 0x02	; 2
    1586:	82 e7       	ldi	r24, 0x72	; 114
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	5d de       	rcall	.-838    	; 0x1246 <xTaskGenericCreate>
    158c:	89 83       	std	Y+1, r24	; 0x01
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	81 30       	cpi	r24, 0x01	; 1
    1592:	49 f4       	brne	.+18     	; 0x15a6 <vTaskStartScheduler+0x52>
    1594:	f8 94       	cli
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 51 0e 	sts	0x0E51, r24
    159c:	10 92 4f 0e 	sts	0x0E4F, r1
    15a0:	10 92 4e 0e 	sts	0x0E4E, r1
    15a4:	79 da       	rcall	.-2830   	; 0xa98 <xPortStartScheduler>
    15a6:	0f 90       	pop	r0
    15a8:	df 91       	pop	r29
    15aa:	cf 91       	pop	r28
    15ac:	0f 91       	pop	r16
    15ae:	ff 90       	pop	r15
    15b0:	ef 90       	pop	r14
    15b2:	df 90       	pop	r13
    15b4:	cf 90       	pop	r12
    15b6:	bf 90       	pop	r11
    15b8:	af 90       	pop	r10
    15ba:	08 95       	ret

000015bc <vTaskSuspendAll>:
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	cd b7       	in	r28, 0x3d	; 61
    15c2:	de b7       	in	r29, 0x3e	; 62
    15c4:	80 91 56 0e 	lds	r24, 0x0E56
    15c8:	8f 5f       	subi	r24, 0xFF	; 255
    15ca:	80 93 56 0e 	sts	0x0E56, r24
    15ce:	df 91       	pop	r29
    15d0:	cf 91       	pop	r28
    15d2:	08 95       	ret

000015d4 <xTaskResumeAll>:
    15d4:	cf 93       	push	r28
    15d6:	df 93       	push	r29
    15d8:	00 d0       	rcall	.+0      	; 0x15da <xTaskResumeAll+0x6>
    15da:	cd b7       	in	r28, 0x3d	; 61
    15dc:	de b7       	in	r29, 0x3e	; 62
    15de:	19 82       	std	Y+1, r1	; 0x01
    15e0:	0f b6       	in	r0, 0x3f	; 63
    15e2:	f8 94       	cli
    15e4:	0f 92       	push	r0
    15e6:	80 91 56 0e 	lds	r24, 0x0E56
    15ea:	81 50       	subi	r24, 0x01	; 1
    15ec:	80 93 56 0e 	sts	0x0E56, r24
    15f0:	80 91 56 0e 	lds	r24, 0x0E56
    15f4:	88 23       	and	r24, r24
    15f6:	09 f0       	breq	.+2      	; 0x15fa <xTaskResumeAll+0x26>
    15f8:	6f c0       	rjmp	.+222    	; 0x16d8 <xTaskResumeAll+0x104>
    15fa:	80 91 4d 0e 	lds	r24, 0x0E4D
    15fe:	88 23       	and	r24, r24
    1600:	09 f4       	brne	.+2      	; 0x1604 <xTaskResumeAll+0x30>
    1602:	6a c0       	rjmp	.+212    	; 0x16d8 <xTaskResumeAll+0x104>
    1604:	49 c0       	rjmp	.+146    	; 0x1698 <xTaskResumeAll+0xc4>
    1606:	80 91 3f 0e 	lds	r24, 0x0E3F
    160a:	90 91 40 0e 	lds	r25, 0x0E40
    160e:	fc 01       	movw	r30, r24
    1610:	86 81       	ldd	r24, Z+6	; 0x06
    1612:	97 81       	ldd	r25, Z+7	; 0x07
    1614:	9b 83       	std	Y+3, r25	; 0x03
    1616:	8a 83       	std	Y+2, r24	; 0x02
    1618:	8a 81       	ldd	r24, Y+2	; 0x02
    161a:	9b 81       	ldd	r25, Y+3	; 0x03
    161c:	0c 96       	adiw	r24, 0x0c	; 12
    161e:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    1622:	8a 81       	ldd	r24, Y+2	; 0x02
    1624:	9b 81       	ldd	r25, Y+3	; 0x03
    1626:	02 96       	adiw	r24, 0x02	; 2
    1628:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    162c:	8a 81       	ldd	r24, Y+2	; 0x02
    162e:	9b 81       	ldd	r25, Y+3	; 0x03
    1630:	fc 01       	movw	r30, r24
    1632:	96 89       	ldd	r25, Z+22	; 0x16
    1634:	80 91 50 0e 	lds	r24, 0x0E50
    1638:	89 17       	cp	r24, r25
    163a:	30 f4       	brcc	.+12     	; 0x1648 <xTaskResumeAll+0x74>
    163c:	8a 81       	ldd	r24, Y+2	; 0x02
    163e:	9b 81       	ldd	r25, Y+3	; 0x03
    1640:	fc 01       	movw	r30, r24
    1642:	86 89       	ldd	r24, Z+22	; 0x16
    1644:	80 93 50 0e 	sts	0x0E50, r24
    1648:	8a 81       	ldd	r24, Y+2	; 0x02
    164a:	9b 81       	ldd	r25, Y+3	; 0x03
    164c:	ac 01       	movw	r20, r24
    164e:	4e 5f       	subi	r20, 0xFE	; 254
    1650:	5f 4f       	sbci	r21, 0xFF	; 255
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	9b 81       	ldd	r25, Y+3	; 0x03
    1656:	fc 01       	movw	r30, r24
    1658:	86 89       	ldd	r24, Z+22	; 0x16
    165a:	28 2f       	mov	r18, r24
    165c:	30 e0       	ldi	r19, 0x00	; 0
    165e:	c9 01       	movw	r24, r18
    1660:	88 0f       	add	r24, r24
    1662:	99 1f       	adc	r25, r25
    1664:	88 0f       	add	r24, r24
    1666:	99 1f       	adc	r25, r25
    1668:	88 0f       	add	r24, r24
    166a:	99 1f       	adc	r25, r25
    166c:	82 0f       	add	r24, r18
    166e:	93 1f       	adc	r25, r19
    1670:	80 50       	subi	r24, 0x00	; 0
    1672:	92 4f       	sbci	r25, 0xF2	; 242
    1674:	ba 01       	movw	r22, r20
    1676:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    167a:	8a 81       	ldd	r24, Y+2	; 0x02
    167c:	9b 81       	ldd	r25, Y+3	; 0x03
    167e:	fc 01       	movw	r30, r24
    1680:	26 89       	ldd	r18, Z+22	; 0x16
    1682:	80 91 fe 0d 	lds	r24, 0x0DFE
    1686:	90 91 ff 0d 	lds	r25, 0x0DFF
    168a:	fc 01       	movw	r30, r24
    168c:	86 89       	ldd	r24, Z+22	; 0x16
    168e:	28 17       	cp	r18, r24
    1690:	18 f0       	brcs	.+6      	; 0x1698 <xTaskResumeAll+0xc4>
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	80 93 53 0e 	sts	0x0E53, r24
    1698:	80 91 3a 0e 	lds	r24, 0x0E3A
    169c:	88 23       	and	r24, r24
    169e:	09 f0       	breq	.+2      	; 0x16a2 <xTaskResumeAll+0xce>
    16a0:	b2 cf       	rjmp	.-156    	; 0x1606 <xTaskResumeAll+0x32>
    16a2:	80 91 52 0e 	lds	r24, 0x0E52
    16a6:	88 23       	and	r24, r24
    16a8:	81 f0       	breq	.+32     	; 0x16ca <xTaskResumeAll+0xf6>
    16aa:	0b c0       	rjmp	.+22     	; 0x16c2 <xTaskResumeAll+0xee>
    16ac:	36 d0       	rcall	.+108    	; 0x171a <xTaskIncrementTick>
    16ae:	88 23       	and	r24, r24
    16b0:	19 f0       	breq	.+6      	; 0x16b8 <xTaskResumeAll+0xe4>
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	80 93 53 0e 	sts	0x0E53, r24
    16b8:	80 91 52 0e 	lds	r24, 0x0E52
    16bc:	81 50       	subi	r24, 0x01	; 1
    16be:	80 93 52 0e 	sts	0x0E52, r24
    16c2:	80 91 52 0e 	lds	r24, 0x0E52
    16c6:	88 23       	and	r24, r24
    16c8:	89 f7       	brne	.-30     	; 0x16ac <xTaskResumeAll+0xd8>
    16ca:	80 91 53 0e 	lds	r24, 0x0E53
    16ce:	81 30       	cpi	r24, 0x01	; 1
    16d0:	19 f4       	brne	.+6      	; 0x16d8 <xTaskResumeAll+0x104>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	89 83       	std	Y+1, r24	; 0x01
    16d6:	18 da       	rcall	.-3024   	; 0xb08 <vPortYield>
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	0f 90       	pop	r0
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	08 95       	ret

000016ea <xTaskGetTickCount>:
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	1f 92       	push	r1
    16f0:	1f 92       	push	r1
    16f2:	cd b7       	in	r28, 0x3d	; 61
    16f4:	de b7       	in	r29, 0x3e	; 62
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
    16fc:	80 91 4e 0e 	lds	r24, 0x0E4E
    1700:	90 91 4f 0e 	lds	r25, 0x0E4F
    1704:	9a 83       	std	Y+2, r25	; 0x02
    1706:	89 83       	std	Y+1, r24	; 0x01
    1708:	0f 90       	pop	r0
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	89 81       	ldd	r24, Y+1	; 0x01
    170e:	9a 81       	ldd	r25, Y+2	; 0x02
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	df 91       	pop	r29
    1716:	cf 91       	pop	r28
    1718:	08 95       	ret

0000171a <xTaskIncrementTick>:
    171a:	cf 93       	push	r28
    171c:	df 93       	push	r29
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
    1722:	29 97       	sbiw	r28, 0x09	; 9
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	de bf       	out	0x3e, r29	; 62
    172a:	0f be       	out	0x3f, r0	; 63
    172c:	cd bf       	out	0x3d, r28	; 61
    172e:	19 82       	std	Y+1, r1	; 0x01
    1730:	80 91 56 0e 	lds	r24, 0x0E56
    1734:	88 23       	and	r24, r24
    1736:	09 f0       	breq	.+2      	; 0x173a <xTaskIncrementTick+0x20>
    1738:	c8 c0       	rjmp	.+400    	; 0x18ca <xTaskIncrementTick+0x1b0>
    173a:	80 91 4e 0e 	lds	r24, 0x0E4E
    173e:	90 91 4f 0e 	lds	r25, 0x0E4F
    1742:	01 96       	adiw	r24, 0x01	; 1
    1744:	90 93 4f 0e 	sts	0x0E4F, r25
    1748:	80 93 4e 0e 	sts	0x0E4E, r24
    174c:	80 91 4e 0e 	lds	r24, 0x0E4E
    1750:	90 91 4f 0e 	lds	r25, 0x0E4F
    1754:	9b 83       	std	Y+3, r25	; 0x03
    1756:	8a 83       	std	Y+2, r24	; 0x02
    1758:	8a 81       	ldd	r24, Y+2	; 0x02
    175a:	9b 81       	ldd	r25, Y+3	; 0x03
    175c:	89 2b       	or	r24, r25
    175e:	d1 f4       	brne	.+52     	; 0x1794 <xTaskIncrementTick+0x7a>
    1760:	80 91 36 0e 	lds	r24, 0x0E36
    1764:	90 91 37 0e 	lds	r25, 0x0E37
    1768:	9d 83       	std	Y+5, r25	; 0x05
    176a:	8c 83       	std	Y+4, r24	; 0x04
    176c:	80 91 38 0e 	lds	r24, 0x0E38
    1770:	90 91 39 0e 	lds	r25, 0x0E39
    1774:	90 93 37 0e 	sts	0x0E37, r25
    1778:	80 93 36 0e 	sts	0x0E36, r24
    177c:	8c 81       	ldd	r24, Y+4	; 0x04
    177e:	9d 81       	ldd	r25, Y+5	; 0x05
    1780:	90 93 39 0e 	sts	0x0E39, r25
    1784:	80 93 38 0e 	sts	0x0E38, r24
    1788:	80 91 54 0e 	lds	r24, 0x0E54
    178c:	8f 5f       	subi	r24, 0xFF	; 255
    178e:	80 93 54 0e 	sts	0x0E54, r24
    1792:	49 d3       	rcall	.+1682   	; 0x1e26 <prvResetNextTaskUnblockTime>
    1794:	80 91 00 02 	lds	r24, 0x0200
    1798:	90 91 01 02 	lds	r25, 0x0201
    179c:	2a 81       	ldd	r18, Y+2	; 0x02
    179e:	3b 81       	ldd	r19, Y+3	; 0x03
    17a0:	28 17       	cp	r18, r24
    17a2:	39 07       	cpc	r19, r25
    17a4:	08 f4       	brcc	.+2      	; 0x17a8 <xTaskIncrementTick+0x8e>
    17a6:	77 c0       	rjmp	.+238    	; 0x1896 <xTaskIncrementTick+0x17c>
    17a8:	80 91 36 0e 	lds	r24, 0x0E36
    17ac:	90 91 37 0e 	lds	r25, 0x0E37
    17b0:	fc 01       	movw	r30, r24
    17b2:	80 81       	ld	r24, Z
    17b4:	88 23       	and	r24, r24
    17b6:	39 f4       	brne	.+14     	; 0x17c6 <xTaskIncrementTick+0xac>
    17b8:	8f ef       	ldi	r24, 0xFF	; 255
    17ba:	9f ef       	ldi	r25, 0xFF	; 255
    17bc:	90 93 01 02 	sts	0x0201, r25
    17c0:	80 93 00 02 	sts	0x0200, r24
    17c4:	68 c0       	rjmp	.+208    	; 0x1896 <xTaskIncrementTick+0x17c>
    17c6:	80 91 36 0e 	lds	r24, 0x0E36
    17ca:	90 91 37 0e 	lds	r25, 0x0E37
    17ce:	fc 01       	movw	r30, r24
    17d0:	85 81       	ldd	r24, Z+5	; 0x05
    17d2:	96 81       	ldd	r25, Z+6	; 0x06
    17d4:	fc 01       	movw	r30, r24
    17d6:	86 81       	ldd	r24, Z+6	; 0x06
    17d8:	97 81       	ldd	r25, Z+7	; 0x07
    17da:	9f 83       	std	Y+7, r25	; 0x07
    17dc:	8e 83       	std	Y+6, r24	; 0x06
    17de:	8e 81       	ldd	r24, Y+6	; 0x06
    17e0:	9f 81       	ldd	r25, Y+7	; 0x07
    17e2:	fc 01       	movw	r30, r24
    17e4:	82 81       	ldd	r24, Z+2	; 0x02
    17e6:	93 81       	ldd	r25, Z+3	; 0x03
    17e8:	99 87       	std	Y+9, r25	; 0x09
    17ea:	88 87       	std	Y+8, r24	; 0x08
    17ec:	2a 81       	ldd	r18, Y+2	; 0x02
    17ee:	3b 81       	ldd	r19, Y+3	; 0x03
    17f0:	88 85       	ldd	r24, Y+8	; 0x08
    17f2:	99 85       	ldd	r25, Y+9	; 0x09
    17f4:	28 17       	cp	r18, r24
    17f6:	39 07       	cpc	r19, r25
    17f8:	38 f4       	brcc	.+14     	; 0x1808 <xTaskIncrementTick+0xee>
    17fa:	88 85       	ldd	r24, Y+8	; 0x08
    17fc:	99 85       	ldd	r25, Y+9	; 0x09
    17fe:	90 93 01 02 	sts	0x0201, r25
    1802:	80 93 00 02 	sts	0x0200, r24
    1806:	47 c0       	rjmp	.+142    	; 0x1896 <xTaskIncrementTick+0x17c>
    1808:	8e 81       	ldd	r24, Y+6	; 0x06
    180a:	9f 81       	ldd	r25, Y+7	; 0x07
    180c:	02 96       	adiw	r24, 0x02	; 2
    180e:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    1812:	8e 81       	ldd	r24, Y+6	; 0x06
    1814:	9f 81       	ldd	r25, Y+7	; 0x07
    1816:	fc 01       	movw	r30, r24
    1818:	84 89       	ldd	r24, Z+20	; 0x14
    181a:	95 89       	ldd	r25, Z+21	; 0x15
    181c:	89 2b       	or	r24, r25
    181e:	29 f0       	breq	.+10     	; 0x182a <xTaskIncrementTick+0x110>
    1820:	8e 81       	ldd	r24, Y+6	; 0x06
    1822:	9f 81       	ldd	r25, Y+7	; 0x07
    1824:	0c 96       	adiw	r24, 0x0c	; 12
    1826:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
    182a:	8e 81       	ldd	r24, Y+6	; 0x06
    182c:	9f 81       	ldd	r25, Y+7	; 0x07
    182e:	fc 01       	movw	r30, r24
    1830:	96 89       	ldd	r25, Z+22	; 0x16
    1832:	80 91 50 0e 	lds	r24, 0x0E50
    1836:	89 17       	cp	r24, r25
    1838:	30 f4       	brcc	.+12     	; 0x1846 <xTaskIncrementTick+0x12c>
    183a:	8e 81       	ldd	r24, Y+6	; 0x06
    183c:	9f 81       	ldd	r25, Y+7	; 0x07
    183e:	fc 01       	movw	r30, r24
    1840:	86 89       	ldd	r24, Z+22	; 0x16
    1842:	80 93 50 0e 	sts	0x0E50, r24
    1846:	8e 81       	ldd	r24, Y+6	; 0x06
    1848:	9f 81       	ldd	r25, Y+7	; 0x07
    184a:	ac 01       	movw	r20, r24
    184c:	4e 5f       	subi	r20, 0xFE	; 254
    184e:	5f 4f       	sbci	r21, 0xFF	; 255
    1850:	8e 81       	ldd	r24, Y+6	; 0x06
    1852:	9f 81       	ldd	r25, Y+7	; 0x07
    1854:	fc 01       	movw	r30, r24
    1856:	86 89       	ldd	r24, Z+22	; 0x16
    1858:	28 2f       	mov	r18, r24
    185a:	30 e0       	ldi	r19, 0x00	; 0
    185c:	c9 01       	movw	r24, r18
    185e:	88 0f       	add	r24, r24
    1860:	99 1f       	adc	r25, r25
    1862:	88 0f       	add	r24, r24
    1864:	99 1f       	adc	r25, r25
    1866:	88 0f       	add	r24, r24
    1868:	99 1f       	adc	r25, r25
    186a:	82 0f       	add	r24, r18
    186c:	93 1f       	adc	r25, r19
    186e:	80 50       	subi	r24, 0x00	; 0
    1870:	92 4f       	sbci	r25, 0xF2	; 242
    1872:	ba 01       	movw	r22, r20
    1874:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    1878:	8e 81       	ldd	r24, Y+6	; 0x06
    187a:	9f 81       	ldd	r25, Y+7	; 0x07
    187c:	fc 01       	movw	r30, r24
    187e:	26 89       	ldd	r18, Z+22	; 0x16
    1880:	80 91 fe 0d 	lds	r24, 0x0DFE
    1884:	90 91 ff 0d 	lds	r25, 0x0DFF
    1888:	fc 01       	movw	r30, r24
    188a:	86 89       	ldd	r24, Z+22	; 0x16
    188c:	28 17       	cp	r18, r24
    188e:	10 f0       	brcs	.+4      	; 0x1894 <xTaskIncrementTick+0x17a>
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	89 83       	std	Y+1, r24	; 0x01
    1894:	89 cf       	rjmp	.-238    	; 0x17a8 <xTaskIncrementTick+0x8e>
    1896:	80 91 fe 0d 	lds	r24, 0x0DFE
    189a:	90 91 ff 0d 	lds	r25, 0x0DFF
    189e:	fc 01       	movw	r30, r24
    18a0:	86 89       	ldd	r24, Z+22	; 0x16
    18a2:	28 2f       	mov	r18, r24
    18a4:	30 e0       	ldi	r19, 0x00	; 0
    18a6:	c9 01       	movw	r24, r18
    18a8:	88 0f       	add	r24, r24
    18aa:	99 1f       	adc	r25, r25
    18ac:	88 0f       	add	r24, r24
    18ae:	99 1f       	adc	r25, r25
    18b0:	88 0f       	add	r24, r24
    18b2:	99 1f       	adc	r25, r25
    18b4:	82 0f       	add	r24, r18
    18b6:	93 1f       	adc	r25, r19
    18b8:	80 50       	subi	r24, 0x00	; 0
    18ba:	92 4f       	sbci	r25, 0xF2	; 242
    18bc:	fc 01       	movw	r30, r24
    18be:	80 81       	ld	r24, Z
    18c0:	82 30       	cpi	r24, 0x02	; 2
    18c2:	40 f0       	brcs	.+16     	; 0x18d4 <xTaskIncrementTick+0x1ba>
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	89 83       	std	Y+1, r24	; 0x01
    18c8:	05 c0       	rjmp	.+10     	; 0x18d4 <xTaskIncrementTick+0x1ba>
    18ca:	80 91 52 0e 	lds	r24, 0x0E52
    18ce:	8f 5f       	subi	r24, 0xFF	; 255
    18d0:	80 93 52 0e 	sts	0x0E52, r24
    18d4:	80 91 53 0e 	lds	r24, 0x0E53
    18d8:	88 23       	and	r24, r24
    18da:	11 f0       	breq	.+4      	; 0x18e0 <xTaskIncrementTick+0x1c6>
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	89 83       	std	Y+1, r24	; 0x01
    18e0:	89 81       	ldd	r24, Y+1	; 0x01
    18e2:	29 96       	adiw	r28, 0x09	; 9
    18e4:	0f b6       	in	r0, 0x3f	; 63
    18e6:	f8 94       	cli
    18e8:	de bf       	out	0x3e, r29	; 62
    18ea:	0f be       	out	0x3f, r0	; 63
    18ec:	cd bf       	out	0x3d, r28	; 61
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	08 95       	ret

000018f4 <vTaskSwitchContext>:
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	1f 92       	push	r1
    18fa:	1f 92       	push	r1
    18fc:	cd b7       	in	r28, 0x3d	; 61
    18fe:	de b7       	in	r29, 0x3e	; 62
    1900:	80 91 56 0e 	lds	r24, 0x0E56
    1904:	88 23       	and	r24, r24
    1906:	21 f0       	breq	.+8      	; 0x1910 <vTaskSwitchContext+0x1c>
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	80 93 53 0e 	sts	0x0E53, r24
    190e:	7b c0       	rjmp	.+246    	; 0x1a06 <vTaskSwitchContext+0x112>
    1910:	10 92 53 0e 	sts	0x0E53, r1
    1914:	80 91 fe 0d 	lds	r24, 0x0DFE
    1918:	90 91 ff 0d 	lds	r25, 0x0DFF
    191c:	fc 01       	movw	r30, r24
    191e:	20 81       	ld	r18, Z
    1920:	31 81       	ldd	r19, Z+1	; 0x01
    1922:	80 91 fe 0d 	lds	r24, 0x0DFE
    1926:	90 91 ff 0d 	lds	r25, 0x0DFF
    192a:	fc 01       	movw	r30, r24
    192c:	87 89       	ldd	r24, Z+23	; 0x17
    192e:	90 8d       	ldd	r25, Z+24	; 0x18
    1930:	82 17       	cp	r24, r18
    1932:	93 07       	cpc	r25, r19
    1934:	68 f0       	brcs	.+26     	; 0x1950 <vTaskSwitchContext+0x5c>
    1936:	80 91 fe 0d 	lds	r24, 0x0DFE
    193a:	90 91 ff 0d 	lds	r25, 0x0DFF
    193e:	9c 01       	movw	r18, r24
    1940:	27 5e       	subi	r18, 0xE7	; 231
    1942:	3f 4f       	sbci	r19, 0xFF	; 255
    1944:	80 91 fe 0d 	lds	r24, 0x0DFE
    1948:	90 91 ff 0d 	lds	r25, 0x0DFF
    194c:	b9 01       	movw	r22, r18
    194e:	7d d3       	rcall	.+1786   	; 0x204a <vApplicationStackOverflowHook>
    1950:	05 c0       	rjmp	.+10     	; 0x195c <vTaskSwitchContext+0x68>
    1952:	80 91 50 0e 	lds	r24, 0x0E50
    1956:	81 50       	subi	r24, 0x01	; 1
    1958:	80 93 50 0e 	sts	0x0E50, r24
    195c:	80 91 50 0e 	lds	r24, 0x0E50
    1960:	28 2f       	mov	r18, r24
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	c9 01       	movw	r24, r18
    1966:	88 0f       	add	r24, r24
    1968:	99 1f       	adc	r25, r25
    196a:	88 0f       	add	r24, r24
    196c:	99 1f       	adc	r25, r25
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	82 0f       	add	r24, r18
    1974:	93 1f       	adc	r25, r19
    1976:	80 50       	subi	r24, 0x00	; 0
    1978:	92 4f       	sbci	r25, 0xF2	; 242
    197a:	fc 01       	movw	r30, r24
    197c:	80 81       	ld	r24, Z
    197e:	88 23       	and	r24, r24
    1980:	41 f3       	breq	.-48     	; 0x1952 <vTaskSwitchContext+0x5e>
    1982:	80 91 50 0e 	lds	r24, 0x0E50
    1986:	28 2f       	mov	r18, r24
    1988:	30 e0       	ldi	r19, 0x00	; 0
    198a:	c9 01       	movw	r24, r18
    198c:	88 0f       	add	r24, r24
    198e:	99 1f       	adc	r25, r25
    1990:	88 0f       	add	r24, r24
    1992:	99 1f       	adc	r25, r25
    1994:	88 0f       	add	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	82 0f       	add	r24, r18
    199a:	93 1f       	adc	r25, r19
    199c:	80 50       	subi	r24, 0x00	; 0
    199e:	92 4f       	sbci	r25, 0xF2	; 242
    19a0:	9a 83       	std	Y+2, r25	; 0x02
    19a2:	89 83       	std	Y+1, r24	; 0x01
    19a4:	89 81       	ldd	r24, Y+1	; 0x01
    19a6:	9a 81       	ldd	r25, Y+2	; 0x02
    19a8:	fc 01       	movw	r30, r24
    19aa:	81 81       	ldd	r24, Z+1	; 0x01
    19ac:	92 81       	ldd	r25, Z+2	; 0x02
    19ae:	fc 01       	movw	r30, r24
    19b0:	22 81       	ldd	r18, Z+2	; 0x02
    19b2:	33 81       	ldd	r19, Z+3	; 0x03
    19b4:	89 81       	ldd	r24, Y+1	; 0x01
    19b6:	9a 81       	ldd	r25, Y+2	; 0x02
    19b8:	fc 01       	movw	r30, r24
    19ba:	32 83       	std	Z+2, r19	; 0x02
    19bc:	21 83       	std	Z+1, r18	; 0x01
    19be:	89 81       	ldd	r24, Y+1	; 0x01
    19c0:	9a 81       	ldd	r25, Y+2	; 0x02
    19c2:	fc 01       	movw	r30, r24
    19c4:	21 81       	ldd	r18, Z+1	; 0x01
    19c6:	32 81       	ldd	r19, Z+2	; 0x02
    19c8:	89 81       	ldd	r24, Y+1	; 0x01
    19ca:	9a 81       	ldd	r25, Y+2	; 0x02
    19cc:	03 96       	adiw	r24, 0x03	; 3
    19ce:	28 17       	cp	r18, r24
    19d0:	39 07       	cpc	r19, r25
    19d2:	69 f4       	brne	.+26     	; 0x19ee <vTaskSwitchContext+0xfa>
    19d4:	89 81       	ldd	r24, Y+1	; 0x01
    19d6:	9a 81       	ldd	r25, Y+2	; 0x02
    19d8:	fc 01       	movw	r30, r24
    19da:	81 81       	ldd	r24, Z+1	; 0x01
    19dc:	92 81       	ldd	r25, Z+2	; 0x02
    19de:	fc 01       	movw	r30, r24
    19e0:	22 81       	ldd	r18, Z+2	; 0x02
    19e2:	33 81       	ldd	r19, Z+3	; 0x03
    19e4:	89 81       	ldd	r24, Y+1	; 0x01
    19e6:	9a 81       	ldd	r25, Y+2	; 0x02
    19e8:	fc 01       	movw	r30, r24
    19ea:	32 83       	std	Z+2, r19	; 0x02
    19ec:	21 83       	std	Z+1, r18	; 0x01
    19ee:	89 81       	ldd	r24, Y+1	; 0x01
    19f0:	9a 81       	ldd	r25, Y+2	; 0x02
    19f2:	fc 01       	movw	r30, r24
    19f4:	81 81       	ldd	r24, Z+1	; 0x01
    19f6:	92 81       	ldd	r25, Z+2	; 0x02
    19f8:	fc 01       	movw	r30, r24
    19fa:	86 81       	ldd	r24, Z+6	; 0x06
    19fc:	97 81       	ldd	r25, Z+7	; 0x07
    19fe:	90 93 ff 0d 	sts	0x0DFF, r25
    1a02:	80 93 fe 0d 	sts	0x0DFE, r24
    1a06:	0f 90       	pop	r0
    1a08:	0f 90       	pop	r0
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	08 95       	ret

00001a10 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	00 d0       	rcall	.+0      	; 0x1a16 <xTaskRemoveFromEventList+0x6>
    1a16:	1f 92       	push	r1
    1a18:	1f 92       	push	r1
    1a1a:	cd b7       	in	r28, 0x3d	; 61
    1a1c:	de b7       	in	r29, 0x3e	; 62
    1a1e:	9d 83       	std	Y+5, r25	; 0x05
    1a20:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a22:	8c 81       	ldd	r24, Y+4	; 0x04
    1a24:	9d 81       	ldd	r25, Y+5	; 0x05
    1a26:	fc 01       	movw	r30, r24
    1a28:	85 81       	ldd	r24, Z+5	; 0x05
    1a2a:	96 81       	ldd	r25, Z+6	; 0x06
    1a2c:	fc 01       	movw	r30, r24
    1a2e:	86 81       	ldd	r24, Z+6	; 0x06
    1a30:	97 81       	ldd	r25, Z+7	; 0x07
    1a32:	9b 83       	std	Y+3, r25	; 0x03
    1a34:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1a36:	8a 81       	ldd	r24, Y+2	; 0x02
    1a38:	9b 81       	ldd	r25, Y+3	; 0x03
    1a3a:	0c 96       	adiw	r24, 0x0c	; 12
    1a3c:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a40:	80 91 56 0e 	lds	r24, 0x0E56
    1a44:	88 23       	and	r24, r24
    1a46:	69 f5       	brne	.+90     	; 0x1aa2 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1a48:	8a 81       	ldd	r24, Y+2	; 0x02
    1a4a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a4c:	02 96       	adiw	r24, 0x02	; 2
    1a4e:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1a52:	8a 81       	ldd	r24, Y+2	; 0x02
    1a54:	9b 81       	ldd	r25, Y+3	; 0x03
    1a56:	fc 01       	movw	r30, r24
    1a58:	96 89       	ldd	r25, Z+22	; 0x16
    1a5a:	80 91 50 0e 	lds	r24, 0x0E50
    1a5e:	89 17       	cp	r24, r25
    1a60:	30 f4       	brcc	.+12     	; 0x1a6e <xTaskRemoveFromEventList+0x5e>
    1a62:	8a 81       	ldd	r24, Y+2	; 0x02
    1a64:	9b 81       	ldd	r25, Y+3	; 0x03
    1a66:	fc 01       	movw	r30, r24
    1a68:	86 89       	ldd	r24, Z+22	; 0x16
    1a6a:	80 93 50 0e 	sts	0x0E50, r24
    1a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a70:	9b 81       	ldd	r25, Y+3	; 0x03
    1a72:	ac 01       	movw	r20, r24
    1a74:	4e 5f       	subi	r20, 0xFE	; 254
    1a76:	5f 4f       	sbci	r21, 0xFF	; 255
    1a78:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	86 89       	ldd	r24, Z+22	; 0x16
    1a80:	28 2f       	mov	r18, r24
    1a82:	30 e0       	ldi	r19, 0x00	; 0
    1a84:	c9 01       	movw	r24, r18
    1a86:	88 0f       	add	r24, r24
    1a88:	99 1f       	adc	r25, r25
    1a8a:	88 0f       	add	r24, r24
    1a8c:	99 1f       	adc	r25, r25
    1a8e:	88 0f       	add	r24, r24
    1a90:	99 1f       	adc	r25, r25
    1a92:	82 0f       	add	r24, r18
    1a94:	93 1f       	adc	r25, r19
    1a96:	80 50       	subi	r24, 0x00	; 0
    1a98:	92 4f       	sbci	r25, 0xF2	; 242
    1a9a:	ba 01       	movw	r22, r20
    1a9c:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
    1aa0:	08 c0       	rjmp	.+16     	; 0x1ab2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa4:	9b 81       	ldd	r25, Y+3	; 0x03
    1aa6:	0c 96       	adiw	r24, 0x0c	; 12
    1aa8:	bc 01       	movw	r22, r24
    1aaa:	8a e3       	ldi	r24, 0x3A	; 58
    1aac:	9e e0       	ldi	r25, 0x0E	; 14
    1aae:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab6:	fc 01       	movw	r30, r24
    1ab8:	26 89       	ldd	r18, Z+22	; 0x16
    1aba:	80 91 fe 0d 	lds	r24, 0x0DFE
    1abe:	90 91 ff 0d 	lds	r25, 0x0DFF
    1ac2:	fc 01       	movw	r30, r24
    1ac4:	86 89       	ldd	r24, Z+22	; 0x16
    1ac6:	82 17       	cp	r24, r18
    1ac8:	30 f4       	brcc	.+12     	; 0x1ad6 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1ace:	81 e0       	ldi	r24, 0x01	; 1
    1ad0:	80 93 53 0e 	sts	0x0E53, r24
    1ad4:	01 c0       	rjmp	.+2      	; 0x1ad8 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    1ad6:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ada:	0f 90       	pop	r0
    1adc:	0f 90       	pop	r0
    1ade:	0f 90       	pop	r0
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
    1ae4:	df 91       	pop	r29
    1ae6:	cf 91       	pop	r28
    1ae8:	08 95       	ret

00001aea <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1aea:	0f 93       	push	r16
    1aec:	1f 93       	push	r17
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	cd b7       	in	r28, 0x3d	; 61
    1af4:	de b7       	in	r29, 0x3e	; 62
    1af6:	2a 97       	sbiw	r28, 0x0a	; 10
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    1b02:	9b 83       	std	Y+3, r25	; 0x03
    1b04:	8a 83       	std	Y+2, r24	; 0x02
    1b06:	7d 83       	std	Y+5, r23	; 0x05
    1b08:	6c 83       	std	Y+4, r22	; 0x04
    1b0a:	4e 83       	std	Y+6, r20	; 0x06
    1b0c:	38 87       	std	Y+8, r19	; 0x08
    1b0e:	2f 83       	std	Y+7, r18	; 0x07
    1b10:	1a 87       	std	Y+10, r17	; 0x0a
    1b12:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1b14:	19 82       	std	Y+1, r1	; 0x01
    1b16:	22 c0       	rjmp	.+68     	; 0x1b5c <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1b18:	89 81       	ldd	r24, Y+1	; 0x01
    1b1a:	88 2f       	mov	r24, r24
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	29 81       	ldd	r18, Y+1	; 0x01
    1b20:	22 2f       	mov	r18, r18
    1b22:	30 e0       	ldi	r19, 0x00	; 0
    1b24:	4c 81       	ldd	r20, Y+4	; 0x04
    1b26:	5d 81       	ldd	r21, Y+5	; 0x05
    1b28:	24 0f       	add	r18, r20
    1b2a:	35 1f       	adc	r19, r21
    1b2c:	f9 01       	movw	r30, r18
    1b2e:	40 81       	ld	r20, Z
    1b30:	2a 81       	ldd	r18, Y+2	; 0x02
    1b32:	3b 81       	ldd	r19, Y+3	; 0x03
    1b34:	82 0f       	add	r24, r18
    1b36:	93 1f       	adc	r25, r19
    1b38:	49 96       	adiw	r24, 0x19	; 25
    1b3a:	fc 01       	movw	r30, r24
    1b3c:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
    1b40:	88 2f       	mov	r24, r24
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	2c 81       	ldd	r18, Y+4	; 0x04
    1b46:	3d 81       	ldd	r19, Y+5	; 0x05
    1b48:	82 0f       	add	r24, r18
    1b4a:	93 1f       	adc	r25, r19
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	80 81       	ld	r24, Z
    1b50:	88 23       	and	r24, r24
    1b52:	09 f4       	brne	.+2      	; 0x1b56 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    1b54:	06 c0       	rjmp	.+12     	; 0x1b62 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1b56:	89 81       	ldd	r24, Y+1	; 0x01
    1b58:	8f 5f       	subi	r24, 0xFF	; 255
    1b5a:	89 83       	std	Y+1, r24	; 0x01
    1b5c:	89 81       	ldd	r24, Y+1	; 0x01
    1b5e:	88 30       	cpi	r24, 0x08	; 8
    1b60:	d8 f2       	brcs	.-74     	; 0x1b18 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1b62:	8a 81       	ldd	r24, Y+2	; 0x02
    1b64:	9b 81       	ldd	r25, Y+3	; 0x03
    1b66:	fc 01       	movw	r30, r24
    1b68:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1b6a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b6c:	84 30       	cpi	r24, 0x04	; 4
    1b6e:	10 f0       	brcs	.+4      	; 0x1b74 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1b70:	83 e0       	ldi	r24, 0x03	; 3
    1b72:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1b74:	8a 81       	ldd	r24, Y+2	; 0x02
    1b76:	9b 81       	ldd	r25, Y+3	; 0x03
    1b78:	2e 81       	ldd	r18, Y+6	; 0x06
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1b7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b80:	9b 81       	ldd	r25, Y+3	; 0x03
    1b82:	02 96       	adiw	r24, 0x02	; 2
    1b84:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1b88:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b8c:	0c 96       	adiw	r24, 0x0c	; 12
    1b8e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1b92:	8a 81       	ldd	r24, Y+2	; 0x02
    1b94:	9b 81       	ldd	r25, Y+3	; 0x03
    1b96:	2a 81       	ldd	r18, Y+2	; 0x02
    1b98:	3b 81       	ldd	r19, Y+3	; 0x03
    1b9a:	fc 01       	movw	r30, r24
    1b9c:	31 87       	std	Z+9, r19	; 0x09
    1b9e:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ba0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ba2:	88 2f       	mov	r24, r24
    1ba4:	90 e0       	ldi	r25, 0x00	; 0
    1ba6:	24 e0       	ldi	r18, 0x04	; 4
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	28 1b       	sub	r18, r24
    1bac:	39 0b       	sbc	r19, r25
    1bae:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb0:	9b 81       	ldd	r25, Y+3	; 0x03
    1bb2:	fc 01       	movw	r30, r24
    1bb4:	35 87       	std	Z+13, r19	; 0x0d
    1bb6:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1bb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1bba:	9b 81       	ldd	r25, Y+3	; 0x03
    1bbc:	2a 81       	ldd	r18, Y+2	; 0x02
    1bbe:	3b 81       	ldd	r19, Y+3	; 0x03
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	33 8b       	std	Z+19, r19	; 0x13
    1bc4:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bca:	fc 01       	movw	r30, r24
    1bcc:	11 a2       	std	Z+33, r1	; 0x21
    1bce:	12 a2       	std	Z+34, r1	; 0x22
    1bd0:	13 a2       	std	Z+35, r1	; 0x23
    1bd2:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd8:	fc 01       	movw	r30, r24
    1bda:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    1bdc:	2a 96       	adiw	r28, 0x0a	; 10
    1bde:	0f b6       	in	r0, 0x3f	; 63
    1be0:	f8 94       	cli
    1be2:	de bf       	out	0x3e, r29	; 62
    1be4:	0f be       	out	0x3f, r0	; 63
    1be6:	cd bf       	out	0x3d, r28	; 61
    1be8:	df 91       	pop	r29
    1bea:	cf 91       	pop	r28
    1bec:	1f 91       	pop	r17
    1bee:	0f 91       	pop	r16
    1bf0:	08 95       	ret

00001bf2 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    1bf2:	cf 93       	push	r28
    1bf4:	df 93       	push	r29
    1bf6:	1f 92       	push	r1
    1bf8:	cd b7       	in	r28, 0x3d	; 61
    1bfa:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1bfc:	19 82       	std	Y+1, r1	; 0x01
    1bfe:	13 c0       	rjmp	.+38     	; 0x1c26 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	28 2f       	mov	r18, r24
    1c04:	30 e0       	ldi	r19, 0x00	; 0
    1c06:	c9 01       	movw	r24, r18
    1c08:	88 0f       	add	r24, r24
    1c0a:	99 1f       	adc	r25, r25
    1c0c:	88 0f       	add	r24, r24
    1c0e:	99 1f       	adc	r25, r25
    1c10:	88 0f       	add	r24, r24
    1c12:	99 1f       	adc	r25, r25
    1c14:	82 0f       	add	r24, r18
    1c16:	93 1f       	adc	r25, r19
    1c18:	80 50       	subi	r24, 0x00	; 0
    1c1a:	92 4f       	sbci	r25, 0xF2	; 242
    1c1c:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1c20:	89 81       	ldd	r24, Y+1	; 0x01
    1c22:	8f 5f       	subi	r24, 0xFF	; 255
    1c24:	89 83       	std	Y+1, r24	; 0x01
    1c26:	89 81       	ldd	r24, Y+1	; 0x01
    1c28:	84 30       	cpi	r24, 0x04	; 4
    1c2a:	50 f3       	brcs	.-44     	; 0x1c00 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1c2c:	84 e2       	ldi	r24, 0x24	; 36
    1c2e:	9e e0       	ldi	r25, 0x0E	; 14
    1c30:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1c34:	8d e2       	ldi	r24, 0x2D	; 45
    1c36:	9e e0       	ldi	r25, 0x0E	; 14
    1c38:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1c3c:	8a e3       	ldi	r24, 0x3A	; 58
    1c3e:	9e e0       	ldi	r25, 0x0E	; 14
    1c40:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1c44:	83 e4       	ldi	r24, 0x43	; 67
    1c46:	9e e0       	ldi	r25, 0x0E	; 14
    1c48:	0e 94 a7 00 	call	0x14e	; 0x14e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1c4c:	84 e2       	ldi	r24, 0x24	; 36
    1c4e:	9e e0       	ldi	r25, 0x0E	; 14
    1c50:	90 93 37 0e 	sts	0x0E37, r25
    1c54:	80 93 36 0e 	sts	0x0E36, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1c58:	8d e2       	ldi	r24, 0x2D	; 45
    1c5a:	9e e0       	ldi	r25, 0x0E	; 14
    1c5c:	90 93 39 0e 	sts	0x0E39, r25
    1c60:	80 93 38 0e 	sts	0x0E38, r24
}
    1c64:	0f 90       	pop	r0
    1c66:	df 91       	pop	r29
    1c68:	cf 91       	pop	r28
    1c6a:	08 95       	ret

00001c6c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1c6c:	cf 93       	push	r28
    1c6e:	df 93       	push	r29
    1c70:	00 d0       	rcall	.+0      	; 0x1c72 <prvCheckTasksWaitingTermination+0x6>
    1c72:	cd b7       	in	r28, 0x3d	; 61
    1c74:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1c76:	2c c0       	rjmp	.+88     	; 0x1cd0 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
    1c78:	a1 dc       	rcall	.-1726   	; 0x15bc <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1c7a:	90 91 43 0e 	lds	r25, 0x0E43
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	99 23       	and	r25, r25
    1c82:	09 f0       	breq	.+2      	; 0x1c86 <prvCheckTasksWaitingTermination+0x1a>
    1c84:	80 e0       	ldi	r24, 0x00	; 0
    1c86:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    1c88:	a5 dc       	rcall	.-1718   	; 0x15d4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1c8a:	89 81       	ldd	r24, Y+1	; 0x01
    1c8c:	88 23       	and	r24, r24
    1c8e:	01 f5       	brne	.+64     	; 0x1cd0 <prvCheckTasksWaitingTermination+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1c96:	80 91 48 0e 	lds	r24, 0x0E48
    1c9a:	90 91 49 0e 	lds	r25, 0x0E49
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	86 81       	ldd	r24, Z+6	; 0x06
    1ca2:	97 81       	ldd	r25, Z+7	; 0x07
    1ca4:	9b 83       	std	Y+3, r25	; 0x03
    1ca6:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    1caa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cac:	02 96       	adiw	r24, 0x02	; 2
    1cae:	0e 94 b3 01 	call	0x366	; 0x366 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1cb2:	80 91 4d 0e 	lds	r24, 0x0E4D
    1cb6:	81 50       	subi	r24, 0x01	; 1
    1cb8:	80 93 4d 0e 	sts	0x0E4D, r24
					--uxTasksDeleted;
    1cbc:	80 91 4c 0e 	lds	r24, 0x0E4C
    1cc0:	81 50       	subi	r24, 0x01	; 1
    1cc2:	80 93 4c 0e 	sts	0x0E4C, r24
				}
				taskEXIT_CRITICAL();
    1cc6:	0f 90       	pop	r0
    1cc8:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1cca:	8a 81       	ldd	r24, Y+2	; 0x02
    1ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    1cce:	95 d0       	rcall	.+298    	; 0x1dfa <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1cd0:	80 91 4c 0e 	lds	r24, 0x0E4C
    1cd4:	88 23       	and	r24, r24
    1cd6:	81 f6       	brne	.-96     	; 0x1c78 <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    1cd8:	0f 90       	pop	r0
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	08 95       	ret

00001ce4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	1f 92       	push	r1
    1cea:	1f 92       	push	r1
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	9a 83       	std	Y+2, r25	; 0x02
    1cf2:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1cf4:	80 91 fe 0d 	lds	r24, 0x0DFE
    1cf8:	90 91 ff 0d 	lds	r25, 0x0DFF
    1cfc:	29 81       	ldd	r18, Y+1	; 0x01
    1cfe:	3a 81       	ldd	r19, Y+2	; 0x02
    1d00:	fc 01       	movw	r30, r24
    1d02:	33 83       	std	Z+3, r19	; 0x03
    1d04:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    1d06:	80 91 4e 0e 	lds	r24, 0x0E4E
    1d0a:	90 91 4f 0e 	lds	r25, 0x0E4F
    1d0e:	29 81       	ldd	r18, Y+1	; 0x01
    1d10:	3a 81       	ldd	r19, Y+2	; 0x02
    1d12:	28 17       	cp	r18, r24
    1d14:	39 07       	cpc	r19, r25
    1d16:	78 f4       	brcc	.+30     	; 0x1d36 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d18:	80 91 fe 0d 	lds	r24, 0x0DFE
    1d1c:	90 91 ff 0d 	lds	r25, 0x0DFF
    1d20:	9c 01       	movw	r18, r24
    1d22:	2e 5f       	subi	r18, 0xFE	; 254
    1d24:	3f 4f       	sbci	r19, 0xFF	; 255
    1d26:	80 91 38 0e 	lds	r24, 0x0E38
    1d2a:	90 91 39 0e 	lds	r25, 0x0E39
    1d2e:	b9 01       	movw	r22, r18
    1d30:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsert>
    1d34:	1d c0       	rjmp	.+58     	; 0x1d70 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d36:	80 91 fe 0d 	lds	r24, 0x0DFE
    1d3a:	90 91 ff 0d 	lds	r25, 0x0DFF
    1d3e:	9c 01       	movw	r18, r24
    1d40:	2e 5f       	subi	r18, 0xFE	; 254
    1d42:	3f 4f       	sbci	r19, 0xFF	; 255
    1d44:	80 91 36 0e 	lds	r24, 0x0E36
    1d48:	90 91 37 0e 	lds	r25, 0x0E37
    1d4c:	b9 01       	movw	r22, r18
    1d4e:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1d52:	80 91 00 02 	lds	r24, 0x0200
    1d56:	90 91 01 02 	lds	r25, 0x0201
    1d5a:	29 81       	ldd	r18, Y+1	; 0x01
    1d5c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d5e:	28 17       	cp	r18, r24
    1d60:	39 07       	cpc	r19, r25
    1d62:	30 f4       	brcc	.+12     	; 0x1d70 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1d64:	89 81       	ldd	r24, Y+1	; 0x01
    1d66:	9a 81       	ldd	r25, Y+2	; 0x02
    1d68:	90 93 01 02 	sts	0x0201, r25
    1d6c:	80 93 00 02 	sts	0x0200, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	08 95       	ret

00001d7a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	cd b7       	in	r28, 0x3d	; 61
    1d80:	de b7       	in	r29, 0x3e	; 62
    1d82:	28 97       	sbiw	r28, 0x08	; 8
    1d84:	0f b6       	in	r0, 0x3f	; 63
    1d86:	f8 94       	cli
    1d88:	de bf       	out	0x3e, r29	; 62
    1d8a:	0f be       	out	0x3f, r0	; 63
    1d8c:	cd bf       	out	0x3d, r28	; 61
    1d8e:	9e 83       	std	Y+6, r25	; 0x06
    1d90:	8d 83       	std	Y+5, r24	; 0x05
    1d92:	78 87       	std	Y+8, r23	; 0x08
    1d94:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d96:	8f 81       	ldd	r24, Y+7	; 0x07
    1d98:	98 85       	ldd	r25, Y+8	; 0x08
    1d9a:	89 2b       	or	r24, r25
    1d9c:	21 f4       	brne	.+8      	; 0x1da6 <prvAllocateTCBAndStack+0x2c>
    1d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1da0:	9e 81       	ldd	r25, Y+6	; 0x06
    1da2:	26 d8       	rcall	.-4020   	; 0xdf0 <pvPortMalloc>
    1da4:	02 c0       	rjmp	.+4      	; 0x1daa <prvAllocateTCBAndStack+0x30>
    1da6:	8f 81       	ldd	r24, Y+7	; 0x07
    1da8:	98 85       	ldd	r25, Y+8	; 0x08
    1daa:	9c 83       	std	Y+4, r25	; 0x04
    1dac:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    1dae:	8b 81       	ldd	r24, Y+3	; 0x03
    1db0:	9c 81       	ldd	r25, Y+4	; 0x04
    1db2:	89 2b       	or	r24, r25
    1db4:	a9 f0       	breq	.+42     	; 0x1de0 <prvAllocateTCBAndStack+0x66>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1db6:	86 e2       	ldi	r24, 0x26	; 38
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	1a d8       	rcall	.-4044   	; 0xdf0 <pvPortMalloc>
    1dbc:	9a 83       	std	Y+2, r25	; 0x02
    1dbe:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    1dc0:	89 81       	ldd	r24, Y+1	; 0x01
    1dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1dc4:	89 2b       	or	r24, r25
    1dc6:	41 f0       	breq	.+16     	; 0x1dd8 <prvAllocateTCBAndStack+0x5e>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1dc8:	89 81       	ldd	r24, Y+1	; 0x01
    1dca:	9a 81       	ldd	r25, Y+2	; 0x02
    1dcc:	2b 81       	ldd	r18, Y+3	; 0x03
    1dce:	3c 81       	ldd	r19, Y+4	; 0x04
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	30 8f       	std	Z+24, r19	; 0x18
    1dd4:	27 8b       	std	Z+23, r18	; 0x17
    1dd6:	06 c0       	rjmp	.+12     	; 0x1de4 <prvAllocateTCBAndStack+0x6a>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dda:	9c 81       	ldd	r25, Y+4	; 0x04
    1ddc:	5c d8       	rcall	.-3912   	; 0xe96 <vPortFree>
    1dde:	02 c0       	rjmp	.+4      	; 0x1de4 <prvAllocateTCBAndStack+0x6a>
			}
		}
		else
		{
			pxNewTCB = NULL;
    1de0:	1a 82       	std	Y+2, r1	; 0x02
    1de2:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1de8:	28 96       	adiw	r28, 0x08	; 8
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	de bf       	out	0x3e, r29	; 62
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	cd bf       	out	0x3d, r28	; 61
    1df4:	df 91       	pop	r29
    1df6:	cf 91       	pop	r28
    1df8:	08 95       	ret

00001dfa <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1dfa:	cf 93       	push	r28
    1dfc:	df 93       	push	r29
    1dfe:	1f 92       	push	r1
    1e00:	1f 92       	push	r1
    1e02:	cd b7       	in	r28, 0x3d	; 61
    1e04:	de b7       	in	r29, 0x3e	; 62
    1e06:	9a 83       	std	Y+2, r25	; 0x02
    1e08:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    1e0a:	89 81       	ldd	r24, Y+1	; 0x01
    1e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0e:	fc 01       	movw	r30, r24
    1e10:	87 89       	ldd	r24, Z+23	; 0x17
    1e12:	90 8d       	ldd	r25, Z+24	; 0x18
    1e14:	40 d8       	rcall	.-3968   	; 0xe96 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    1e16:	89 81       	ldd	r24, Y+1	; 0x01
    1e18:	9a 81       	ldd	r25, Y+2	; 0x02
    1e1a:	3d d8       	rcall	.-3974   	; 0xe96 <vPortFree>
	}
    1e1c:	0f 90       	pop	r0
    1e1e:	0f 90       	pop	r0
    1e20:	df 91       	pop	r29
    1e22:	cf 91       	pop	r28
    1e24:	08 95       	ret

00001e26 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1e26:	cf 93       	push	r28
    1e28:	df 93       	push	r29
    1e2a:	1f 92       	push	r1
    1e2c:	1f 92       	push	r1
    1e2e:	cd b7       	in	r28, 0x3d	; 61
    1e30:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1e32:	80 91 36 0e 	lds	r24, 0x0E36
    1e36:	90 91 37 0e 	lds	r25, 0x0E37
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	80 81       	ld	r24, Z
    1e3e:	88 23       	and	r24, r24
    1e40:	39 f4       	brne	.+14     	; 0x1e50 <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1e42:	8f ef       	ldi	r24, 0xFF	; 255
    1e44:	9f ef       	ldi	r25, 0xFF	; 255
    1e46:	90 93 01 02 	sts	0x0201, r25
    1e4a:	80 93 00 02 	sts	0x0200, r24
    1e4e:	15 c0       	rjmp	.+42     	; 0x1e7a <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1e50:	80 91 36 0e 	lds	r24, 0x0E36
    1e54:	90 91 37 0e 	lds	r25, 0x0E37
    1e58:	fc 01       	movw	r30, r24
    1e5a:	85 81       	ldd	r24, Z+5	; 0x05
    1e5c:	96 81       	ldd	r25, Z+6	; 0x06
    1e5e:	fc 01       	movw	r30, r24
    1e60:	86 81       	ldd	r24, Z+6	; 0x06
    1e62:	97 81       	ldd	r25, Z+7	; 0x07
    1e64:	9a 83       	std	Y+2, r25	; 0x02
    1e66:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1e68:	89 81       	ldd	r24, Y+1	; 0x01
    1e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	82 81       	ldd	r24, Z+2	; 0x02
    1e70:	93 81       	ldd	r25, Z+3	; 0x03
    1e72:	90 93 01 02 	sts	0x0201, r25
    1e76:	80 93 00 02 	sts	0x0200, r24
	}
}
    1e7a:	0f 90       	pop	r0
    1e7c:	0f 90       	pop	r0
    1e7e:	df 91       	pop	r29
    1e80:	cf 91       	pop	r28
    1e82:	08 95       	ret

00001e84 <vTask>:
SemaphoreHandle_t xSemaphore;
QueueHandle_t xQueue1;
TaskHandle_t x1Handle;
TaskHandle_t x2Handle;

void vTask(void *pvParameters) {
    1e84:	cf 93       	push	r28
    1e86:	df 93       	push	r29
    1e88:	00 d0       	rcall	.+0      	; 0x1e8a <vTask+0x6>
    1e8a:	00 d0       	rcall	.+0      	; 0x1e8c <vTask+0x8>
    1e8c:	cd b7       	in	r28, 0x3d	; 61
    1e8e:	de b7       	in	r29, 0x3e	; 62
    1e90:	9e 83       	std	Y+6, r25	; 0x06
    1e92:	8d 83       	std	Y+5, r24	; 0x05
	portTickType xLastWakeTime = xTaskGetTickCount();
    1e94:	2a dc       	rcall	.-1964   	; 0x16ea <xTaskGetTickCount>
    1e96:	9c 83       	std	Y+4, r25	; 0x04
    1e98:	8b 83       	std	Y+3, r24	; 0x03
	volatile TaskParam *pxTaskParam = (TaskParam*) pvParameters;
    1e9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1e9e:	9a 83       	std	Y+2, r25	; 0x02
    1ea0:	89 83       	std	Y+1, r24	; 0x01

	vTaskDelay(pxTaskParam -> initDelay);
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	86 81       	ldd	r24, Z+6	; 0x06
    1eaa:	97 81       	ldd	r25, Z+7	; 0x07
    1eac:	a0 85       	ldd	r26, Z+8	; 0x08
    1eae:	b1 85       	ldd	r27, Z+9	; 0x09
    1eb0:	20 db       	rcall	.-2496   	; 0x14f2 <vTaskDelay>

	xLastWakeTime = xTaskGetTickCount();
    1eb2:	1b dc       	rcall	.-1994   	; 0x16ea <xTaskGetTickCount>
    1eb4:	9c 83       	std	Y+4, r25	; 0x04
    1eb6:	8b 83       	std	Y+3, r24	; 0x03

	while (1) {
		PORTA ^= pxTaskParam -> pin;
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
    1eba:	9a 81       	ldd	r25, Y+2	; 0x02
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	40 81       	ld	r20, Z
    1ec0:	51 81       	ldd	r21, Z+1	; 0x01
    1ec2:	82 e2       	ldi	r24, 0x22	; 34
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	22 e2       	ldi	r18, 0x22	; 34
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	f9 01       	movw	r30, r18
    1ecc:	20 81       	ld	r18, Z
    1ece:	32 2f       	mov	r19, r18
    1ed0:	24 2f       	mov	r18, r20
    1ed2:	23 27       	eor	r18, r19
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	20 83       	st	Z, r18
		vTaskDelayUntil(&xLastWakeTime, pxTaskParam -> period / portTICK_RATE_MS);		
    1ed8:	89 81       	ldd	r24, Y+1	; 0x01
    1eda:	9a 81       	ldd	r25, Y+2	; 0x02
    1edc:	fc 01       	movw	r30, r24
    1ede:	82 81       	ldd	r24, Z+2	; 0x02
    1ee0:	93 81       	ldd	r25, Z+3	; 0x03
    1ee2:	a4 81       	ldd	r26, Z+4	; 0x04
    1ee4:	b5 81       	ldd	r27, Z+5	; 0x05
    1ee6:	9c 01       	movw	r18, r24
    1ee8:	ce 01       	movw	r24, r28
    1eea:	03 96       	adiw	r24, 0x03	; 3
    1eec:	b9 01       	movw	r22, r18
    1eee:	8c da       	rcall	.-2792   	; 0x1408 <vTaskDelayUntil>
		taskYIELD();
    1ef0:	0e 94 84 05 	call	0xb08	; 0xb08 <vPortYield>
	}
    1ef4:	e1 cf       	rjmp	.-62     	; 0x1eb8 <vTask+0x34>

00001ef6 <main>:
	vTaskDelete(NULL);
}

int main( void )
{
    1ef6:	af 92       	push	r10
    1ef8:	bf 92       	push	r11
    1efa:	cf 92       	push	r12
    1efc:	df 92       	push	r13
    1efe:	ef 92       	push	r14
    1f00:	ff 92       	push	r15
    1f02:	0f 93       	push	r16
    1f04:	cf 93       	push	r28
    1f06:	df 93       	push	r29
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	64 97       	sbiw	r28, 0x14	; 20
    1f0e:	0f b6       	in	r0, 0x3f	; 63
    1f10:	f8 94       	cli
    1f12:	de bf       	out	0x3e, r29	; 62
    1f14:	0f be       	out	0x3f, r0	; 63
    1f16:	cd bf       	out	0x3d, r28	; 61
	TaskParam xTP1, xTP2;
	DDRA = 0xff;
    1f18:	81 e2       	ldi	r24, 0x21	; 33
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	2f ef       	ldi	r18, 0xFF	; 255
    1f1e:	fc 01       	movw	r30, r24
    1f20:	20 83       	st	Z, r18
	PORTA = 0xff;
    1f22:	82 e2       	ldi	r24, 0x22	; 34
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	2f ef       	ldi	r18, 0xFF	; 255
    1f28:	fc 01       	movw	r30, r24
    1f2a:	20 83       	st	Z, r18

	xTP1.pin = 128;
    1f2c:	80 e8       	ldi	r24, 0x80	; 128
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	9a 83       	std	Y+2, r25	; 0x02
    1f32:	89 83       	std	Y+1, r24	; 0x01
	xTP1.period = 1000;
    1f34:	88 ee       	ldi	r24, 0xE8	; 232
    1f36:	93 e0       	ldi	r25, 0x03	; 3
    1f38:	a0 e0       	ldi	r26, 0x00	; 0
    1f3a:	b0 e0       	ldi	r27, 0x00	; 0
    1f3c:	8b 83       	std	Y+3, r24	; 0x03
    1f3e:	9c 83       	std	Y+4, r25	; 0x04
    1f40:	ad 83       	std	Y+5, r26	; 0x05
    1f42:	be 83       	std	Y+6, r27	; 0x06
	xTP1.initDelay = 0;
    1f44:	1f 82       	std	Y+7, r1	; 0x07
    1f46:	18 86       	std	Y+8, r1	; 0x08
    1f48:	19 86       	std	Y+9, r1	; 0x09
    1f4a:	1a 86       	std	Y+10, r1	; 0x0a
	xTaskCreate(vTask, "Task 1", configMINIMAL_STACK_SIZE, &xTP1,
    1f4c:	a1 2c       	mov	r10, r1
    1f4e:	b1 2c       	mov	r11, r1
    1f50:	c1 2c       	mov	r12, r1
    1f52:	d1 2c       	mov	r13, r1
    1f54:	e1 2c       	mov	r14, r1
    1f56:	f1 2c       	mov	r15, r1
    1f58:	05 e0       	ldi	r16, 0x05	; 5
    1f5a:	ce 01       	movw	r24, r28
    1f5c:	01 96       	adiw	r24, 0x01	; 1
    1f5e:	9c 01       	movw	r18, r24
    1f60:	49 eb       	ldi	r20, 0xB9	; 185
    1f62:	50 e0       	ldi	r21, 0x00	; 0
    1f64:	67 e0       	ldi	r22, 0x07	; 7
    1f66:	72 e0       	ldi	r23, 0x02	; 2
    1f68:	82 e4       	ldi	r24, 0x42	; 66
    1f6a:	9f e0       	ldi	r25, 0x0F	; 15
    1f6c:	6c d9       	rcall	.-3368   	; 0x1246 <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);

	xTP2.pin = 64;
    1f6e:	80 e4       	ldi	r24, 0x40	; 64
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	9c 87       	std	Y+12, r25	; 0x0c
    1f74:	8b 87       	std	Y+11, r24	; 0x0b
	xTP2.period = 1000;
    1f76:	88 ee       	ldi	r24, 0xE8	; 232
    1f78:	93 e0       	ldi	r25, 0x03	; 3
    1f7a:	a0 e0       	ldi	r26, 0x00	; 0
    1f7c:	b0 e0       	ldi	r27, 0x00	; 0
    1f7e:	8d 87       	std	Y+13, r24	; 0x0d
    1f80:	9e 87       	std	Y+14, r25	; 0x0e
    1f82:	af 87       	std	Y+15, r26	; 0x0f
    1f84:	b8 8b       	std	Y+16, r27	; 0x10
	xTP2.initDelay = 500;
    1f86:	84 ef       	ldi	r24, 0xF4	; 244
    1f88:	91 e0       	ldi	r25, 0x01	; 1
    1f8a:	a0 e0       	ldi	r26, 0x00	; 0
    1f8c:	b0 e0       	ldi	r27, 0x00	; 0
    1f8e:	89 8b       	std	Y+17, r24	; 0x11
    1f90:	9a 8b       	std	Y+18, r25	; 0x12
    1f92:	ab 8b       	std	Y+19, r26	; 0x13
    1f94:	bc 8b       	std	Y+20, r27	; 0x14
	xTaskCreate(vTask, "Task 2", configMINIMAL_STACK_SIZE, &xTP2,
    1f96:	ce 01       	movw	r24, r28
    1f98:	0b 96       	adiw	r24, 0x0b	; 11
    1f9a:	a1 2c       	mov	r10, r1
    1f9c:	b1 2c       	mov	r11, r1
    1f9e:	c1 2c       	mov	r12, r1
    1fa0:	d1 2c       	mov	r13, r1
    1fa2:	e1 2c       	mov	r14, r1
    1fa4:	f1 2c       	mov	r15, r1
    1fa6:	05 e0       	ldi	r16, 0x05	; 5
    1fa8:	9c 01       	movw	r18, r24
    1faa:	49 eb       	ldi	r20, 0xB9	; 185
    1fac:	50 e0       	ldi	r21, 0x00	; 0
    1fae:	6e e0       	ldi	r22, 0x0E	; 14
    1fb0:	72 e0       	ldi	r23, 0x02	; 2
    1fb2:	82 e4       	ldi	r24, 0x42	; 66
    1fb4:	9f e0       	ldi	r25, 0x0F	; 15
    1fb6:	47 d9       	rcall	.-3442   	; 0x1246 <xTaskGenericCreate>
	task1_TASK_PRIORITY, NULL);
	
	vTaskStartScheduler();
    1fb8:	cd da       	rcall	.-2662   	; 0x1554 <vTaskStartScheduler>

	return 0;
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
}
    1fbe:	64 96       	adiw	r28, 0x14	; 20
    1fc0:	0f b6       	in	r0, 0x3f	; 63
    1fc2:	f8 94       	cli
    1fc4:	de bf       	out	0x3e, r29	; 62
    1fc6:	0f be       	out	0x3f, r0	; 63
    1fc8:	cd bf       	out	0x3d, r28	; 61
    1fca:	df 91       	pop	r29
    1fcc:	cf 91       	pop	r28
    1fce:	0f 91       	pop	r16
    1fd0:	ff 90       	pop	r15
    1fd2:	ef 90       	pop	r14
    1fd4:	df 90       	pop	r13
    1fd6:	cf 90       	pop	r12
    1fd8:	bf 90       	pop	r11
    1fda:	af 90       	pop	r10
    1fdc:	08 95       	ret

00001fde <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	cd b7       	in	r28, 0x3d	; 61
    1fe4:	de b7       	in	r29, 0x3e	; 62
	vCoRoutineSchedule();
    1fe6:	0e 94 06 03 	call	0x60c	; 0x60c <vCoRoutineSchedule>
}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	08 95       	ret

00001ff0 <__vector_default>:

ISR(BADISR_vect)
{
    1ff0:	1f 92       	push	r1
    1ff2:	0f 92       	push	r0
    1ff4:	00 90 5f 00 	lds	r0, 0x005F
    1ff8:	0f 92       	push	r0
    1ffa:	11 24       	eor	r1, r1
    1ffc:	00 90 5b 00 	lds	r0, 0x005B
    2000:	0f 92       	push	r0
    2002:	2f 93       	push	r18
    2004:	3f 93       	push	r19
    2006:	8f 93       	push	r24
    2008:	9f 93       	push	r25
    200a:	ef 93       	push	r30
    200c:	ff 93       	push	r31
    200e:	cf 93       	push	r28
    2010:	df 93       	push	r29
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
	PORTA &= ~_BV(PA1);
    2016:	82 e2       	ldi	r24, 0x22	; 34
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	22 e2       	ldi	r18, 0x22	; 34
    201c:	30 e0       	ldi	r19, 0x00	; 0
    201e:	f9 01       	movw	r30, r18
    2020:	20 81       	ld	r18, Z
    2022:	2d 7f       	andi	r18, 0xFD	; 253
    2024:	fc 01       	movw	r30, r24
    2026:	20 83       	st	Z, r18
}
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	ff 91       	pop	r31
    202e:	ef 91       	pop	r30
    2030:	9f 91       	pop	r25
    2032:	8f 91       	pop	r24
    2034:	3f 91       	pop	r19
    2036:	2f 91       	pop	r18
    2038:	0f 90       	pop	r0
    203a:	00 92 5b 00 	sts	0x005B, r0
    203e:	0f 90       	pop	r0
    2040:	00 92 5f 00 	sts	0x005F, r0
    2044:	0f 90       	pop	r0
    2046:	1f 90       	pop	r1
    2048:	18 95       	reti

0000204a <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    204a:	cf 93       	push	r28
    204c:	df 93       	push	r29
    204e:	00 d0       	rcall	.+0      	; 0x2050 <vApplicationStackOverflowHook+0x6>
    2050:	1f 92       	push	r1
    2052:	cd b7       	in	r28, 0x3d	; 61
    2054:	de b7       	in	r29, 0x3e	; 62
    2056:	9a 83       	std	Y+2, r25	; 0x02
    2058:	89 83       	std	Y+1, r24	; 0x01
    205a:	7c 83       	std	Y+4, r23	; 0x04
    205c:	6b 83       	std	Y+3, r22	; 0x03
	PORTA |= _BV(PA7);
    205e:	82 e2       	ldi	r24, 0x22	; 34
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	22 e2       	ldi	r18, 0x22	; 34
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	f9 01       	movw	r30, r18
    2068:	20 81       	ld	r18, Z
    206a:	20 68       	ori	r18, 0x80	; 128
    206c:	fc 01       	movw	r30, r24
    206e:	20 83       	st	Z, r18
    2070:	0f 90       	pop	r0
    2072:	0f 90       	pop	r0
    2074:	0f 90       	pop	r0
    2076:	0f 90       	pop	r0
    2078:	df 91       	pop	r29
    207a:	cf 91       	pop	r28
    207c:	08 95       	ret

0000207e <__vector_25>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
ISR(USART0_RX_vect)
{
    207e:	1f 92       	push	r1
    2080:	0f 92       	push	r0
    2082:	00 90 5f 00 	lds	r0, 0x005F
    2086:	0f 92       	push	r0
    2088:	11 24       	eor	r1, r1
    208a:	00 90 5b 00 	lds	r0, 0x005B
    208e:	0f 92       	push	r0
    2090:	2f 93       	push	r18
    2092:	3f 93       	push	r19
    2094:	4f 93       	push	r20
    2096:	5f 93       	push	r21
    2098:	6f 93       	push	r22
    209a:	7f 93       	push	r23
    209c:	8f 93       	push	r24
    209e:	9f 93       	push	r25
    20a0:	af 93       	push	r26
    20a2:	bf 93       	push	r27
    20a4:	ef 93       	push	r30
    20a6:	ff 93       	push	r31
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
    20ac:	1f 92       	push	r1
    20ae:	1f 92       	push	r1
    20b0:	cd b7       	in	r28, 0x3d	; 61
    20b2:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    20b4:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    20b6:	86 ec       	ldi	r24, 0xC6	; 198
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	fc 01       	movw	r30, r24
    20bc:	80 81       	ld	r24, Z
    20be:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    20c0:	80 91 57 0e 	lds	r24, 0x0E57
    20c4:	90 91 58 0e 	lds	r25, 0x0E58
    20c8:	ae 01       	movw	r20, r28
    20ca:	4e 5f       	subi	r20, 0xFE	; 254
    20cc:	5f 4f       	sbci	r21, 0xFF	; 255
    20ce:	20 e0       	ldi	r18, 0x00	; 0
    20d0:	be 01       	movw	r22, r28
    20d2:	6f 5f       	subi	r22, 0xFF	; 255
    20d4:	7f 4f       	sbci	r23, 0xFF	; 255
    20d6:	0e 94 58 07 	call	0xeb0	; 0xeb0 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    20da:	8a 81       	ldd	r24, Y+2	; 0x02
    20dc:	88 23       	and	r24, r24
    20de:	11 f0       	breq	.+4      	; 0x20e4 <__vector_25+0x66>
	{
		taskYIELD();
    20e0:	0e 94 84 05 	call	0xb08	; 0xb08 <vPortYield>
	}
}
    20e4:	0f 90       	pop	r0
    20e6:	0f 90       	pop	r0
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	ff 91       	pop	r31
    20ee:	ef 91       	pop	r30
    20f0:	bf 91       	pop	r27
    20f2:	af 91       	pop	r26
    20f4:	9f 91       	pop	r25
    20f6:	8f 91       	pop	r24
    20f8:	7f 91       	pop	r23
    20fa:	6f 91       	pop	r22
    20fc:	5f 91       	pop	r21
    20fe:	4f 91       	pop	r20
    2100:	3f 91       	pop	r19
    2102:	2f 91       	pop	r18
    2104:	0f 90       	pop	r0
    2106:	00 92 5b 00 	sts	0x005B, r0
    210a:	0f 90       	pop	r0
    210c:	00 92 5f 00 	sts	0x005F, r0
    2110:	0f 90       	pop	r0
    2112:	1f 90       	pop	r1
    2114:	18 95       	reti

00002116 <__vector_26>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
ISR(USART0_UDRE_vect)
{
    2116:	1f 92       	push	r1
    2118:	0f 92       	push	r0
    211a:	00 90 5f 00 	lds	r0, 0x005F
    211e:	0f 92       	push	r0
    2120:	11 24       	eor	r1, r1
    2122:	00 90 5b 00 	lds	r0, 0x005B
    2126:	0f 92       	push	r0
    2128:	2f 93       	push	r18
    212a:	3f 93       	push	r19
    212c:	4f 93       	push	r20
    212e:	5f 93       	push	r21
    2130:	6f 93       	push	r22
    2132:	7f 93       	push	r23
    2134:	8f 93       	push	r24
    2136:	9f 93       	push	r25
    2138:	af 93       	push	r26
    213a:	bf 93       	push	r27
    213c:	ef 93       	push	r30
    213e:	ff 93       	push	r31
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	00 d0       	rcall	.+0      	; 0x2146 <__vector_26+0x30>
    2146:	cd b7       	in	r28, 0x3d	; 61
    2148:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    214a:	80 91 59 0e 	lds	r24, 0x0E59
    214e:	90 91 5a 0e 	lds	r25, 0x0E5A
    2152:	ae 01       	movw	r20, r28
    2154:	4d 5f       	subi	r20, 0xFD	; 253
    2156:	5f 4f       	sbci	r21, 0xFF	; 255
    2158:	9e 01       	movw	r18, r28
    215a:	2e 5f       	subi	r18, 0xFE	; 254
    215c:	3f 4f       	sbci	r19, 0xFF	; 255
    215e:	b9 01       	movw	r22, r18
    2160:	0e 94 b6 07 	call	0xf6c	; 0xf6c <xQueueReceiveFromISR>
    2164:	81 30       	cpi	r24, 0x01	; 1
    2166:	31 f4       	brne	.+12     	; 0x2174 <__vector_26+0x5e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    2168:	86 ec       	ldi	r24, 0xC6	; 198
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	2a 81       	ldd	r18, Y+2	; 0x02
    216e:	fc 01       	movw	r30, r24
    2170:	20 83       	st	Z, r18
    2172:	0d c0       	rjmp	.+26     	; 0x218e <__vector_26+0x78>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    2174:	81 ec       	ldi	r24, 0xC1	; 193
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	fc 01       	movw	r30, r24
    217a:	80 81       	ld	r24, Z
    217c:	89 83       	std	Y+1, r24	; 0x01
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	8f 7d       	andi	r24, 0xDF	; 223
    2182:	89 83       	std	Y+1, r24	; 0x01
    2184:	81 ec       	ldi	r24, 0xC1	; 193
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	29 81       	ldd	r18, Y+1	; 0x01
    218a:	fc 01       	movw	r30, r24
    218c:	20 83       	st	Z, r18
	}
}
    218e:	0f 90       	pop	r0
    2190:	0f 90       	pop	r0
    2192:	0f 90       	pop	r0
    2194:	df 91       	pop	r29
    2196:	cf 91       	pop	r28
    2198:	ff 91       	pop	r31
    219a:	ef 91       	pop	r30
    219c:	bf 91       	pop	r27
    219e:	af 91       	pop	r26
    21a0:	9f 91       	pop	r25
    21a2:	8f 91       	pop	r24
    21a4:	7f 91       	pop	r23
    21a6:	6f 91       	pop	r22
    21a8:	5f 91       	pop	r21
    21aa:	4f 91       	pop	r20
    21ac:	3f 91       	pop	r19
    21ae:	2f 91       	pop	r18
    21b0:	0f 90       	pop	r0
    21b2:	00 92 5b 00 	sts	0x005B, r0
    21b6:	0f 90       	pop	r0
    21b8:	00 92 5f 00 	sts	0x005F, r0
    21bc:	0f 90       	pop	r0
    21be:	1f 90       	pop	r1
    21c0:	18 95       	reti

000021c2 <__udivmodsi4>:
    21c2:	a1 e2       	ldi	r26, 0x21	; 33
    21c4:	1a 2e       	mov	r1, r26
    21c6:	aa 1b       	sub	r26, r26
    21c8:	bb 1b       	sub	r27, r27
    21ca:	fd 01       	movw	r30, r26
    21cc:	0d c0       	rjmp	.+26     	; 0x21e8 <__udivmodsi4_ep>

000021ce <__udivmodsi4_loop>:
    21ce:	aa 1f       	adc	r26, r26
    21d0:	bb 1f       	adc	r27, r27
    21d2:	ee 1f       	adc	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	a2 17       	cp	r26, r18
    21d8:	b3 07       	cpc	r27, r19
    21da:	e4 07       	cpc	r30, r20
    21dc:	f5 07       	cpc	r31, r21
    21de:	20 f0       	brcs	.+8      	; 0x21e8 <__udivmodsi4_ep>
    21e0:	a2 1b       	sub	r26, r18
    21e2:	b3 0b       	sbc	r27, r19
    21e4:	e4 0b       	sbc	r30, r20
    21e6:	f5 0b       	sbc	r31, r21

000021e8 <__udivmodsi4_ep>:
    21e8:	66 1f       	adc	r22, r22
    21ea:	77 1f       	adc	r23, r23
    21ec:	88 1f       	adc	r24, r24
    21ee:	99 1f       	adc	r25, r25
    21f0:	1a 94       	dec	r1
    21f2:	69 f7       	brne	.-38     	; 0x21ce <__udivmodsi4_loop>
    21f4:	60 95       	com	r22
    21f6:	70 95       	com	r23
    21f8:	80 95       	com	r24
    21fa:	90 95       	com	r25
    21fc:	9b 01       	movw	r18, r22
    21fe:	ac 01       	movw	r20, r24
    2200:	bd 01       	movw	r22, r26
    2202:	cf 01       	movw	r24, r30
    2204:	08 95       	ret

00002206 <memcpy>:
    2206:	fb 01       	movw	r30, r22
    2208:	dc 01       	movw	r26, r24
    220a:	02 c0       	rjmp	.+4      	; 0x2210 <memcpy+0xa>
    220c:	01 90       	ld	r0, Z+
    220e:	0d 92       	st	X+, r0
    2210:	41 50       	subi	r20, 0x01	; 1
    2212:	50 40       	sbci	r21, 0x00	; 0
    2214:	d8 f7       	brcc	.-10     	; 0x220c <memcpy+0x6>
    2216:	08 95       	ret

00002218 <_exit>:
    2218:	f8 94       	cli

0000221a <__stop_program>:
    221a:	ff cf       	rjmp	.-2      	; 0x221a <__stop_program>
